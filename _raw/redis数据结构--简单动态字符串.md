# redis数据结构--简单动态字符串（SDS）
redis自己构建了简单的字符串结构，c语言的字符串类型只用于一些字面量展示    
SDS还被用于缓冲区，AOF模块的缓冲区就是SDS实现的
```c
struct sdshdr {
    //记录buf已经使用的长度
    int len;
    //记录buf数组未使用的字节数量
    int free;
    //字节数组，用于保存字符串
    char buf[];
}
```
![](/images/20181115155008537_833883931.png)

SDS通用遵循着\0结尾的方式，但是不会计入len，这样做的好处是可以使用部分C语言字符串函数
## 与c字符串的区别
### 常数复杂度的获取字符串长度
- SDS获取字符串长度的时间复杂度是o(1)    
- c字符串需要遍历所有的字符串O(n)    
### 杜绝缓冲区溢出
- c字符串由于不知道自己的长度，所以无法校验自身的长度，造成缓冲区溢出
![](/images/20181115160028745_608947995.png)
![](/images/20181115160043863_1829374010.png)
- 对于SDS来说，每次append操作时，都会检查是否存在足够的空间，如果空间不够的话，则会提前分配空间
### 减少修改字符串带来的内存重新分配次数
#### c字符串存在的缺点：
    - 字符串拼接，如果不通过内存重分配扩展足够的空间，则会产生缓冲区溢出
    - 字符串截断，如果不使用内存重新分配来释放字符串不用的空间的话，则会造成内存泄漏
 对于c语言来说，偶尔的进行内存重新分配，其实是可以接受的，但是对于redis这种需要频繁修改的场景来说，内存重分配会占用一大部分时间，造成性能的降低
#### SDS的解决方案：
- 空间预分配
- 当需要对sds进行修改，并且需要对sds进行空间扩展时，
    - 如果对SDS进行修改之后，SDS的大小小于1MB的话，则会给SDS分配相同大小的空闲空间， 即len和free相同
    - 如果对SDS修改之后，SDS的大小大于1MB，则会给SDS分配1MB的空闲空间
- 在对SDS进行扩展操作时，会检查剩余空间是否足够，如果足够的话，则直接插入字符即可
- 这种空间与分配的策略，会将连续N次增长的情况下内存分配的次数从N次变为最多N次
- 惰性空间释放
    - 对于SDS的字符串缩短操作，SDS并不会释放空闲出的空间，而是通过维护free，来等待将来的使用
### 二级制安全
- c字符串使用\0表示字符串的结尾，这使得c字符串不能存储图像，音频视频等文件
- 而对于SDS来说，并不会对\0进行过滤截断等操作，所有的api都是用二进制的方法处理buf中的数据    
- 即存入时是什么样，读取时就是什么样
### 兼容部分C字符串函数
- 由于SDS采用c语言的\0结尾的惯例，所以它可以使用一部分c语言字符串的处理函数

![](/images/20181115163544261_765611971.png)

![](/images/20181115163615120_2065867420.png)
