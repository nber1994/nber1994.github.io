--- 
layout: post 
title: sysDesign-发号器 
tags: sysDesign 
---
# ID生成器
## 要求
ID一定要是全局有序的，再者因为有诸如按照时间排序的场景，所以要求按照时间有序。同时要求尽可能的短
- 按照时间粗略有序
- 尽可能短

## 方案

### 1.使用数据库的auto_increment生成全局递增ID
优点：
- 简单
- 能够全局唯一
- 时间严格递增
缺点：
- 可用性难以保持，主库挂了就挂了
- 扩展性差，主库写性能为上限，难以扩展

### 2.数据库集群
一共有n个节点，每个节点设置不同的auto_increment初始值，已经相同的增长步长
- 优点：
    - 具有较高的可用性和扩展性
- 缺点：
    - 并不是根据时间严格递增

### 3.uuid
数据库生成ID方法，都需要有远程调用。uuid的方法是在本地生成唯一ID
- 4个字节标识unix timestamp
- 3个字节标识机器ID
- 2个字节标识进程ID
- 3个字节标识计数器
- 优点：
    - 高性能，生成很快，不会重复
- 缺点：
    - 较长，查询效率较低
    - 同时不失严格的按照时间有序

### 4.snowflake
核心思想：一个long的ID，41bit作为毫秒数，10bit作为机器编号，12bit作为毫秒内序列号
理论上每秒能生成：1000*2^12个大约400w的ID
* 实现自己的分布式算法
    * 单机并发量
    * 多少个机房
    * 每个机房机器数量
    * 几个业务线
    * 需要几年
1. 假设一个64bit的int值，如果系统预计运行10年，至少需要10*365*24*60*60*1000来算出大致需要多少位
2. 单机的峰值10w，也就是每毫秒大概是100，则需要预留7bit给毫秒内序列号
3. 机房和机器数也按照该规则

![](https://cdn.jsdelivr.net/gh/nber1994/fu0k@master/uPic/20190109123139527_1792787220.png)

* 优点：
    * ID唯一
    * 毫秒在高位，时间递增

## 参考
* [沈剑-发号器](https://chuansongme.com/n/2459549)
