--- 
layout: post 
title: mysql-索引结构 
date: 2019-07-05 16:20:34 
categories: mysql 
---
# mysql-索引结构
> 索引的结构是B+Tree，这个众所周知，但是具体的结构以及原因我们来探究下

## 聚簇索引和非聚簇索引

### 首先要知道
* 聚簇索引即数据行放在索引的叶子页面中，而非聚簇索引则是数据和索引分开存放
* 索引和表属于比较大的数据，所以存放在磁盘中，索引的变更等操作都会导致节点的分裂和新增
* 考量一个索引结构的性能和设计时，不能只考虑查询性能，还要考虑对数据的修改以及对索引调整的复杂度
* 一般一个B+Tree的节点为innodb的一页的大小，即16k

### 聚簇索引
* 数据文件存放在叶子节点中
* 数据存放顺序和索引顺序是一致的，索引相邻的话，磁盘存放位置就是相邻的

### 聚簇索引的特点
* 优点
    * 由于相邻索引的数据是在磁盘相邻存放的，所以可以将一类的数据的索引值相邻，这样一旦查询一类数据时，可以一次读取磁盘，将所有数据都读取，避免了随机读
    * 数据访问会很快，因为到达叶子节点直接就能拿到数据

* 缺点
    * 脱离了IO密集型场景则失去优势
    * 插入速度依赖插入的顺序，如果顺序插入速度最快，**但是会在主键的上界产生明显的竞争**
    * 更新索引列的代价很高，因为会强制的对数据进行移动
    * 使用辅助索引会带来两次查找（自适应哈希索引解决）

> 顺序写入与读取的性能要大于随机写入读取，所以你会发现很多地方的设计其实都是将随机写入转变为顺序写入的，
> 例如mysql的doublewirte，先将需要落磁盘的数据写入内存缓冲区之后，在顺序写入到磁盘的共享表空间中，再写入实际的页面中，来解决写磁盘时崩溃导致的数据丢失问题
> ![](https://cdn.jsdelivr.net/gh/nber1994/fu0k@master/uPic/20190705162621367_360839888.png)


### 非聚簇索引
* 数据和索引分开存放
* 数据的存放于索引的顺序没有关系，叶子节点指向数据的地址

* 优点
    * 插入索引非顺序时也很快
    * 更新索引代价不大，不需要移动数据行

## 两种索引的数据存储
### MyIsam
例如按照下述代码建表，col1为主键
```c
create table layout_test(
    col1 int not null,
    col2 int not null,
    primary key(col1),
    key(col2)
);
```
主键索引的结构是按照行号来组织的，其结构如下
![](https://cdn.jsdelivr.net/gh/nber1994/fu0k@master/uPic/20190704165848911_1484289541.png)
如下图，索引文件按照行号来进行组织，叶子节点存储的是数据行的地址指针
![](https://cdn.jsdelivr.net/gh/nber1994/fu0k@master/uPic/20190704165905564_1284272035.png)

而对于col2对应的索引结构，与主键上的一致

### InnoDB
对于聚簇索引，其主键索引是按照主键索引组织的，其结构大致：
![](https://cdn.jsdelivr.net/gh/nber1994/fu0k@master/uPic/20190704171001101_1842590321.png)

* 其中叶子节点包括
    * 主键值
    * 事务ID
    * 用于MVCC的回流指针
    * 数据列
其大致结构为：
![](https://cdn.jsdelivr.net/gh/nber1994/fu0k@master/uPic/20190704171247519_597744944.png)

而辅助索引，和主键索引有一定区别，叶子节点存放的不是数据而是主键的id
![](https://cdn.jsdelivr.net/gh/nber1994/fu0k@master/uPic/20190704171437857_1734137647.png)
![](https://cdn.jsdelivr.net/gh/nber1994/fu0k@master/uPic/20190704171428341_370773142.png)



## 两种结构的查找过程
![](https://cdn.jsdelivr.net/gh/nber1994/fu0k@master/uPic/20190704213206543_3376045.png)
由此可见，聚簇索引的搜索过程，首先通过辅助索引拿到主键id的值，再走一遍主键索引拿到数据    
而非聚簇索引则是通过辅助索引可以直接拿到数据，似乎聚簇索引会比较慢啊，那为何还会采用这种设计？    
* 首先，聚簇索引的数据和叶子节点在一个页面上，这样主键索引可以直接拿到数据行，速度较快
* 另外，辅助索引使用主键id作为值而非数据行地址，这样能保证主键索引的行不论怎么移动和页分裂，都不会影响到辅助索引
* 同时，聚簇索引还可以结合自适应哈希来提高检索速度

