<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">

        <link href="https://fonts.googleapis.com/css?family=Ubuntu" rel="stylesheet">

        <title>go-scheduler 下</title>

        <link rel="stylesheet" href="/css/stylesheet.css">
    </head>
    <body>
        <section id="page-title">
            <h1><a href="/">nber1994</a></h1>
        </section>



<section class="blog-post">
    <h1>go-scheduler 下</h1>
    <div class="blog-post-subheader">
        November 25, 2021
    </div>
    <div class="blog-post-content">
        <h1 id="三调度器-scheduler">三、调度器 Scheduler</h1>
<h2 id="3-任务窃取调度器--11httpsgithubcomgolanggoblob779c45a50700bda0f6ec98429720802e6c1624e8srcpkgruntimeprocc">3. 任务窃取调度器 · <a href="https://github.com/golang/go/blob/779c45a50700bda0f6ec98429720802e6c1624e8/src/pkg/runtime/proc.c">1.1</a></h2>
<p>2012 年 Google 的工程师 Dmitry Vyukov 在 <a href="http://golang.org/s/go11sched">Scalable Go Scheduler Design Doc</a> 中指出了现有多线程调度器的问题，并且针对出现的问题，针对性的进行了改进设计。</p>
<p>我们来回顾下GM模型带来的问题：</p>
<ul>
<li>mcache泛滥</li>
<li>资源竞争严重</li>
<li>Goroutine传递问题</li>
<li>频繁的线程阻塞/解阻塞</li>
</ul>
<p>下面我们分开来看，为了解决各个问题，分别引入了哪些设计</p>
<h3 id="1-mcache泛滥---引入中间层p">1. mcache泛滥 - 引入中间层P</h3>
<p>在Goroutine和线程之间引入了中间层P，其数量对应于机器的核数，且只有P持有mcache，并且P托管了M运行所需的上下文。每个M都需要绑定到P上才能够获得G。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nber1994/fu0k@master/uPic/image-202111241226080732021112412260820211124151844.png" alt="image-20211124122608073" style="zoom: 50%;" /></p>
<p>这样一来，每个M做到了减重，M变成了一个很干净的系统线程封装。减少了很多冗余的mcache。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">p</span> <span style="color:#66d9ef">struct</span> {
   <span style="color:#a6e22e">lock</span> <span style="color:#a6e22e">mutex</span>

   <span style="color:#a6e22e">id</span>          <span style="color:#66d9ef">int32</span>
   <span style="color:#75715e">// p的状态
</span><span style="color:#75715e"></span>   <span style="color:#a6e22e">status</span>      <span style="color:#66d9ef">uint32</span> <span style="color:#75715e">// one of pidle/prunning/...
</span><span style="color:#75715e"></span>   <span style="color:#75715e">// 下一个p的地址，可参考 g.schedlink
</span><span style="color:#75715e"></span>   <span style="color:#a6e22e">link</span>        <span style="color:#a6e22e">puintptr</span>
   <span style="color:#75715e">// p所关联的m
</span><span style="color:#75715e"></span>   <span style="color:#a6e22e">m</span>           <span style="color:#a6e22e">muintptr</span>   <span style="color:#75715e">// back-link to associated m (nil if idle)
</span><span style="color:#75715e"></span>   <span style="color:#75715e">// 内存分配的时候用的，p所属的m的mcache用的也是这个
</span><span style="color:#75715e"></span>   <span style="color:#a6e22e">mcache</span>      <span style="color:#f92672">*</span><span style="color:#a6e22e">mcache</span>
  
   <span style="color:#75715e">// Cache of goroutine ids, amortizes accesses to runtime·sched.goidgen.
</span><span style="color:#75715e"></span>   <span style="color:#75715e">// 从sched中获取并缓存的id，避免每次分配goid都从sched分配
</span><span style="color:#75715e"></span>     <span style="color:#a6e22e">goidcache</span>    <span style="color:#66d9ef">uint64</span>
     <span style="color:#a6e22e">goidcacheend</span> <span style="color:#66d9ef">uint64</span>

   <span style="color:#75715e">// Queue of runnable goroutines. Accessed without lock.
</span><span style="color:#75715e"></span>   <span style="color:#75715e">// p 本地的runnbale的goroutine形成的队列
</span><span style="color:#75715e"></span>   <span style="color:#a6e22e">runqhead</span> <span style="color:#66d9ef">uint32</span>
   <span style="color:#a6e22e">runqtail</span> <span style="color:#66d9ef">uint32</span>
   <span style="color:#a6e22e">runq</span>     [<span style="color:#ae81ff">256</span>]<span style="color:#a6e22e">guintptr</span>
   <span style="color:#75715e">// 下一个执行的g，如果是nil，则从队列中获取下一个执行的g
</span><span style="color:#75715e"></span>   <span style="color:#a6e22e">runnext</span> <span style="color:#a6e22e">guintptr</span>

   <span style="color:#75715e">// Available G&#39;s (status == Gdead)
</span><span style="color:#75715e"></span>   <span style="color:#75715e">// 状态为 Gdead的g的列表，可以进行复用
</span><span style="color:#75715e"></span>   <span style="color:#a6e22e">gfree</span>    <span style="color:#f92672">*</span><span style="color:#a6e22e">g</span>
   <span style="color:#a6e22e">gfreecnt</span> <span style="color:#66d9ef">int32</span>
}
</code></pre></div><p>我们可以看到，mcache已经被P托管了，并且M只有获得P才能执行</p>
<p><img src="https://cdn.jsdelivr.net/gh/nber1994/fu0k@master/uPic/image-202111241349090142021112413490920211124151846.png" alt="image-20211124134909014" style="zoom: 33%;" /></p>
<h3 id="2-资源竞争严重--goroutine传递问题---p构建本地g队列">2. 资源竞争严重 &amp; Goroutine传递问题 - P构建本地G队列</h3>
<p>为了减少全局锁的竞争，很常见的思路就是减少锁的粒度，在原有全局G队列的基础上，在每个P上也维护了本地G队列，并且保留全局G队列，作为一个G的暂存空间 &amp; 负载均衡使用。而且本G创建的G&rsquo;优先放入本地队列，很好的保证了局部性。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nber1994/fu0k@master/uPic/2019-04-image-20190331160728024-4019648-2021112415184666020211124151846.png" alt="img" style="zoom: 50%;" /></p>
<h4 id="1新建goroutine">1.新建Goroutine</h4>
<p><img src="https://cdn.jsdelivr.net/gh/nber1994/fu0k@master/uPic/2019-04-image-20190331190809649-40304892021112413553720211124151847.png" alt="img"  /></p>
<p>p1拥有g1，m1获取p1后开始运行g1，g1使用<code>go func()</code>创建了g2，为了局部性g2优先加入到p1的本地队列。</p>
<h4 id="2goroutine切换">2.Goroutine切换</h4>
<p><img src="https://cdn.jsdelivr.net/gh/nber1994/fu0k@master/uPic/2019-04-image-20190331190826838-403050620211124135714.png" alt="img"></p>
<h4 id="3全局队列和本地g队列负载均衡">3.全局队列和本地G队列负载均衡</h4>
<p>因为每个p都维护了本地队列，但是这些队列可能存在G不均匀的情况，例如一个P下的G疯狂的在go func()，那么很快P的本地G队列就要满了，如果P创建的G都在P执行的话，那么会出现一核拼命跑，另外几个核在旁边吃瓜的情况，所以引入了负载均衡的策略，当本地G队列满了之后，将一部分G转移到全局G队列，其他P本地G队列空了后，可以从全局队列，来使G均匀的运行在所有P上。</p>
<p><img src="https://lessisbetter.site/images/2019-04-image-20190331160718646-4019638.png" alt="img" style="zoom:50%;" /></p>
<p>假设每个p的本地队列只能存4个g。g2要创建了6个g，前4个g（g3, g4, g5, g6）已经加入p1的本地队列，p1本地队列满了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nber1994/fu0k@master/uPic/2019-04-image-20190331160728024-4019648-2021112415184666020211124151846.png" alt="img" style="zoom: 50%;" /></p>
<p>g2在创建g7的时候，发现p1的本地队列已满，需要执行<strong>负载均衡</strong>，把p1中本地队列中前一半的g，还有新创建的g<strong>转移</strong>到全局队列（实现中并不一定是新的g，如果g是g2之后就执行的，会被保存在本地队列，利用某个老的g替换新g加入全局队列），这些g被转移到全局队列时，会被打乱顺序。所以g3,g4,g7被转移到全局队列。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nber1994/fu0k@master/uPic/2019-04-image-20190331162734830-40208542021112414022220211124151848.png" alt="img"></p>
<p>从全局看，假设还有另外的p2绑定了m2，并且本地队列为空（m自旋状态）</p>
<p><img src="https://cdn.jsdelivr.net/gh/nber1994/fu0k@master/uPic/2019-04-image-20190331162717486-40208372021112414091320211124151848.png" alt="img" style="zoom:67%;" /></p>
<p>此时m2尝试从全局队列(GQ)取一批g放到p2的本地队列（函数：<code>findrunnable</code>）。m2从全局队列取的g数量符合下面的公式：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#a6e22e">n</span> = <span style="color:#a6e22e">min</span>(len(<span style="color:#a6e22e">GQ</span>)<span style="color:#f92672">/</span><span style="color:#a6e22e">GOMAXPROCS</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, len(<span style="color:#a6e22e">GQ</span><span style="color:#f92672">/</span><span style="color:#ae81ff">2</span>))
</code></pre></div><p>总体的含义是说，至少从全局G中拿1个G，但是又不会获取过多，会给其他P预留一些。</p>
<h4 id="4本地g队列负载均衡">4.本地G队列负载均衡</h4>
<p>除了从全局队列中获取G来运行之外，当全局队列为空时，P还会尝试从其他P的本地队列偷取一些来运行，反正总而言之就是让G在全局P上均匀的运行。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nber1994/fu0k@master/uPic/2020-09-go-scheduler-p82021112414142920211124151848.png" alt="img" style="zoom:67%;" /></p>
<p>由此可见，当全局队列为空时，自旋的P2会从P2的本地队列中偷取一半到本地队列进行运行。</p>
<h3 id="3-频繁的线程阻塞">3. 频繁的线程阻塞</h3>
<p>针对Goroutine的不同阻塞情况，GMP模型做了更细化的处理，目的就是为了减少线程阻塞时间，把阻塞的G及时的让出CPU去运行其他线程。</p>
<p>在go中阻塞主要分为以下四种场景：</p>
<ol>
<li>原子性，互斥量或者channel操作导致的Goroutine阻塞</li>
<li>由于网络请求和IO操作导致的Goroutine阻塞</li>
<li>调用一些系统方法时，例如文件读写导致Goroutine阻塞</li>
<li>Goroutine中执行了sleep操作导致Goroutine阻塞</li>
</ol>
<h4 id="netpoller-thread---网络请求和-io阻塞">NetPoller Thread - 网络请求和 IO阻塞</h4>
<p>由于网络请求和 IO 操作导致 Goroutine 阻塞。Go 程序提供了网络轮询器（NetPoller）来处理网络请求和 IO 操作的问题。</p>
<p>其后台通过 kqueue（MacOS），epoll（Linux）或 iocp（Windows）来实现 IO 多路复用。</p>
<p>通过使用 NetPoller 进行网络系统调用，调度器可以防止 Goroutine 在进行这些系统调用时阻塞 M。这可以让 M 执行 P 的 LRQ 中其他的 Goroutines，而不需要创建新的 M。执行网络系统调用不需要额外的 M，<strong>网络轮询器使用系统线程</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/nber1994/fu0k@master/uPic/go_scheduler_async_systemcall_12021112414241620211124151849.png" alt="img" style="zoom:67%;" /></p>
<p>当前G1要进行网络请求，此时G1会被转移到NetPoller进行托管，P从本地G队列获取G2给到M继续执行。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nber1994/fu0k@master/uPic/go_scheduler_async_systemcall_220211124142557.png" alt="img" style="zoom:67%;" /></p>
<p>G1执行完成后，G1放入原P的本地队列，继续等待执行</p>
<p><img src="https://cdn.jsdelivr.net/gh/nber1994/fu0k@master/uPic/go_scheduler_async_systemcall_32021112414263320211124151849.png" alt="img" style="zoom:67%;" /></p>
<h4 id="系统调用阻塞">系统调用阻塞</h4>
<p>G1即将进行阻塞型的同步系统调用</p>
<p><img src="https://cdn.jsdelivr.net/gh/nber1994/fu0k@master/uPic/go_scheduler_sync_systemcall_12021112414273720211124151850.png" alt="img" style="zoom:67%;" /></p>
<p>调度器会将M1，G1和P进行分离，同时引入新的M2来服务P</p>
<p><img src="https://cdn.jsdelivr.net/gh/nber1994/fu0k@master/uPic/go_scheduler_sync_systemcall_220211124142847.png" alt="img" style="zoom:67%;" /></p>
<p>当G1系统调用完成后，G1会回归P的本地队列，等待继续执行</p>
<p><img src="https://cdn.jsdelivr.net/gh/nber1994/fu0k@master/uPic/go_scheduler_sync_systemcall_32021112414292420211124151850.png" alt="img" style="zoom:67%;" /></p>
<h2 id="四抢占式调度器--12httpsgithubcomgolanggoblobgo12srcpkgruntimeprocc--至今">四、抢占式调度器 · <a href="https://github.com/golang/go/blob/go1.2/src/pkg/runtime/proc.c">1.2</a> ~ 至今</h2>
<h4 id="sysmon线程">sysmon线程</h4>
<p>上一个版本，引入了P等一系列措施，基本上解决了GM模型存在的一些问题</p>
<p>我们来回顾下GM模型带来的问题：</p>
<ul>
<li><del>mcache泛滥</del></li>
<li><del>资源竞争严重</del></li>
<li><del>Goroutine传递问题</del></li>
<li>频繁的线程阻塞/解阻塞</li>
</ul>
<p>除了最后一个问题，我们拆开来看</p>
<p>在go中阻塞主要分为以下四种场景：</p>
<ol>
<li>原子性，互斥量或者channel操作导致的Goroutine阻塞</li>
<li><del>由于网络请求和IO操作导致的Goroutine阻塞</del></li>
<li><del>调用一些系统方法时，例如文件读写导致Goroutine阻塞</del></li>
<li>Goroutine中执行了sleep操作导致Goroutine阻塞</li>
</ol>
<p>针对Goroutine内部的诸如原子访问，锁，channel阻塞以及sleep函数休眠等造成的阻塞，GMP借助了系统监控线程sysmon来进行解决，它会每隔一段时间<strong>检查 Go 语言runtime</strong>，确保程序没有进入异常状态。</p>
<p>系统监控的触发时间就会稳定在 10ms，功能比较多:</p>
<ol>
<li>检查死锁runtime.checkdead</li>
<li>运行计时器 — 获取下一个需要被触发的计时器；</li>
<li>定时从 netpoll 中获取 ready 的协程</li>
<li><a href="https://mp.weixin.qq.com/s/d7FdGBc0S0V3S4aRL4EByA">Go 的抢占式调度</a></li>
</ol>
<h3 id="41-基于协作的抢占式调度器---12--113">4.1 基于协作的抢占式调度器 - 1.2 ~ 1.13</h3>
<h4 id="原理">原理</h4>
<p>当 sysmon 发现 M 已运行同一个 G（Goroutine）10ms 以上时，它会将该 G 的内部参数 preempt 设置为 true。然后，在函数序言中，当 G 进行函数调用时，G 会检查自己的 preempt 标志，如果它为 true，则它将自己与 M 分离并推入“全局队列”。</p>
<h4 id="问题">问题</h4>
<p>由于它的工作方式（函数调用触发），在 <code>for{}</code> 的情况下并不会发生抢占，如果没有函数调用，即使设置了抢占标志，也不会进行该标志的检查</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">x</span> <span style="color:#66d9ef">int</span>
	<span style="color:#a6e22e">threads</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">runtime</span>.<span style="color:#a6e22e">GOMAXPROCS</span>(<span style="color:#ae81ff">0</span>)
	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#a6e22e">threads</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
		<span style="color:#66d9ef">go</span> <span style="color:#66d9ef">func</span>() {
			<span style="color:#66d9ef">for</span> { <span style="color:#a6e22e">x</span><span style="color:#f92672">++</span> }
		}()
	}
	<span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Sleep</span>(<span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Second</span>)
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;x =&#34;</span>, <span style="color:#a6e22e">x</span>)
}
</code></pre></div><p>运行结果：</p>
<p>启动了和cpu核心数相同的g，每个g都绑定了一个p，但是每个又进入了for循环，不存在调度点，所有的P都在执行for循环，此时永远都不会到达print。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">x</span> <span style="color:#66d9ef">int</span>
	<span style="color:#a6e22e">threads</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">runtime</span>.<span style="color:#a6e22e">GOMAXPROCS</span>(<span style="color:#ae81ff">0</span>) <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>
	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#a6e22e">threads</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
		<span style="color:#66d9ef">go</span> <span style="color:#66d9ef">func</span>() {
			<span style="color:#66d9ef">for</span> { <span style="color:#a6e22e">x</span><span style="color:#f92672">++</span> }
		}()
	}
	<span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Sleep</span>(<span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Second</span>)
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;x =&#34;</span>, <span style="color:#a6e22e">x</span>)
}
</code></pre></div><p>运行结果</p>
<pre><code>x = 0
</code></pre><h3 id="42-基于信号的抢占式调度器---114--至今">4.2 基于信号的抢占式调度器 - 1.14 ~ 至今</h3>
<h4 id="原理-1">原理</h4>
<p>Go1.14 引入抢占式调度（使用信号的异步抢占机制），sysmon 仍然会检测到运行了 10ms 以上的 G（goroutine）。然后，sysmon 向运行 G 的 P 发送信号（SIGURG）。Go 的信号处理程序会调用P上的一个叫作 gsignal 的 goroutine 来处理该信号，将其映射到 M 而不是 G，并使其检查该信号。gsignal 看到抢占信号，停止正在运行的 G。</p>
<h3 id="43-gmp-scheduler角色介绍">4.3 GMP Scheduler角色介绍</h3>
<p><img src="https://cdn.jsdelivr.net/gh/nber1994/fu0k@master/uPic/image-202111241226080732021112412260820211124151844.png" alt="image-20211124122608073" style="zoom: 50%;" /></p>
<h4 id="g">G</h4>
<p>goroutine是运行时的最小执行单元</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">g</span> <span style="color:#66d9ef">struct</span> {
    <span style="color:#75715e">// Stack parameters.
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// stack describes the actual stack memory: [stack.lo, stack.hi).
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// stackguard0 is the stack pointer compared in the Go stack growth prologue.
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// It is stack.lo+StackGuard normally, but can be StackPreempt to trigger a preemption.
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// stackguard1 is the stack pointer compared in the C stack growth prologue.
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// It is stack.lo+StackGuard on g0 and gsignal stacks.
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// It is ~0 on other goroutine stacks, to trigger a call to morestackc (and crash).
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// 当前g使用的栈空间，stack结构包括 [lo, hi]两个成员
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">stack</span>       <span style="color:#a6e22e">stack</span>   <span style="color:#75715e">// offset known to runtime/cgo
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// 用于检测是否需要进行栈扩张，go代码使用
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">stackguard0</span> <span style="color:#66d9ef">uintptr</span> <span style="color:#75715e">// offset known to liblink
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// 用于检测是否需要进行栈扩展，原生代码使用的
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">stackguard1</span> <span style="color:#66d9ef">uintptr</span> <span style="color:#75715e">// offset known to liblink
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// 当前g所绑定的m
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">m</span>              <span style="color:#f92672">*</span><span style="color:#a6e22e">m</span>      <span style="color:#75715e">// current m; offset known to arm liblink
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// 当前g的调度数据，当goroutine切换时，保存当前g的上下文，用于恢复
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">sched</span>          <span style="color:#a6e22e">gobuf</span>
    <span style="color:#75715e">// g当前的状态
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">atomicstatus</span>   <span style="color:#66d9ef">uint32</span>
  <span style="color:#75715e">// 当前g的id
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">goid</span>           <span style="color:#66d9ef">int64</span>
  <span style="color:#75715e">// 下一个g的地址，通过guintptr结构体的ptr set函数可以设置和获取下一个g，通过这个字段和sched.gfreeStack sched.gfreeNoStack 可以把 free g串成一个链表
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">schedlink</span>      <span style="color:#a6e22e">guintptr</span>
  <span style="color:#75715e">// 判断g是否允许被抢占
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">preempt</span>        <span style="color:#66d9ef">bool</span>       <span style="color:#75715e">// preemption signal, duplicates stackguard0 = stackpreempt
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// g是否要求要回到这个M执行, 有的时候g中断了恢复会要求使用原来的M执行
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">lockedm</span>        <span style="color:#a6e22e">muintptr</span>
}
</code></pre></div><h4 id="m">M</h4>
<p>系统线程封装</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">m</span> <span style="color:#66d9ef">struct</span> {
   <span style="color:#75715e">// g0是用于调度和执行系统调用的特殊g
</span><span style="color:#75715e"></span>   <span style="color:#a6e22e">g0</span>      <span style="color:#f92672">*</span><span style="color:#a6e22e">g</span>     <span style="color:#75715e">// goroutine with scheduling stack
</span><span style="color:#75715e"></span>     <span style="color:#75715e">// m当前运行的g
</span><span style="color:#75715e"></span>   <span style="color:#a6e22e">curg</span>          <span style="color:#f92672">*</span><span style="color:#a6e22e">g</span>       <span style="color:#75715e">// current running goroutine
</span><span style="color:#75715e"></span>   <span style="color:#75715e">// 当前拥有的p
</span><span style="color:#75715e"></span>   <span style="color:#a6e22e">p</span>             <span style="color:#a6e22e">puintptr</span> <span style="color:#75715e">// attached p for executing go code (nil if not executing go code)
</span><span style="color:#75715e"></span>   <span style="color:#75715e">// 线程的 local storage
</span><span style="color:#75715e"></span>   <span style="color:#a6e22e">tls</span>           [<span style="color:#ae81ff">6</span>]<span style="color:#66d9ef">uintptr</span>   <span style="color:#75715e">// thread-local storage
</span><span style="color:#75715e"></span>   <span style="color:#75715e">// 唤醒m时，m会拥有这个p
</span><span style="color:#75715e"></span>   <span style="color:#a6e22e">nextp</span>         <span style="color:#a6e22e">puintptr</span>
   <span style="color:#a6e22e">id</span>            <span style="color:#66d9ef">int64</span>
   <span style="color:#75715e">// 如果 !=&#34;&#34;, 继续运行curg
</span><span style="color:#75715e"></span>   <span style="color:#a6e22e">preemptoff</span>    <span style="color:#66d9ef">string</span> <span style="color:#75715e">// if != &#34;&#34;, keep curg running on this m
</span><span style="color:#75715e"></span>   <span style="color:#75715e">// 自旋状态，用于判断m是否工作已结束，并寻找g进行工作
</span><span style="color:#75715e"></span>   <span style="color:#a6e22e">spinning</span>      <span style="color:#66d9ef">bool</span> <span style="color:#75715e">// m is out of work and is actively looking for work
</span><span style="color:#75715e"></span>   <span style="color:#75715e">// 用于判断m是否进行休眠状态
</span><span style="color:#75715e"></span>   <span style="color:#a6e22e">blocked</span>       <span style="color:#66d9ef">bool</span> <span style="color:#75715e">// m is blocked on a note
</span><span style="color:#75715e"></span>     <span style="color:#75715e">// m休眠和唤醒通过这个，note里面有一个成员key，对这个key所指向的地址进行值的修改，进而达到唤醒和休眠的目的
</span><span style="color:#75715e"></span>   <span style="color:#a6e22e">park</span>          <span style="color:#a6e22e">note</span>
   <span style="color:#75715e">// 所有m组成的一个链表
</span><span style="color:#75715e"></span>   <span style="color:#a6e22e">alllink</span>       <span style="color:#f92672">*</span><span style="color:#a6e22e">m</span> <span style="color:#75715e">// on allm
</span><span style="color:#75715e"></span>   <span style="color:#75715e">// 下一个m，通过这个字段和sched.midle 可以串成一个m的空闲链表
</span><span style="color:#75715e"></span>   <span style="color:#a6e22e">schedlink</span>     <span style="color:#a6e22e">muintptr</span>
   <span style="color:#75715e">// mcache，m拥有p的时候，会把自己的mcache给p
</span><span style="color:#75715e"></span>   <span style="color:#a6e22e">mcache</span>        <span style="color:#f92672">*</span><span style="color:#a6e22e">mcache</span>
   <span style="color:#75715e">// lockedm的对应值
</span><span style="color:#75715e"></span>   <span style="color:#a6e22e">lockedg</span>       <span style="color:#a6e22e">guintptr</span>
   <span style="color:#75715e">// 待释放的m的list，通过sched.freem 串成一个链表
</span><span style="color:#75715e"></span>   <span style="color:#a6e22e">freelink</span>      <span style="color:#f92672">*</span><span style="color:#a6e22e">m</span>      <span style="color:#75715e">// on sched.freem
</span><span style="color:#75715e"></span>}
</code></pre></div><h4 id="p">P</h4>
<p>P是M运行G所需的资源</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">p</span> <span style="color:#66d9ef">struct</span> {
   <span style="color:#a6e22e">lock</span> <span style="color:#a6e22e">mutex</span>

   <span style="color:#a6e22e">id</span>          <span style="color:#66d9ef">int32</span>
   <span style="color:#75715e">// p的状态，稍后介绍
</span><span style="color:#75715e"></span>   <span style="color:#a6e22e">status</span>      <span style="color:#66d9ef">uint32</span> <span style="color:#75715e">// one of pidle/prunning/...
</span><span style="color:#75715e"></span>   <span style="color:#75715e">// 下一个p的地址，可参考 g.schedlink
</span><span style="color:#75715e"></span>   <span style="color:#a6e22e">link</span>        <span style="color:#a6e22e">puintptr</span>
   <span style="color:#75715e">// p所关联的m
</span><span style="color:#75715e"></span>   <span style="color:#a6e22e">m</span>           <span style="color:#a6e22e">muintptr</span>   <span style="color:#75715e">// back-link to associated m (nil if idle)
</span><span style="color:#75715e"></span>   <span style="color:#75715e">// 内存分配的时候用的，p所属的m的mcache用的也是这个
</span><span style="color:#75715e"></span>   <span style="color:#a6e22e">mcache</span>      <span style="color:#f92672">*</span><span style="color:#a6e22e">mcache</span>
  
   <span style="color:#75715e">// Cache of goroutine ids, amortizes accesses to runtime·sched.goidgen.
</span><span style="color:#75715e"></span>   <span style="color:#75715e">// 从sched中获取并缓存的id，避免每次分配goid都从sched分配
</span><span style="color:#75715e"></span>     <span style="color:#a6e22e">goidcache</span>    <span style="color:#66d9ef">uint64</span>
     <span style="color:#a6e22e">goidcacheend</span> <span style="color:#66d9ef">uint64</span>

   <span style="color:#75715e">// Queue of runnable goroutines. Accessed without lock.
</span><span style="color:#75715e"></span>   <span style="color:#75715e">// p 本地的runnbale的goroutine形成的队列
</span><span style="color:#75715e"></span>   <span style="color:#a6e22e">runqhead</span> <span style="color:#66d9ef">uint32</span>
   <span style="color:#a6e22e">runqtail</span> <span style="color:#66d9ef">uint32</span>
   <span style="color:#a6e22e">runq</span>     [<span style="color:#ae81ff">256</span>]<span style="color:#a6e22e">guintptr</span>
   <span style="color:#75715e">// runnext, if non-nil, is a runnable G that was ready&#39;d by
</span><span style="color:#75715e"></span>   <span style="color:#75715e">// the current G and should be run next instead of what&#39;s in
</span><span style="color:#75715e"></span>   <span style="color:#75715e">// runq if there&#39;s time remaining in the running G&#39;s time
</span><span style="color:#75715e"></span>   <span style="color:#75715e">// slice. It will inherit the time left in the current time
</span><span style="color:#75715e"></span>   <span style="color:#75715e">// slice. If a set of goroutines is locked in a
</span><span style="color:#75715e"></span>   <span style="color:#75715e">// communicate-and-wait pattern, this schedules that set as a
</span><span style="color:#75715e"></span>   <span style="color:#75715e">// unit and eliminates the (potentially large) scheduling
</span><span style="color:#75715e"></span>   <span style="color:#75715e">// latency that otherwise arises from adding the ready&#39;d
</span><span style="color:#75715e"></span>   <span style="color:#75715e">// goroutines to the end of the run queue.
</span><span style="color:#75715e"></span>   <span style="color:#75715e">// 下一个执行的g，如果是nil，则从队列中获取下一个执行的g
</span><span style="color:#75715e"></span>   <span style="color:#a6e22e">runnext</span> <span style="color:#a6e22e">guintptr</span>

   <span style="color:#75715e">// Available G&#39;s (status == Gdead)
</span><span style="color:#75715e"></span>   <span style="color:#75715e">// 状态为 Gdead的g的列表，可以进行复用
</span><span style="color:#75715e"></span>   <span style="color:#a6e22e">gfree</span>    <span style="color:#f92672">*</span><span style="color:#a6e22e">g</span>
   <span style="color:#a6e22e">gfreecnt</span> <span style="color:#66d9ef">int32</span>
}
</code></pre></div><p>可以看到，P上维护了mcache，并且维护了本地的runq队列。并且所有的P相互关联。</p>
<h4 id="sched">Sched</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">allp</span> [<span style="color:#a6e22e">_MaxGomaxprocs</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>]<span style="color:#f92672">*</span><span style="color:#a6e22e">p</span>

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">schedt</span> <span style="color:#66d9ef">struct</span> {
   <span style="color:#75715e">// 全局的go id分配
</span><span style="color:#75715e"></span>   <span style="color:#a6e22e">goidgen</span>  <span style="color:#66d9ef">uint64</span>
   <span style="color:#75715e">// 记录的最后一次从i/o中查询g的时间
</span><span style="color:#75715e"></span>   <span style="color:#a6e22e">lastpoll</span> <span style="color:#66d9ef">uint64</span>

   <span style="color:#a6e22e">lock</span> <span style="color:#a6e22e">mutex</span>

   <span style="color:#75715e">// When increasing nmidle, nmidlelocked, nmsys, or nmfreed, be
</span><span style="color:#75715e"></span>   <span style="color:#75715e">// sure to call checkdead().
</span><span style="color:#75715e"></span>     <span style="color:#75715e">// m的空闲链表，结合m.schedlink 就可以组成一个空闲链表了
</span><span style="color:#75715e"></span>   <span style="color:#a6e22e">midle</span>        <span style="color:#a6e22e">muintptr</span> <span style="color:#75715e">// idle m&#39;s waiting for work
</span><span style="color:#75715e"></span>   <span style="color:#a6e22e">nmidle</span>       <span style="color:#66d9ef">int32</span>    <span style="color:#75715e">// number of idle m&#39;s waiting for work
</span><span style="color:#75715e"></span>   <span style="color:#a6e22e">nmidlelocked</span> <span style="color:#66d9ef">int32</span>    <span style="color:#75715e">// number of locked m&#39;s waiting for work
</span><span style="color:#75715e"></span>   <span style="color:#75715e">// 下一个m的id，也用来记录创建的m数量
</span><span style="color:#75715e"></span>   <span style="color:#a6e22e">mnext</span>        <span style="color:#66d9ef">int64</span>    <span style="color:#75715e">// number of m&#39;s that have been created and next M ID
</span><span style="color:#75715e"></span>   <span style="color:#75715e">// 最多允许的m的数量
</span><span style="color:#75715e"></span>   <span style="color:#a6e22e">maxmcount</span>    <span style="color:#66d9ef">int32</span>    <span style="color:#75715e">// maximum number of m&#39;s allowed (or die)
</span><span style="color:#75715e"></span>   <span style="color:#a6e22e">nmsys</span>        <span style="color:#66d9ef">int32</span>    <span style="color:#75715e">// number of system m&#39;s not counted for deadlock
</span><span style="color:#75715e"></span>   <span style="color:#75715e">// free掉的m的数量，exit的m的数量
</span><span style="color:#75715e"></span>   <span style="color:#a6e22e">nmfreed</span>      <span style="color:#66d9ef">int64</span>    <span style="color:#75715e">// cumulative number of freed m&#39;s
</span><span style="color:#75715e"></span>
   <span style="color:#a6e22e">ngsys</span> <span style="color:#66d9ef">uint32</span> <span style="color:#75715e">// number of system goroutines; updated atomically
</span><span style="color:#75715e"></span>
   <span style="color:#a6e22e">pidle</span>      <span style="color:#a6e22e">puintptr</span> <span style="color:#75715e">// idle p&#39;s
</span><span style="color:#75715e"></span>   <span style="color:#a6e22e">npidle</span>     <span style="color:#66d9ef">uint32</span>
   <span style="color:#a6e22e">nmspinning</span> <span style="color:#66d9ef">uint32</span> <span style="color:#75715e">// See &#34;Worker thread parking/unparking&#34; comment in proc.go.
</span><span style="color:#75715e"></span>
   <span style="color:#75715e">// Global runnable queue.
</span><span style="color:#75715e"></span>   <span style="color:#75715e">// 这个就是全局的g的队列了，如果p的本地队列没有g或者太多，会跟全局队列进行平衡
</span><span style="color:#75715e"></span>   <span style="color:#75715e">// 根据runqhead可以获取队列头的g，然后根据g.schedlink 获取下一个，从而形成了一个链表
</span><span style="color:#75715e"></span>   <span style="color:#a6e22e">runqhead</span> <span style="color:#a6e22e">guintptr</span>
   <span style="color:#a6e22e">runqtail</span> <span style="color:#a6e22e">guintptr</span>
   <span style="color:#a6e22e">runqsize</span> <span style="color:#66d9ef">int32</span>

   <span style="color:#75715e">// freem is the list of m&#39;s waiting to be freed when their
</span><span style="color:#75715e"></span>   <span style="color:#75715e">// m.exited is set. Linked through m.freelink.
</span><span style="color:#75715e"></span>   <span style="color:#75715e">// 等待释放的m的列表
</span><span style="color:#75715e"></span>   <span style="color:#a6e22e">freem</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">m</span>
}
</code></pre></div><p>全局结构上新增了全局的p列表，并且和sched结构拆分了，减少锁竞争</p>
<h3 id="44-gmp-整体一张图">4.4 GMP 整体一张图</h3>
<p><img src="https://cdn.jsdelivr.net/gh/nber1994/fu0k@master/uPic/ngqDBf20211124153819.jpg" alt="image-20211124153852657" style="zoom: 25%;" /></p>
<h3 id="45-程序初始化">4.5 程序初始化</h3>
<p>go的启动流程分为4步</p>
<ol>
<li>call osinit， 这里就是设置了全局变量ncpu = cpu核心数量</li>
<li>call schedinit</li>
<li>make &amp; queue new G （runtime.newproc, go func()也是调用这个函数来创建goroutine）</li>
<li>call runtime·mstart</li>
</ol>
<p>和GM模型启动流程没有改变</p>
<p><img src="https://cdn.jsdelivr.net/gh/nber1994/fu0k@master/uPic/image-2021112415420457120211124154204.png" alt="image-20211124154204571" style="zoom:50%;" /></p>
<h3 id="46-调度器初始化">4.6 调度器初始化</h3>
<p><img src="https://cdn.jsdelivr.net/gh/nber1994/fu0k@master/uPic/image-2021112415423084420211124154231.png" alt="image-20211124154230844" style="zoom:50%;" /></p>
<p>schedinit这里对当前m进行了初始化，并根据osinit获取到的cpu核数和设置的<code>GOMAXPROCS</code> 确定p的数量，并进行初始化</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">schedinit</span>() {
    <span style="color:#75715e">// 从TLS或者专用寄存器获取当前g的指针类型
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">_g_</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">getg</span>()
    <span style="color:#75715e">// 设置m最大的数量
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">sched</span>.<span style="color:#a6e22e">maxmcount</span> = <span style="color:#ae81ff">10000</span>

    <span style="color:#75715e">// 初始化栈的复用空间
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">stackinit</span>()
    <span style="color:#75715e">// 初始化当前m
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">mcommoninit</span>(<span style="color:#a6e22e">_g_</span>.<span style="color:#a6e22e">m</span>)

    <span style="color:#75715e">// osinit的时候会设置 ncpu这个全局变量，这里就是根据cpu核心数和参数GOMAXPROCS来确定p的数量
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">procs</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">ncpu</span>
    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">n</span>, <span style="color:#a6e22e">ok</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">atoi32</span>(<span style="color:#a6e22e">gogetenv</span>(<span style="color:#e6db74">&#34;GOMAXPROCS&#34;</span>)); <span style="color:#a6e22e">ok</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">n</span> &gt; <span style="color:#ae81ff">0</span> {
        <span style="color:#a6e22e">procs</span> = <span style="color:#a6e22e">n</span>
    }
    <span style="color:#75715e">// 生成设定数量的p
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">procresize</span>(<span style="color:#a6e22e">procs</span>) <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
        <span style="color:#a6e22e">throw</span>(<span style="color:#e6db74">&#34;unknown runnable goroutine during bootstrap&#34;</span>)
    }
}
</code></pre></div><p>procresize函数更改p的数量，多退少补的原则，在初始化过程中，由于最开始是没有p的，所以这里的作用就是初始化设定数量的p了</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">procresize</span>(<span style="color:#a6e22e">nprocs</span> <span style="color:#66d9ef">int32</span>) <span style="color:#f92672">*</span><span style="color:#a6e22e">p</span> {
    <span style="color:#a6e22e">old</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">gomaxprocs</span>
    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">old</span> &lt; <span style="color:#ae81ff">0</span> <span style="color:#f92672">||</span> <span style="color:#a6e22e">nprocs</span> <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">0</span> {
        <span style="color:#a6e22e">throw</span>(<span style="color:#e6db74">&#34;procresize: invalid arg&#34;</span>)
    }
    <span style="color:#75715e">// update statistics
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">now</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">nanotime</span>()
    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">sched</span>.<span style="color:#a6e22e">procresizetime</span> <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span> {
        <span style="color:#a6e22e">sched</span>.<span style="color:#a6e22e">totaltime</span> <span style="color:#f92672">+=</span> int64(<span style="color:#a6e22e">old</span>) <span style="color:#f92672">*</span> (<span style="color:#a6e22e">now</span> <span style="color:#f92672">-</span> <span style="color:#a6e22e">sched</span>.<span style="color:#a6e22e">procresizetime</span>)
    }
    <span style="color:#a6e22e">sched</span>.<span style="color:#a6e22e">procresizetime</span> = <span style="color:#a6e22e">now</span>

    <span style="color:#75715e">// Grow allp if necessary.
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 如果新给的p的数量比原先的p的数量多，则新建增长的p
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">nprocs</span> &gt; int32(len(<span style="color:#a6e22e">allp</span>)) {
        <span style="color:#75715e">// Synchronize with retake, which could be running
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// concurrently since it doesn&#39;t run on a P.
</span><span style="color:#75715e"></span>        <span style="color:#a6e22e">lock</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">allpLock</span>)
        <span style="color:#75715e">// 判断allp 的cap是否满足增长后的长度，满足就直接使用，不满足，则需要扩张这个slice
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">nprocs</span> <span style="color:#f92672">&lt;=</span> int32(cap(<span style="color:#a6e22e">allp</span>)) {
            <span style="color:#a6e22e">allp</span> = <span style="color:#a6e22e">allp</span>[:<span style="color:#a6e22e">nprocs</span>]
        } <span style="color:#66d9ef">else</span> {
            <span style="color:#a6e22e">nallp</span> <span style="color:#f92672">:=</span> make([]<span style="color:#f92672">*</span><span style="color:#a6e22e">p</span>, <span style="color:#a6e22e">nprocs</span>)
            <span style="color:#75715e">// Copy everything up to allp&#39;s cap so we
</span><span style="color:#75715e"></span>            <span style="color:#75715e">// never lose old allocated Ps.
</span><span style="color:#75715e"></span>            copy(<span style="color:#a6e22e">nallp</span>, <span style="color:#a6e22e">allp</span>[:cap(<span style="color:#a6e22e">allp</span>)])
            <span style="color:#a6e22e">allp</span> = <span style="color:#a6e22e">nallp</span>
        }
        <span style="color:#a6e22e">unlock</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">allpLock</span>)
    }

    <span style="color:#75715e">// initialize new P&#39;s
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 初始化新增的p
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> int32(<span style="color:#ae81ff">0</span>); <span style="color:#a6e22e">i</span> &lt; <span style="color:#a6e22e">nprocs</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
        <span style="color:#a6e22e">pp</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">allp</span>[<span style="color:#a6e22e">i</span>]
        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">pp</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
            <span style="color:#a6e22e">pp</span> = new(<span style="color:#a6e22e">p</span>)
            <span style="color:#a6e22e">pp</span>.<span style="color:#a6e22e">id</span> = <span style="color:#a6e22e">i</span>
            <span style="color:#a6e22e">pp</span>.<span style="color:#a6e22e">status</span> = <span style="color:#a6e22e">_Pgcstop</span>
            <span style="color:#a6e22e">pp</span>.<span style="color:#a6e22e">sudogcache</span> = <span style="color:#a6e22e">pp</span>.<span style="color:#a6e22e">sudogbuf</span>[:<span style="color:#ae81ff">0</span>]
            <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">pp</span>.<span style="color:#a6e22e">deferpool</span> {
                <span style="color:#a6e22e">pp</span>.<span style="color:#a6e22e">deferpool</span>[<span style="color:#a6e22e">i</span>] = <span style="color:#a6e22e">pp</span>.<span style="color:#a6e22e">deferpoolbuf</span>[<span style="color:#a6e22e">i</span>][:<span style="color:#ae81ff">0</span>]
            }
            <span style="color:#a6e22e">pp</span>.<span style="color:#a6e22e">wbBuf</span>.<span style="color:#a6e22e">reset</span>()
            <span style="color:#75715e">// allp是一个slice，直接将新增的p放到对应的索引下面就ok了
</span><span style="color:#75715e"></span>            <span style="color:#a6e22e">atomicstorep</span>(<span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">allp</span>[<span style="color:#a6e22e">i</span>]), <span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>(<span style="color:#a6e22e">pp</span>))
        }
        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">pp</span>.<span style="color:#a6e22e">mcache</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
            <span style="color:#75715e">// 初始化时，old=0，第一个新建的p给当前的m使用
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">old</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> {
                <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">getg</span>().<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">mcache</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
                    <span style="color:#a6e22e">throw</span>(<span style="color:#e6db74">&#34;missing mcache?&#34;</span>)
                }
                <span style="color:#a6e22e">pp</span>.<span style="color:#a6e22e">mcache</span> = <span style="color:#a6e22e">getg</span>().<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">mcache</span> <span style="color:#75715e">// bootstrap
</span><span style="color:#75715e"></span>            } <span style="color:#66d9ef">else</span> {
                <span style="color:#75715e">// 为p分配内存
</span><span style="color:#75715e"></span>                <span style="color:#a6e22e">pp</span>.<span style="color:#a6e22e">mcache</span> = <span style="color:#a6e22e">allocmcache</span>()  <span style="color:#75715e">//*******为P分配mcache********
</span><span style="color:#75715e"></span>            }
        }
    }

    <span style="color:#75715e">// free unused P&#39;s
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 释放掉多余的p，当新设置的p的数量，比原先设定的p的数量少的时候，会走到这个流程
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 通过 runtime.GOMAXPROCS 就可以动态的修改nprocs
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">nprocs</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#a6e22e">old</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
        <span style="color:#a6e22e">p</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">allp</span>[<span style="color:#a6e22e">i</span>]
        <span style="color:#75715e">// move all runnable goroutines to the global queue
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// 把当前p的运行队列里的g转移到全局的g的队列
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">runqhead</span> <span style="color:#f92672">!=</span> <span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">runqtail</span> {
            <span style="color:#75715e">// pop from tail of local queue
</span><span style="color:#75715e"></span>            <span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">runqtail</span><span style="color:#f92672">--</span>
            <span style="color:#a6e22e">gp</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">runq</span>[<span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">runqtail</span><span style="color:#f92672">%</span>uint32(len(<span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">runq</span>))].<span style="color:#a6e22e">ptr</span>()
            <span style="color:#75715e">// push onto head of global queue
</span><span style="color:#75715e"></span>            <span style="color:#a6e22e">globrunqputhead</span>(<span style="color:#a6e22e">gp</span>)
        }
        <span style="color:#75715e">// 把runnext里的g也转移到全局队列
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">runnext</span> <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span> {
            <span style="color:#a6e22e">globrunqputhead</span>(<span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">runnext</span>.<span style="color:#a6e22e">ptr</span>())
            <span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">runnext</span> = <span style="color:#ae81ff">0</span>
        }
        <span style="color:#75715e">// if there&#39;s a background worker, make it runnable and put
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// it on the global queue so it can clean itself up
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// 如果有gc worker的话，修改g的状态，然后再把它放到全局队列中
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">gp</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">gcBgMarkWorker</span>.<span style="color:#a6e22e">ptr</span>(); <span style="color:#a6e22e">gp</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
            <span style="color:#a6e22e">casgstatus</span>(<span style="color:#a6e22e">gp</span>, <span style="color:#a6e22e">_Gwaiting</span>, <span style="color:#a6e22e">_Grunnable</span>)
            <span style="color:#a6e22e">globrunqput</span>(<span style="color:#a6e22e">gp</span>)
            <span style="color:#75715e">// This assignment doesn&#39;t race because the
</span><span style="color:#75715e"></span>            <span style="color:#75715e">// world is stopped.
</span><span style="color:#75715e"></span>            <span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">gcBgMarkWorker</span>.<span style="color:#a6e22e">set</span>(<span style="color:#66d9ef">nil</span>)
        }
        <span style="color:#75715e">// sudoig的buf和cache，以及deferpool全部清空
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">sudogbuf</span> {
            <span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">sudogbuf</span>[<span style="color:#a6e22e">i</span>] = <span style="color:#66d9ef">nil</span>
        }
        <span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">sudogcache</span> = <span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">sudogbuf</span>[:<span style="color:#ae81ff">0</span>]
        <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">deferpool</span> {
            <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">j</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">deferpoolbuf</span>[<span style="color:#a6e22e">i</span>] {
                <span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">deferpoolbuf</span>[<span style="color:#a6e22e">i</span>][<span style="color:#a6e22e">j</span>] = <span style="color:#66d9ef">nil</span>
            }
            <span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">deferpool</span>[<span style="color:#a6e22e">i</span>] = <span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">deferpoolbuf</span>[<span style="color:#a6e22e">i</span>][:<span style="color:#ae81ff">0</span>]
        }
        <span style="color:#75715e">// 释放掉当前p的mcache
</span><span style="color:#75715e"></span>        <span style="color:#a6e22e">freemcache</span>(<span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">mcache</span>)
        <span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">mcache</span> = <span style="color:#66d9ef">nil</span>
        <span style="color:#75715e">// 把当前p的gfree转移到全局
</span><span style="color:#75715e"></span>        <span style="color:#a6e22e">gfpurge</span>(<span style="color:#a6e22e">p</span>)
        <span style="color:#75715e">// 修改p的状态，让他自生自灭去了
</span><span style="color:#75715e"></span>        <span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">status</span> = <span style="color:#a6e22e">_Pdead</span>
        <span style="color:#75715e">// can&#39;t free P itself because it can be referenced by an M in syscall
</span><span style="color:#75715e"></span>    }

    <span style="color:#75715e">// Trim allp.
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> int32(len(<span style="color:#a6e22e">allp</span>)) <span style="color:#f92672">!=</span> <span style="color:#a6e22e">nprocs</span> {
        <span style="color:#a6e22e">lock</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">allpLock</span>)
        <span style="color:#a6e22e">allp</span> = <span style="color:#a6e22e">allp</span>[:<span style="color:#a6e22e">nprocs</span>]
        <span style="color:#a6e22e">unlock</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">allpLock</span>)
    }
    <span style="color:#75715e">// 判断当前g是否有p，有的话更改当前使用的p的状态，继续使用
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">_g_</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">getg</span>()
    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">_g_</span>.<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">p</span> <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">_g_</span>.<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">ptr</span>().<span style="color:#a6e22e">id</span> &lt; <span style="color:#a6e22e">nprocs</span> {
        <span style="color:#75715e">// continue to use the current P
</span><span style="color:#75715e"></span>        <span style="color:#a6e22e">_g_</span>.<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">ptr</span>().<span style="color:#a6e22e">status</span> = <span style="color:#a6e22e">_Prunning</span>
    } <span style="color:#66d9ef">else</span> {
        <span style="color:#75715e">// release the current P and acquire allp[0]
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// 如果当前g有p，但是拥有的是已经释放的p，则不再使用这个p，重新分配
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">_g_</span>.<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">p</span> <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span> {
            <span style="color:#a6e22e">_g_</span>.<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">ptr</span>().<span style="color:#a6e22e">m</span> = <span style="color:#ae81ff">0</span>
        }
        <span style="color:#75715e">// 分配allp[0]给当前g使用
</span><span style="color:#75715e"></span>        <span style="color:#a6e22e">_g_</span>.<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">p</span> = <span style="color:#ae81ff">0</span>
        <span style="color:#a6e22e">_g_</span>.<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">mcache</span> = <span style="color:#66d9ef">nil</span>
        <span style="color:#a6e22e">p</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">allp</span>[<span style="color:#ae81ff">0</span>]
        <span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">m</span> = <span style="color:#ae81ff">0</span>
        <span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">status</span> = <span style="color:#a6e22e">_Pidle</span>
        <span style="color:#75715e">// 将p m g绑定，并把m.mcache指向p.mcache，并修改p的状态为_Prunning
</span><span style="color:#75715e"></span>        <span style="color:#a6e22e">acquirep</span>(<span style="color:#a6e22e">p</span>)
    }
    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">runnablePs</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">p</span>
    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">nprocs</span> <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>; <span style="color:#a6e22e">i</span> <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">--</span> {
        <span style="color:#a6e22e">p</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">allp</span>[<span style="color:#a6e22e">i</span>]
        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">_g_</span>.<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">ptr</span>() <span style="color:#f92672">==</span> <span style="color:#a6e22e">p</span> {
            <span style="color:#66d9ef">continue</span>
        }
        <span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">status</span> = <span style="color:#a6e22e">_Pidle</span>
        <span style="color:#75715e">// 根据 runqempty 来判断当前p的g运行队列是否为空
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">runqempty</span>(<span style="color:#a6e22e">p</span>) {
            <span style="color:#75715e">// g运行队列为空的p，放到 sched的pidle队列里面
</span><span style="color:#75715e"></span>            <span style="color:#a6e22e">pidleput</span>(<span style="color:#a6e22e">p</span>)
        } <span style="color:#66d9ef">else</span> {
            <span style="color:#75715e">// g 运行队列不为空的p，组成一个可运行队列，并最后返回
</span><span style="color:#75715e"></span>            <span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">set</span>(<span style="color:#a6e22e">mget</span>())
            <span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">link</span>.<span style="color:#a6e22e">set</span>(<span style="color:#a6e22e">runnablePs</span>)
            <span style="color:#a6e22e">runnablePs</span> = <span style="color:#a6e22e">p</span>
        }
    }
    <span style="color:#a6e22e">stealOrder</span>.<span style="color:#a6e22e">reset</span>(uint32(<span style="color:#a6e22e">nprocs</span>))
    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">int32p</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">int32</span> = <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">gomaxprocs</span> <span style="color:#75715e">// make compiler check that gomaxprocs is an int32
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">atomic</span>.<span style="color:#a6e22e">Store</span>((<span style="color:#f92672">*</span><span style="color:#66d9ef">uint32</span>)(<span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>(<span style="color:#a6e22e">int32p</span>)), uint32(<span style="color:#a6e22e">nprocs</span>))
    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">runnablePs</span>
}
</code></pre></div><p>上面这一步可以看到，为P分配了mcache</p>
<h3 id="47-协程创建">4.7 协程创建</h3>
<p><img src="https://cdn.jsdelivr.net/gh/nber1994/fu0k@master/uPic/image-2021112415505940820211124155059.png" alt="image-20211124155059408" style="zoom:50%;" /></p>
<p>仍然是调用newproc1函数，和GM模型的区别是，先获取空闲的g复用，之后优先加入p本地运行g队列中，否则放入全局队列中。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">newproc1</span>(<span style="color:#a6e22e">fn</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">funcval</span>, <span style="color:#a6e22e">argp</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">uint8</span>, <span style="color:#a6e22e">narg</span> <span style="color:#66d9ef">int32</span>, <span style="color:#a6e22e">callergp</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">g</span>, <span style="color:#a6e22e">callerpc</span> <span style="color:#66d9ef">uintptr</span>) {
    <span style="color:#a6e22e">_g_</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">getg</span>()

    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">fn</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
        <span style="color:#a6e22e">_g_</span>.<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">throwing</span> = <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> <span style="color:#75715e">// do not dump full stacks
</span><span style="color:#75715e"></span>        <span style="color:#a6e22e">throw</span>(<span style="color:#e6db74">&#34;go of nil func value&#34;</span>)
    }
    <span style="color:#75715e">// 加锁禁止被抢占
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">_g_</span>.<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">locks</span><span style="color:#f92672">++</span> <span style="color:#75715e">// disable preemption because it can be holding p in a local var
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">siz</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">narg</span>
    <span style="color:#a6e22e">siz</span> = (<span style="color:#a6e22e">siz</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">7</span>) <span style="color:#f92672">&amp;^</span> <span style="color:#ae81ff">7</span>

    <span style="color:#75715e">// We could allocate a larger initial stack if necessary.
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// Not worth it: this is almost always an error.
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 4*sizeof(uintreg): extra space added below
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// sizeof(uintreg): caller&#39;s LR (arm) or return address (x86, in gostartcall).
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 如果参数过多，则直接抛出异常，栈大小是2k
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">siz</span> <span style="color:#f92672">&gt;=</span> <span style="color:#a6e22e">_StackMin</span><span style="color:#f92672">-</span><span style="color:#ae81ff">4</span><span style="color:#f92672">*</span><span style="color:#a6e22e">sys</span>.<span style="color:#a6e22e">RegSize</span><span style="color:#f92672">-</span><span style="color:#a6e22e">sys</span>.<span style="color:#a6e22e">RegSize</span> {
        <span style="color:#a6e22e">throw</span>(<span style="color:#e6db74">&#34;newproc: function arguments too large for new goroutine&#34;</span>)
    }

    <span style="color:#a6e22e">_p_</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">_g_</span>.<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">ptr</span>()
    <span style="color:#75715e">// 尝试获取一个空闲的g，如果获取不到，则新建一个，并添加到allg里面
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// gfget首先会尝试从p本地获取空闲的g，如果本地没有的话，则从全局获取一堆平衡到本地p
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">newg</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">gfget</span>(<span style="color:#a6e22e">_p_</span>)
    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">newg</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
        <span style="color:#a6e22e">newg</span> = <span style="color:#a6e22e">malg</span>(<span style="color:#a6e22e">_StackMin</span>)
        <span style="color:#a6e22e">casgstatus</span>(<span style="color:#a6e22e">newg</span>, <span style="color:#a6e22e">_Gidle</span>, <span style="color:#a6e22e">_Gdead</span>)
        <span style="color:#75715e">// 新建的g，添加到全局的 allg里面，allg是一个slice， append进去即可
</span><span style="color:#75715e"></span>        <span style="color:#a6e22e">allgadd</span>(<span style="color:#a6e22e">newg</span>) <span style="color:#75715e">// publishes with a g-&gt;status of Gdead so GC scanner doesn&#39;t look at uninitialized stack.
</span><span style="color:#75715e"></span>    }
    <span style="color:#75715e">// 判断获取的g的栈是否正常
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">newg</span>.<span style="color:#a6e22e">stack</span>.<span style="color:#a6e22e">hi</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> {
        <span style="color:#a6e22e">throw</span>(<span style="color:#e6db74">&#34;newproc1: newg missing stack&#34;</span>)
    }
    <span style="color:#75715e">// 判断g的状态是否正常
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">readgstatus</span>(<span style="color:#a6e22e">newg</span>) <span style="color:#f92672">!=</span> <span style="color:#a6e22e">_Gdead</span> {
        <span style="color:#a6e22e">throw</span>(<span style="color:#e6db74">&#34;newproc1: new g is not Gdead&#34;</span>)
    }
    <span style="color:#75715e">// 预留一点空间，防止读取超出一点点
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">totalSize</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">4</span><span style="color:#f92672">*</span><span style="color:#a6e22e">sys</span>.<span style="color:#a6e22e">RegSize</span> <span style="color:#f92672">+</span> uintptr(<span style="color:#a6e22e">siz</span>) <span style="color:#f92672">+</span> <span style="color:#a6e22e">sys</span>.<span style="color:#a6e22e">MinFrameSize</span> <span style="color:#75715e">// extra space in case of reads slightly beyond frame
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 空间大小进行对齐
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">totalSize</span> <span style="color:#f92672">+=</span> <span style="color:#f92672">-</span><span style="color:#a6e22e">totalSize</span> <span style="color:#f92672">&amp;</span> (<span style="color:#a6e22e">sys</span>.<span style="color:#a6e22e">SpAlign</span> <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) <span style="color:#75715e">// align to spAlign
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">sp</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">newg</span>.<span style="color:#a6e22e">stack</span>.<span style="color:#a6e22e">hi</span> <span style="color:#f92672">-</span> <span style="color:#a6e22e">totalSize</span>
    <span style="color:#a6e22e">spArg</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">sp</span>
    <span style="color:#75715e">// usesLr 为0，这里不执行
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">usesLR</span> {
        <span style="color:#75715e">// caller&#39;s LR
</span><span style="color:#75715e"></span>        <span style="color:#f92672">*</span>(<span style="color:#f92672">*</span><span style="color:#66d9ef">uintptr</span>)(<span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>(<span style="color:#a6e22e">sp</span>)) = <span style="color:#ae81ff">0</span>
        <span style="color:#a6e22e">prepGoExitFrame</span>(<span style="color:#a6e22e">sp</span>)
        <span style="color:#a6e22e">spArg</span> <span style="color:#f92672">+=</span> <span style="color:#a6e22e">sys</span>.<span style="color:#a6e22e">MinFrameSize</span>
    }
    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">narg</span> &gt; <span style="color:#ae81ff">0</span> {
        <span style="color:#75715e">// 将参数拷贝入栈
</span><span style="color:#75715e"></span>        <span style="color:#a6e22e">memmove</span>(<span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>(<span style="color:#a6e22e">spArg</span>), <span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>(<span style="color:#a6e22e">argp</span>), uintptr(<span style="color:#a6e22e">narg</span>))
        <span style="color:#75715e">// ... 省略 ...
</span><span style="color:#75715e"></span>    }
    <span style="color:#75715e">// 初始化用于保存现场的区域及初始化基本状态
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">memclrNoHeapPointers</span>(<span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">newg</span>.<span style="color:#a6e22e">sched</span>), <span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Sizeof</span>(<span style="color:#a6e22e">newg</span>.<span style="color:#a6e22e">sched</span>))
    <span style="color:#a6e22e">newg</span>.<span style="color:#a6e22e">sched</span>.<span style="color:#a6e22e">sp</span> = <span style="color:#a6e22e">sp</span>
    <span style="color:#a6e22e">newg</span>.<span style="color:#a6e22e">stktopsp</span> = <span style="color:#a6e22e">sp</span>
    <span style="color:#75715e">// 这里保存了goexit的地址，在用户函数执行完成后，会根据pc来执行goexit
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">newg</span>.<span style="color:#a6e22e">sched</span>.<span style="color:#a6e22e">pc</span> = <span style="color:#a6e22e">funcPC</span>(<span style="color:#a6e22e">goexit</span>) <span style="color:#f92672">+</span> <span style="color:#a6e22e">sys</span>.<span style="color:#a6e22e">PCQuantum</span> <span style="color:#75715e">// +PCQuantum so that previous instruction is in same function
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">newg</span>.<span style="color:#a6e22e">sched</span>.<span style="color:#a6e22e">g</span> = <span style="color:#a6e22e">guintptr</span>(<span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>(<span style="color:#a6e22e">newg</span>))
    <span style="color:#75715e">// 这里调整 sched 信息，pc = goexit的地址
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">gostartcallfn</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">newg</span>.<span style="color:#a6e22e">sched</span>, <span style="color:#a6e22e">fn</span>)
    <span style="color:#a6e22e">newg</span>.<span style="color:#a6e22e">gopc</span> = <span style="color:#a6e22e">callerpc</span>
    <span style="color:#a6e22e">newg</span>.<span style="color:#a6e22e">ancestors</span> = <span style="color:#a6e22e">saveAncestors</span>(<span style="color:#a6e22e">callergp</span>)
    <span style="color:#a6e22e">newg</span>.<span style="color:#a6e22e">startpc</span> = <span style="color:#a6e22e">fn</span>.<span style="color:#a6e22e">fn</span>
    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">_g_</span>.<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">curg</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
        <span style="color:#a6e22e">newg</span>.<span style="color:#a6e22e">labels</span> = <span style="color:#a6e22e">_g_</span>.<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">curg</span>.<span style="color:#a6e22e">labels</span>
    }
    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">isSystemGoroutine</span>(<span style="color:#a6e22e">newg</span>) {
        <span style="color:#a6e22e">atomic</span>.<span style="color:#a6e22e">Xadd</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">sched</span>.<span style="color:#a6e22e">ngsys</span>, <span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>)
    }
    <span style="color:#a6e22e">newg</span>.<span style="color:#a6e22e">gcscanvalid</span> = <span style="color:#66d9ef">false</span>
    <span style="color:#a6e22e">casgstatus</span>(<span style="color:#a6e22e">newg</span>, <span style="color:#a6e22e">_Gdead</span>, <span style="color:#a6e22e">_Grunnable</span>)
    <span style="color:#75715e">// 如果p缓存的goid已经用完，本地再从sched批量获取一点
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">_p_</span>.<span style="color:#a6e22e">goidcache</span> <span style="color:#f92672">==</span> <span style="color:#a6e22e">_p_</span>.<span style="color:#a6e22e">goidcacheend</span> {
        <span style="color:#75715e">// Sched.goidgen is the last allocated id,
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// this batch must be [sched.goidgen+1, sched.goidgen+GoidCacheBatch].
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// At startup sched.goidgen=0, so main goroutine receives goid=1.
</span><span style="color:#75715e"></span>        <span style="color:#a6e22e">_p_</span>.<span style="color:#a6e22e">goidcache</span> = <span style="color:#a6e22e">atomic</span>.<span style="color:#a6e22e">Xadd64</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">sched</span>.<span style="color:#a6e22e">goidgen</span>, <span style="color:#a6e22e">_GoidCacheBatch</span>)
        <span style="color:#a6e22e">_p_</span>.<span style="color:#a6e22e">goidcache</span> <span style="color:#f92672">-=</span> <span style="color:#a6e22e">_GoidCacheBatch</span> <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>
        <span style="color:#a6e22e">_p_</span>.<span style="color:#a6e22e">goidcacheend</span> = <span style="color:#a6e22e">_p_</span>.<span style="color:#a6e22e">goidcache</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">_GoidCacheBatch</span>
    }
    <span style="color:#75715e">// 分配goid
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">newg</span>.<span style="color:#a6e22e">goid</span> = int64(<span style="color:#a6e22e">_p_</span>.<span style="color:#a6e22e">goidcache</span>)
    <span style="color:#a6e22e">_p_</span>.<span style="color:#a6e22e">goidcache</span><span style="color:#f92672">++</span>
    <span style="color:#75715e">// 把新的g放到 p 的可运行g队列中
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">runqput</span>(<span style="color:#a6e22e">_p_</span>, <span style="color:#a6e22e">newg</span>, <span style="color:#66d9ef">true</span>)
    <span style="color:#75715e">// 判断是否有空闲p，且是否需要唤醒一个m来执行g
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">atomic</span>.<span style="color:#a6e22e">Load</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">sched</span>.<span style="color:#a6e22e">npidle</span>) <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">atomic</span>.<span style="color:#a6e22e">Load</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">sched</span>.<span style="color:#a6e22e">nmspinning</span>) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">mainStarted</span> {
        <span style="color:#a6e22e">wakep</span>()
    }
    <span style="color:#a6e22e">_g_</span>.<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">locks</span><span style="color:#f92672">--</span>
    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">_g_</span>.<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">locks</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">_g_</span>.<span style="color:#a6e22e">preempt</span> { <span style="color:#75715e">// restore the preemption request in case we&#39;ve cleared it in newstack
</span><span style="color:#75715e"></span>        <span style="color:#a6e22e">_g_</span>.<span style="color:#a6e22e">stackguard0</span> = <span style="color:#a6e22e">stackPreempt</span>
    }
}
</code></pre></div><p>同样的，仍然给g的callerpc写入goexit()函数的PC</p>
<p><strong>获取空闲g</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/nber1994/fu0k@master/uPic/image-2021112415542677020211124155427.png" alt="image-20211124155426770" style="zoom:33%;" /></p>
<p>先从p本地获取空闲g，没有则从全局获取空闲g</p>
<p><strong>将g放入运行队列</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/nber1994/fu0k@master/uPic/image-2021112415562545320211124155625.png" alt="image-20211124155625453" style="zoom:50%;" /></p>
<p>先尝试放入本地g队列，如果满了后，就尝试放入全局g队列</p>
<h3 id="48-启动m">4.8 启动M</h3>
<p><img src="https://cdn.jsdelivr.net/gh/nber1994/fu0k@master/uPic/image-2021112416002379220211124160024.png" alt="image-20211124160023792" style="zoom:50%;" /></p>
<p>整体逻辑从之前的从g全局列表获取g变为了如果入参p!=nil，则为m找一个M（没有则创建），如果p==nil则尝试找到空闲P和M最匹配，并且最后唤醒m</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">startm</span>(<span style="color:#a6e22e">_p_</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">p</span>, <span style="color:#a6e22e">spinning</span> <span style="color:#66d9ef">bool</span>) {
    <span style="color:#a6e22e">lock</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">sched</span>.<span style="color:#a6e22e">lock</span>)
    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">_p_</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
        <span style="color:#75715e">// *********************如果没有指定p, 则从sched.pidle获取空闲的p*************************
</span><span style="color:#75715e"></span>        <span style="color:#a6e22e">_p_</span> = <span style="color:#a6e22e">pidleget</span>()
        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">_p_</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
            <span style="color:#a6e22e">unlock</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">sched</span>.<span style="color:#a6e22e">lock</span>)
            <span style="color:#75715e">// 如果没有获取到p，重置nmspinning
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">spinning</span> {
                <span style="color:#75715e">// The caller incremented nmspinning, but there are no idle Ps,
</span><span style="color:#75715e"></span>                <span style="color:#75715e">// so it&#39;s okay to just undo the increment and give up.
</span><span style="color:#75715e"></span>                <span style="color:#66d9ef">if</span> int32(<span style="color:#a6e22e">atomic</span>.<span style="color:#a6e22e">Xadd</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">sched</span>.<span style="color:#a6e22e">nmspinning</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)) &lt; <span style="color:#ae81ff">0</span> {
                    <span style="color:#a6e22e">throw</span>(<span style="color:#e6db74">&#34;startm: negative nmspinning&#34;</span>)
                }
            }
            <span style="color:#66d9ef">return</span>
        }
    }
    <span style="color:#75715e">// 首先尝试从 sched.midle获取一个空闲的m
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">mp</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">mget</span>()
    <span style="color:#a6e22e">unlock</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">sched</span>.<span style="color:#a6e22e">lock</span>)
    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">mp</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
        <span style="color:#75715e">// 如果获取不到空闲的m，则创建一个 mspining = true的m，并将p绑定到m上，直接返回
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">fn</span> <span style="color:#66d9ef">func</span>()
        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">spinning</span> {
            <span style="color:#75715e">// The caller incremented nmspinning, so set m.spinning in the new M.
</span><span style="color:#75715e"></span>            <span style="color:#a6e22e">fn</span> = <span style="color:#a6e22e">mspinning</span>
        }
        <span style="color:#a6e22e">newm</span>(<span style="color:#a6e22e">fn</span>, <span style="color:#a6e22e">_p_</span>)
        <span style="color:#66d9ef">return</span>
    }
    <span style="color:#75715e">// 判断获取到的空闲m是否是spining状态
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">mp</span>.<span style="color:#a6e22e">spinning</span> {
        <span style="color:#a6e22e">throw</span>(<span style="color:#e6db74">&#34;startm: m is spinning&#34;</span>)
    }
    <span style="color:#75715e">// 判断获取到的m是否有p
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">mp</span>.<span style="color:#a6e22e">nextp</span> <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span> {
        <span style="color:#a6e22e">throw</span>(<span style="color:#e6db74">&#34;startm: m has p&#34;</span>)
    }
    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">spinning</span> <span style="color:#f92672">&amp;&amp;</span> !<span style="color:#a6e22e">runqempty</span>(<span style="color:#a6e22e">_p_</span>) {
        <span style="color:#a6e22e">throw</span>(<span style="color:#e6db74">&#34;startm: p has runnable gs&#34;</span>)
    }
    <span style="color:#75715e">// The caller incremented nmspinning, so set m.spinning in the new M.
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 调用函数的父函数已经增加了nmspinning， 这里只需要设置m.spining就ok了，同时把p绑上来
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">mp</span>.<span style="color:#a6e22e">spinning</span> = <span style="color:#a6e22e">spinning</span>
    <span style="color:#a6e22e">mp</span>.<span style="color:#a6e22e">nextp</span>.<span style="color:#a6e22e">set</span>(<span style="color:#a6e22e">_p_</span>)
    <span style="color:#75715e">// 唤醒m
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">notewakeup</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">mp</span>.<span style="color:#a6e22e">park</span>)
}
</code></pre></div><h3 id="49-调度循环">4.9 调度循环</h3>
<p><img src="https://cdn.jsdelivr.net/gh/nber1994/fu0k@master/uPic/image-2021112416050288820211124160503.png" alt="image-20211124160502888" style="zoom:50%;" /></p>
<p><strong>schedule</strong></p>
<p>首先进行调度次数检测，如果大于某个数，则从全局获取g，然后m在P的资源下执行g</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">schedule</span>() {
    <span style="color:#a6e22e">_g_</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">getg</span>()

    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">_g_</span>.<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">locks</span> <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span> {
        <span style="color:#a6e22e">throw</span>(<span style="color:#e6db74">&#34;schedule: holding locks&#34;</span>)
    }
    <span style="color:#75715e">// 如果有lockg，停止执行当前的m
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">_g_</span>.<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">lockedg</span> <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span> {
        <span style="color:#75715e">// 解除lockedm的锁定，并执行当前g
</span><span style="color:#75715e"></span>        <span style="color:#a6e22e">stoplockedm</span>()
        <span style="color:#a6e22e">execute</span>(<span style="color:#a6e22e">_g_</span>.<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">lockedg</span>.<span style="color:#a6e22e">ptr</span>(), <span style="color:#66d9ef">false</span>) <span style="color:#75715e">// Never returns.
</span><span style="color:#75715e"></span>    }

    <span style="color:#75715e">// We should not schedule away from a g that is executing a cgo call,
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// since the cgo call is using the m&#39;s g0 stack.
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">_g_</span>.<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">incgo</span> {
        <span style="color:#a6e22e">throw</span>(<span style="color:#e6db74">&#34;schedule: in cgo&#34;</span>)
    }

<span style="color:#a6e22e">top</span>:
    <span style="color:#75715e">// gc 等待
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">sched</span>.<span style="color:#a6e22e">gcwaiting</span> <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span> {
        <span style="color:#a6e22e">gcstopm</span>()
        <span style="color:#66d9ef">goto</span> <span style="color:#a6e22e">top</span>
    }

    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">gp</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">g</span>
    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">inheritTime</span> <span style="color:#66d9ef">bool</span>

    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">gp</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
        <span style="color:#75715e">// Check the global runnable queue once in a while to ensure fairness.
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// Otherwise two goroutines can completely occupy the local runqueue
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// by constantly respawning each other.
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// 为了保证公平，每隔61次，从全局队列上获取g
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">_g_</span>.<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">ptr</span>().<span style="color:#a6e22e">schedtick</span><span style="color:#f92672">%</span><span style="color:#ae81ff">61</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">sched</span>.<span style="color:#a6e22e">runqsize</span> &gt; <span style="color:#ae81ff">0</span> {
            <span style="color:#a6e22e">lock</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">sched</span>.<span style="color:#a6e22e">lock</span>)
            <span style="color:#a6e22e">gp</span> = <span style="color:#a6e22e">globrunqget</span>(<span style="color:#a6e22e">_g_</span>.<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">ptr</span>(), <span style="color:#ae81ff">1</span>)
            <span style="color:#a6e22e">unlock</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">sched</span>.<span style="color:#a6e22e">lock</span>)
        }
    }
    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">gp</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
        <span style="color:#75715e">// 全局队列上获取不到待运行的g，则从p local队列中获取
</span><span style="color:#75715e"></span>        <span style="color:#a6e22e">gp</span>, <span style="color:#a6e22e">inheritTime</span> = <span style="color:#a6e22e">runqget</span>(<span style="color:#a6e22e">_g_</span>.<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">ptr</span>())
        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">gp</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">_g_</span>.<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">spinning</span> {
            <span style="color:#a6e22e">throw</span>(<span style="color:#e6db74">&#34;schedule: spinning with local work&#34;</span>)
        }
    }
    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">gp</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
        <span style="color:#75715e">// 如果p local获取不到待运行g，则开始查找，这个函数会从 全局 io poll， p locl和其他p local获取待运行的g，后面详细分析
</span><span style="color:#75715e"></span>        <span style="color:#a6e22e">gp</span>, <span style="color:#a6e22e">inheritTime</span> = <span style="color:#a6e22e">findrunnable</span>() <span style="color:#75715e">// blocks until work is available
</span><span style="color:#75715e"></span>    }

    <span style="color:#75715e">// This thread is going to run a goroutine and is not spinning anymore,
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// so if it was marked as spinning we need to reset it now and potentially
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// start a new spinning M.
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">_g_</span>.<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">spinning</span> {
        <span style="color:#75715e">// 如果m是自旋状态，取消自旋
</span><span style="color:#75715e"></span>        <span style="color:#a6e22e">resetspinning</span>()
    }

    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">gp</span>.<span style="color:#a6e22e">lockedm</span> <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span> {
        <span style="color:#75715e">// Hands off own p to the locked m,
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// then blocks waiting for a new p.
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// 如果g有lockedm，则休眠上交p，休眠m，等待新的m，唤醒后从这里开始执行，跳转到top
</span><span style="color:#75715e"></span>        <span style="color:#a6e22e">startlockedm</span>(<span style="color:#a6e22e">gp</span>)
        <span style="color:#66d9ef">goto</span> <span style="color:#a6e22e">top</span>
    }
    <span style="color:#75715e">// 开始执行这个g
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">execute</span>(<span style="color:#a6e22e">gp</span>, <span style="color:#a6e22e">inheritTime</span>)
}
</code></pre></div><p>最后，仍然是gogo函数执行g的用户代码，同时伪造了call指令的栈帧，将goexit()函数写入了SP上，ret指令结束后会跳转到goexit()函数继续执行</p>
<p><strong>goexit()</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">goexit0</span>(<span style="color:#a6e22e">gp</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">g</span>) {
    <span style="color:#a6e22e">_g_</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">getg</span>()
    <span style="color:#75715e">// 转换g的状态为dead，以放回空闲列表
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">casgstatus</span>(<span style="color:#a6e22e">gp</span>, <span style="color:#a6e22e">_Grunning</span>, <span style="color:#a6e22e">_Gdead</span>)
    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">isSystemGoroutine</span>(<span style="color:#a6e22e">gp</span>) {
        <span style="color:#a6e22e">atomic</span>.<span style="color:#a6e22e">Xadd</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">sched</span>.<span style="color:#a6e22e">ngsys</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)
    }
    <span style="color:#75715e">// 清空g的状态
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">gp</span>.<span style="color:#a6e22e">m</span> = <span style="color:#66d9ef">nil</span>
    <span style="color:#a6e22e">locked</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">gp</span>.<span style="color:#a6e22e">lockedm</span> <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>
    <span style="color:#a6e22e">gp</span>.<span style="color:#a6e22e">lockedm</span> = <span style="color:#ae81ff">0</span>
    <span style="color:#a6e22e">_g_</span>.<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">lockedg</span> = <span style="color:#ae81ff">0</span>
    <span style="color:#a6e22e">gp</span>.<span style="color:#a6e22e">paniconfault</span> = <span style="color:#66d9ef">false</span>
    <span style="color:#a6e22e">gp</span>.<span style="color:#a6e22e">_defer</span> = <span style="color:#66d9ef">nil</span> <span style="color:#75715e">// should be true already but just in case.
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">gp</span>.<span style="color:#a6e22e">_panic</span> = <span style="color:#66d9ef">nil</span> <span style="color:#75715e">// non-nil for Goexit during panic. points at stack-allocated data.
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">gp</span>.<span style="color:#a6e22e">writebuf</span> = <span style="color:#66d9ef">nil</span>
    <span style="color:#a6e22e">gp</span>.<span style="color:#a6e22e">waitreason</span> = <span style="color:#ae81ff">0</span>
    <span style="color:#a6e22e">gp</span>.<span style="color:#a6e22e">param</span> = <span style="color:#66d9ef">nil</span>
    <span style="color:#a6e22e">gp</span>.<span style="color:#a6e22e">labels</span> = <span style="color:#66d9ef">nil</span>
    <span style="color:#a6e22e">gp</span>.<span style="color:#a6e22e">timer</span> = <span style="color:#66d9ef">nil</span>

    <span style="color:#75715e">// Note that gp&#39;s stack scan is now &#34;valid&#34; because it has no
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// stack.
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">gp</span>.<span style="color:#a6e22e">gcscanvalid</span> = <span style="color:#66d9ef">true</span>
    <span style="color:#a6e22e">dropg</span>()

    <span style="color:#75715e">// 把g放回空闲列表，以备复用
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">gfput</span>(<span style="color:#a6e22e">_g_</span>.<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">ptr</span>(), <span style="color:#a6e22e">gp</span>)
    <span style="color:#75715e">// 再次进入调度循环
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">schedule</span>()
}
</code></pre></div><p>最后调用schedule函数开始下一轮调用。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nber1994/fu0k@master/uPic/image-2021112416291048520211124162911.png" alt="image-20211124162910485" style="zoom:50%;" /></p>
<p>剩下的自己去看吧，我累了</p>
<h2 id="五非均匀存储访问调度器--提案">五、非均匀存储访问调度器 · 提案</h2>
<p>这个有兴趣自己研究吧</p>
<h1 id="参考资料">参考资料</h1>
<ul>
<li><a href="https://segmentfault.com/a/1190000020254937#item-3-3">这个GMP源码讲的比较清楚</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/404698231?utm_source=wechat_session&amp;utm_medium=social&amp;utm_oi=1034005455210786816">go scheduler这十年发展历程</a></li>
<li><a href="https://segmentfault.com/a/1190000040364177">图解协程调度模型-GMP模型</a></li>
<li><a href="https://learnku.com/articles/41728">GMP各种场景分析</a></li>
<li><a href="https://qcrao.com/ishare/go-scheduler/#true%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB">这哥们的文档大而全</a></li>
<li><a href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-goroutine/#p">这哥们马上出书了，从发展到代码都有涉及</a></li>
<li><a href="https://lessisbetter.site/2019/03/10/golang-scheduler-1-history/">大斌这哥们的系列文章-除了源码其他讲的非常清楚</a></li>
<li><a href="https://eddycjy.com/posts/go/go-tips-gmp-p/">GMP为什么有P-煎鱼</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1819618">GMP和GM动态图</a></li>
<li><a href="https://segmentfault.com/a/1190000016038785">很火的scheduler英文文档翻译</a></li>
</ul>

    </div>
</section>

    </body>
</html>