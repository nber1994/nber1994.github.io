<!DOCTYPE html>
<html lang="zh-cn">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<style type=text/css>body{font-family:monospace;}</style>
	<title>go-scheduler 下</title>
	
	
	<link rel="stylesheet" href="/css/style.css">
	
	
</head>
<body>
	<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">

        <link href="https://fonts.googleapis.com/css?family=Ubuntu" rel="stylesheet">

        <title>go-scheduler 下</title>

        <link rel="stylesheet" href="/css/stylesheet.css">
    </head>

<header>
        <section id="page-title">
            <h1><a href="/">nber1994</a></h1>

          <div class="date-time-title post">
			<a  href="/">All</a>
          </div>
			
			
          <div class="date-time-title post">
			<a href="/posts/">Posts</a>
          </div>
			
          <div class="date-time-title post">
			<a href="/categories/">Categories</a>
          </div>
			
          <div class="date-time-title post">
			<a href="/tags/">Tags</a>
          </div>
			
          <div class="date-time-title post">
			<a href="/about">About</a>
          </div>
			
	

        </section>
</header>

<div id="icon">
<script type="text/javascript">


    function chunkSubstr(str, size) {
            const numChunks = Math.ceil(str.length / size)
            const chunks = new Array(numChunks)

            for (let i = 0, o = 0; i < numChunks; ++i, o += size) {
                    chunks[i] = str.substr(o, size)
                }

            return chunks
        }
    var pic = [];
    pic[0] = "https://cdn.jsdelivr.net/gh/nber1994/fu0k@master/uPic/qRKvRQ20220116152554.jpg";
    pic[1] = "https://cdn.jsdelivr.net/gh/nber1994/fu0k@master/uPic/nEf3GW20220116150946.jpg";
    pic[2] = "https://cdn.jsdelivr.net/gh/nber1994/fu0k@master/uPic/ITL6SB20220116154359.jpg";
    pic[3] = "https://cdn.jsdelivr.net/gh/nber1994/fu0k@master/uPic/3QAQ7M20220116154758.jpg";
    pic[4] = "https://cdn.jsdelivr.net/gh/nber1994/fu0k@master/uPic/HCCsx620220116160636.jpg";
    pic[5] = "https://cdn.jsdelivr.net/gh/nber1994/fu0k@master/uPic/c4zSPk20220116161109.jpg";
    pic[6] = "https://cdn.jsdelivr.net/gh/nber1994/fu0k@master/uPic/Bm5IHA20220116161518.jpg";
    pic[7] = "https://cdn.jsdelivr.net/gh/nber1994/fu0k@master/uPic/lpcstW20220116161917.jpg";
    pic[8] = "https://cdn.jsdelivr.net/gh/nber1994/fu0k@master/uPic/MSCA4K20220116162440.jpg";

    var talk = [];
    talk[0] = "Help poor children in Uganda!";
    talk[1] = "Bad programmers worry about the code. Good programmers worry about data structures and their relationships.";
    talk[2] = "So, dear Redis community, today I’m stepping back as the Redis maintainer.";
    talk[3] = "Don't tune for speed until you've measured.";
    talk[4] = "C is quirky, flawed, and an enormous success.";
    talk[5] = "I've never thought of PHP as more than a simple tool to solve problems.";
    talk[6] = "Java is C++ without the guns, clubs and knives.";
    talk[7] = "Life is short, you need Python!";
    talk[8] = "C makes it easy to shoot yourself in the foot; C++ makes it harder, but when you do it blows your whole leg off.";

    var randomBgIndex = Math.floor( Math.random() * 8 );


    document.write("<img src=" + pic[randomBgIndex] + ">")
    document.write("<span style='font-size:12px'>" + talk[randomBgIndex] + " </span>")
    document.write("</div>")

</script>
</div>
<br>

	
<main>
    <article>
        <h1>go-scheduler 下</h1>
        <div id="common-a">
            <b><time>2021-11-25</time></b>&nbsp;&nbsp;&nbsp;
            
            <a href="/categories/go"> ❐go</a>
            
            
        </div>
    </article>
        <hr>
    </br>
    <aside id="toc">
        <nav id="TableOfContents">
  <ul>
    <li><a href="#三调度器-scheduler">三、调度器 Scheduler</a>
      <ul>
        <li><a href="#3-任务窃取调度器--11httpsgithubcomgolanggoblob779c45a50700bda0f6ec98429720802e6c1624e8srcpkgruntimeprocc">3. 任务窃取调度器 · <a href="https://github.com/golang/go/blob/779c45a50700bda0f6ec98429720802e6c1624e8/src/pkg/runtime/proc.c">1.1</a></a>
          <ul>
            <li><a href="#1-mcache泛滥---引入中间层p">1. mcache泛滥 - 引入中间层P</a></li>
            <li><a href="#2-资源竞争严重--goroutine传递问题---p构建本地g队列">2. 资源竞争严重 &amp; Goroutine传递问题 - P构建本地G队列</a></li>
            <li><a href="#3-频繁的线程阻塞">3. 频繁的线程阻塞</a></li>
          </ul>
        </li>
        <li><a href="#四抢占式调度器--12httpsgithubcomgolanggoblobgo12srcpkgruntimeprocc--至今">四、抢占式调度器 · <a href="https://github.com/golang/go/blob/go1.2/src/pkg/runtime/proc.c">1.2</a> ~ 至今</a>
          <ul>
            <li></li>
            <li><a href="#41-基于协作的抢占式调度器---12--113">4.1 基于协作的抢占式调度器 - 1.2 ~ 1.13</a></li>
            <li><a href="#42-基于信号的抢占式调度器---114--至今">4.2 基于信号的抢占式调度器 - 1.14 ~ 至今</a></li>
            <li><a href="#43-gmp-scheduler角色介绍">4.3 GMP Scheduler角色介绍</a></li>
            <li><a href="#44-gmp-整体一张图">4.4 GMP 整体一张图</a></li>
            <li><a href="#45-程序初始化">4.5 程序初始化</a></li>
            <li><a href="#46-调度器初始化">4.6 调度器初始化</a></li>
            <li><a href="#47-协程创建">4.7 协程创建</a></li>
            <li><a href="#48-启动m">4.8 启动M</a></li>
            <li><a href="#49-调度循环">4.9 调度循环</a></li>
          </ul>
        </li>
        <li><a href="#五非均匀存储访问调度器--提案">五、非均匀存储访问调度器 · 提案</a></li>
      </ul>
    </li>
    <li><a href="#参考资料">参考资料</a></li>
  </ul>
</nav>
    </aside>
        <div id="body">
            <h1 id="三调度器-scheduler">三、调度器 Scheduler</h1>
<h2 id="3-任务窃取调度器--11httpsgithubcomgolanggoblob779c45a50700bda0f6ec98429720802e6c1624e8srcpkgruntimeprocc">3. 任务窃取调度器 · <a href="https://github.com/golang/go/blob/779c45a50700bda0f6ec98429720802e6c1624e8/src/pkg/runtime/proc.c">1.1</a></h2>
<p>2012 年 Google 的工程师 Dmitry Vyukov 在 <a href="http://golang.org/s/go11sched">Scalable Go Scheduler Design Doc</a> 中指出了现有多线程调度器的问题，并且针对出现的问题，针对性的进行了改进设计。</p>
<p>我们来回顾下GM模型带来的问题：</p>
<ul>
<li>mcache泛滥</li>
<li>资源竞争严重</li>
<li>Goroutine传递问题</li>
<li>频繁的线程阻塞/解阻塞</li>
</ul>
<p>下面我们分开来看，为了解决各个问题，分别引入了哪些设计</p>
<h3 id="1-mcache泛滥---引入中间层p">1. mcache泛滥 - 引入中间层P</h3>
<p>在Goroutine和线程之间引入了中间层P，其数量对应于机器的核数，且只有P持有mcache，并且P托管了M运行所需的上下文。每个M都需要绑定到P上才能够获得G。</p>
<img src="https://cdn.jsdelivr.net/gh/nber1994/fu0k@master/uPic/image-202111241226080732021112412260820211124151844.png" alt="image-20211124122608073" style="zoom: 50%;" />
<p>这样一来，每个M做到了减重，M变成了一个很干净的系统线程封装。减少了很多冗余的mcache。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#000;font-weight:bold">type</span> p <span style="color:#000;font-weight:bold">struct</span> {
   lock mutex

   id          <span style="color:#458;font-weight:bold">int32</span>
   <span style="color:#998;font-style:italic">// p的状态
</span><span style="color:#998;font-style:italic"></span>   status      <span style="color:#458;font-weight:bold">uint32</span> <span style="color:#998;font-style:italic">// one of pidle/prunning/...
</span><span style="color:#998;font-style:italic"></span>   <span style="color:#998;font-style:italic">// 下一个p的地址，可参考 g.schedlink
</span><span style="color:#998;font-style:italic"></span>   link        puintptr
   <span style="color:#998;font-style:italic">// p所关联的m
</span><span style="color:#998;font-style:italic"></span>   m           muintptr   <span style="color:#998;font-style:italic">// back-link to associated m (nil if idle)
</span><span style="color:#998;font-style:italic"></span>   <span style="color:#998;font-style:italic">// 内存分配的时候用的，p所属的m的mcache用的也是这个
</span><span style="color:#998;font-style:italic"></span>   mcache      <span style="color:#000;font-weight:bold">*</span>mcache
  
   <span style="color:#998;font-style:italic">// Cache of goroutine ids, amortizes accesses to runtime·sched.goidgen.
</span><span style="color:#998;font-style:italic"></span>   <span style="color:#998;font-style:italic">// 从sched中获取并缓存的id，避免每次分配goid都从sched分配
</span><span style="color:#998;font-style:italic"></span>     goidcache    <span style="color:#458;font-weight:bold">uint64</span>
     goidcacheend <span style="color:#458;font-weight:bold">uint64</span>

   <span style="color:#998;font-style:italic">// Queue of runnable goroutines. Accessed without lock.
</span><span style="color:#998;font-style:italic"></span>   <span style="color:#998;font-style:italic">// p 本地的runnbale的goroutine形成的队列
</span><span style="color:#998;font-style:italic"></span>   runqhead <span style="color:#458;font-weight:bold">uint32</span>
   runqtail <span style="color:#458;font-weight:bold">uint32</span>
   runq     [<span style="color:#099">256</span>]guintptr
   <span style="color:#998;font-style:italic">// 下一个执行的g，如果是nil，则从队列中获取下一个执行的g
</span><span style="color:#998;font-style:italic"></span>   runnext guintptr

   <span style="color:#998;font-style:italic">// Available G&#39;s (status == Gdead)
</span><span style="color:#998;font-style:italic"></span>   <span style="color:#998;font-style:italic">// 状态为 Gdead的g的列表，可以进行复用
</span><span style="color:#998;font-style:italic"></span>   gfree    <span style="color:#000;font-weight:bold">*</span>g
   gfreecnt <span style="color:#458;font-weight:bold">int32</span>
}
</code></pre></div><p>我们可以看到，mcache已经被P托管了，并且M只有获得P才能执行</p>
<img src="https://cdn.jsdelivr.net/gh/nber1994/fu0k@master/uPic/image-202111241349090142021112413490920211124151846.png" alt="image-20211124134909014" style="zoom: 33%;" />
<h3 id="2-资源竞争严重--goroutine传递问题---p构建本地g队列">2. 资源竞争严重 &amp; Goroutine传递问题 - P构建本地G队列</h3>
<p>为了减少全局锁的竞争，很常见的思路就是减少锁的粒度，在原有全局G队列的基础上，在每个P上也维护了本地G队列，并且保留全局G队列，作为一个G的暂存空间 &amp; 负载均衡使用。而且本G创建的G&rsquo;优先放入本地队列，很好的保证了局部性。</p>
<img src="https://cdn.jsdelivr.net/gh/nber1994/fu0k@master/uPic/2019-04-image-20190331160728024-4019648-2021112415184666020211124151846.png" alt="img" style="zoom: 50%;" />
<h4 id="1新建goroutine">1.新建Goroutine</h4>
<img src="https://cdn.jsdelivr.net/gh/nber1994/fu0k@master/uPic/2019-04-image-20190331190809649-40304892021112413553720211124151847.png" alt="img"  />
<p>p1拥有g1，m1获取p1后开始运行g1，g1使用<code>go func()</code>创建了g2，为了局部性g2优先加入到p1的本地队列。</p>
<h4 id="2goroutine切换">2.Goroutine切换</h4>
<p><img src="https://cdn.jsdelivr.net/gh/nber1994/fu0k@master/uPic/2019-04-image-20190331190826838-403050620211124135714.png" alt="img"></p>
<h4 id="3全局队列和本地g队列负载均衡">3.全局队列和本地G队列负载均衡</h4>
<p>因为每个p都维护了本地队列，但是这些队列可能存在G不均匀的情况，例如一个P下的G疯狂的在go func()，那么很快P的本地G队列就要满了，如果P创建的G都在P执行的话，那么会出现一核拼命跑，另外几个核在旁边吃瓜的情况，所以引入了负载均衡的策略，当本地G队列满了之后，将一部分G转移到全局G队列，其他P本地G队列空了后，可以从全局队列，来使G均匀的运行在所有P上。</p>
<img src="https://lessisbetter.site/images/2019-04-image-20190331160718646-4019638.png" alt="img" style="zoom:50%;" />
<p>假设每个p的本地队列只能存4个g。g2要创建了6个g，前4个g（g3, g4, g5, g6）已经加入p1的本地队列，p1本地队列满了。</p>
<img src="https://cdn.jsdelivr.net/gh/nber1994/fu0k@master/uPic/2019-04-image-20190331160728024-4019648-2021112415184666020211124151846.png" alt="img" style="zoom: 50%;" />
<p>g2在创建g7的时候，发现p1的本地队列已满，需要执行<strong>负载均衡</strong>，把p1中本地队列中前一半的g，还有新创建的g<strong>转移</strong>到全局队列（实现中并不一定是新的g，如果g是g2之后就执行的，会被保存在本地队列，利用某个老的g替换新g加入全局队列），这些g被转移到全局队列时，会被打乱顺序。所以g3,g4,g7被转移到全局队列。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nber1994/fu0k@master/uPic/2019-04-image-20190331162734830-40208542021112414022220211124151848.png" alt="img"></p>
<p>从全局看，假设还有另外的p2绑定了m2，并且本地队列为空（m自旋状态）</p>
<img src="https://cdn.jsdelivr.net/gh/nber1994/fu0k@master/uPic/2019-04-image-20190331162717486-40208372021112414091320211124151848.png" alt="img" style="zoom:67%;" />
<p>此时m2尝试从全局队列(GQ)取一批g放到p2的本地队列（函数：<code>findrunnable</code>）。m2从全局队列取的g数量符合下面的公式：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go">n = <span style="color:#900;font-weight:bold">min</span>(<span style="color:#0086b3">len</span>(GQ)<span style="color:#000;font-weight:bold">/</span>GOMAXPROCS <span style="color:#000;font-weight:bold">+</span> <span style="color:#099">1</span>, <span style="color:#0086b3">len</span>(GQ<span style="color:#000;font-weight:bold">/</span><span style="color:#099">2</span>))
</code></pre></div><p>总体的含义是说，至少从全局G中拿1个G，但是又不会获取过多，会给其他P预留一些。</p>
<h4 id="4本地g队列负载均衡">4.本地G队列负载均衡</h4>
<p>除了从全局队列中获取G来运行之外，当全局队列为空时，P还会尝试从其他P的本地队列偷取一些来运行，反正总而言之就是让G在全局P上均匀的运行。</p>
<img src="https://cdn.jsdelivr.net/gh/nber1994/fu0k@master/uPic/2020-09-go-scheduler-p82021112414142920211124151848.png" alt="img" style="zoom:67%;" />
<p>由此可见，当全局队列为空时，自旋的P2会从P2的本地队列中偷取一半到本地队列进行运行。</p>
<h3 id="3-频繁的线程阻塞">3. 频繁的线程阻塞</h3>
<p>针对Goroutine的不同阻塞情况，GMP模型做了更细化的处理，目的就是为了减少线程阻塞时间，把阻塞的G及时的让出CPU去运行其他线程。</p>
<p>在go中阻塞主要分为以下四种场景：</p>
<ol>
<li>原子性，互斥量或者channel操作导致的Goroutine阻塞</li>
<li>由于网络请求和IO操作导致的Goroutine阻塞</li>
<li>调用一些系统方法时，例如文件读写导致Goroutine阻塞</li>
<li>Goroutine中执行了sleep操作导致Goroutine阻塞</li>
</ol>
<h4 id="netpoller-thread---网络请求和-io阻塞">NetPoller Thread - 网络请求和 IO阻塞</h4>
<p>由于网络请求和 IO 操作导致 Goroutine 阻塞。Go 程序提供了网络轮询器（NetPoller）来处理网络请求和 IO 操作的问题。</p>
<p>其后台通过 kqueue（MacOS），epoll（Linux）或 iocp（Windows）来实现 IO 多路复用。</p>
<p>通过使用 NetPoller 进行网络系统调用，调度器可以防止 Goroutine 在进行这些系统调用时阻塞 M。这可以让 M 执行 P 的 LRQ 中其他的 Goroutines，而不需要创建新的 M。执行网络系统调用不需要额外的 M，<strong>网络轮询器使用系统线程</strong></p>
<img src="https://cdn.jsdelivr.net/gh/nber1994/fu0k@master/uPic/go_scheduler_async_systemcall_12021112414241620211124151849.png" alt="img" style="zoom:67%;" />
<p>当前G1要进行网络请求，此时G1会被转移到NetPoller进行托管，P从本地G队列获取G2给到M继续执行。</p>
<img src="https://cdn.jsdelivr.net/gh/nber1994/fu0k@master/uPic/go_scheduler_async_systemcall_220211124142557.png" alt="img" style="zoom:67%;" />
<p>G1执行完成后，G1放入原P的本地队列，继续等待执行</p>
<img src="https://cdn.jsdelivr.net/gh/nber1994/fu0k@master/uPic/go_scheduler_async_systemcall_32021112414263320211124151849.png" alt="img" style="zoom:67%;" />
<h4 id="系统调用阻塞">系统调用阻塞</h4>
<p>G1即将进行阻塞型的同步系统调用</p>
<img src="https://cdn.jsdelivr.net/gh/nber1994/fu0k@master/uPic/go_scheduler_sync_systemcall_12021112414273720211124151850.png" alt="img" style="zoom:67%;" />
<p>调度器会将M1，G1和P进行分离，同时引入新的M2来服务P</p>
<img src="https://cdn.jsdelivr.net/gh/nber1994/fu0k@master/uPic/go_scheduler_sync_systemcall_220211124142847.png" alt="img" style="zoom:67%;" />
<p>当G1系统调用完成后，G1会回归P的本地队列，等待继续执行</p>
<img src="https://cdn.jsdelivr.net/gh/nber1994/fu0k@master/uPic/go_scheduler_sync_systemcall_32021112414292420211124151850.png" alt="img" style="zoom:67%;" />
<h2 id="四抢占式调度器--12httpsgithubcomgolanggoblobgo12srcpkgruntimeprocc--至今">四、抢占式调度器 · <a href="https://github.com/golang/go/blob/go1.2/src/pkg/runtime/proc.c">1.2</a> ~ 至今</h2>
<h4 id="sysmon线程">sysmon线程</h4>
<p>上一个版本，引入了P等一系列措施，基本上解决了GM模型存在的一些问题</p>
<p>我们来回顾下GM模型带来的问题：</p>
<ul>
<li><del>mcache泛滥</del></li>
<li><del>资源竞争严重</del></li>
<li><del>Goroutine传递问题</del></li>
<li>频繁的线程阻塞/解阻塞</li>
</ul>
<p>除了最后一个问题，我们拆开来看</p>
<p>在go中阻塞主要分为以下四种场景：</p>
<ol>
<li>原子性，互斥量或者channel操作导致的Goroutine阻塞</li>
<li><del>由于网络请求和IO操作导致的Goroutine阻塞</del></li>
<li><del>调用一些系统方法时，例如文件读写导致Goroutine阻塞</del></li>
<li>Goroutine中执行了sleep操作导致Goroutine阻塞</li>
</ol>
<p>针对Goroutine内部的诸如原子访问，锁，channel阻塞以及sleep函数休眠等造成的阻塞，GMP借助了系统监控线程sysmon来进行解决，它会每隔一段时间<strong>检查 Go 语言runtime</strong>，确保程序没有进入异常状态。</p>
<p>系统监控的触发时间就会稳定在 10ms，功能比较多:</p>
<ol>
<li>检查死锁runtime.checkdead</li>
<li>运行计时器 — 获取下一个需要被触发的计时器；</li>
<li>定时从 netpoll 中获取 ready 的协程</li>
<li><a href="https://mp.weixin.qq.com/s/d7FdGBc0S0V3S4aRL4EByA">Go 的抢占式调度</a></li>
</ol>
<h3 id="41-基于协作的抢占式调度器---12--113">4.1 基于协作的抢占式调度器 - 1.2 ~ 1.13</h3>
<h4 id="原理">原理</h4>
<p>当 sysmon 发现 M 已运行同一个 G（Goroutine）10ms 以上时，它会将该 G 的内部参数 preempt 设置为 true。然后，在函数序言中，当 G 进行函数调用时，G 会检查自己的 preempt 标志，如果它为 true，则它将自己与 M 分离并推入“全局队列”。</p>
<h4 id="问题">问题</h4>
<p>由于它的工作方式（函数调用触发），在 <code>for{}</code> 的情况下并不会发生抢占，如果没有函数调用，即使设置了抢占标志，也不会进行该标志的检查</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#000;font-weight:bold">func</span> <span style="color:#900;font-weight:bold">main</span>() {
	<span style="color:#000;font-weight:bold">var</span> x <span style="color:#458;font-weight:bold">int</span>
	threads <span style="color:#000;font-weight:bold">:=</span> runtime.<span style="color:#900;font-weight:bold">GOMAXPROCS</span>(<span style="color:#099">0</span>)
	<span style="color:#000;font-weight:bold">for</span> i <span style="color:#000;font-weight:bold">:=</span> <span style="color:#099">0</span>; i &lt; threads; i<span style="color:#000;font-weight:bold">++</span> {
		<span style="color:#000;font-weight:bold">go</span> <span style="color:#000;font-weight:bold">func</span>() {
			<span style="color:#000;font-weight:bold">for</span> { x<span style="color:#000;font-weight:bold">++</span> }
		}()
	}
	time.<span style="color:#900;font-weight:bold">Sleep</span>(time.Second)
	fmt.<span style="color:#900;font-weight:bold">Println</span>(<span style="color:#d14">&#34;x =&#34;</span>, x)
}
</code></pre></div><p>运行结果：</p>
<p>启动了和cpu核心数相同的g，每个g都绑定了一个p，但是每个又进入了for循环，不存在调度点，所有的P都在执行for循环，此时永远都不会到达print。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#000;font-weight:bold">func</span> <span style="color:#900;font-weight:bold">main</span>() {
	<span style="color:#000;font-weight:bold">var</span> x <span style="color:#458;font-weight:bold">int</span>
	threads <span style="color:#000;font-weight:bold">:=</span> runtime.<span style="color:#900;font-weight:bold">GOMAXPROCS</span>(<span style="color:#099">0</span>) <span style="color:#000;font-weight:bold">-</span> <span style="color:#099">1</span>
	<span style="color:#000;font-weight:bold">for</span> i <span style="color:#000;font-weight:bold">:=</span> <span style="color:#099">0</span>; i &lt; threads; i<span style="color:#000;font-weight:bold">++</span> {
		<span style="color:#000;font-weight:bold">go</span> <span style="color:#000;font-weight:bold">func</span>() {
			<span style="color:#000;font-weight:bold">for</span> { x<span style="color:#000;font-weight:bold">++</span> }
		}()
	}
	time.<span style="color:#900;font-weight:bold">Sleep</span>(time.Second)
	fmt.<span style="color:#900;font-weight:bold">Println</span>(<span style="color:#d14">&#34;x =&#34;</span>, x)
}
</code></pre></div><p>运行结果</p>
<pre tabindex="0"><code>x = 0
</code></pre><h3 id="42-基于信号的抢占式调度器---114--至今">4.2 基于信号的抢占式调度器 - 1.14 ~ 至今</h3>
<h4 id="原理-1">原理</h4>
<p>Go1.14 引入抢占式调度（使用信号的异步抢占机制），sysmon 仍然会检测到运行了 10ms 以上的 G（goroutine）。然后，sysmon 向运行 G 的 P 发送信号（SIGURG）。Go 的信号处理程序会调用P上的一个叫作 gsignal 的 goroutine 来处理该信号，将其映射到 M 而不是 G，并使其检查该信号。gsignal 看到抢占信号，停止正在运行的 G。</p>
<h3 id="43-gmp-scheduler角色介绍">4.3 GMP Scheduler角色介绍</h3>
<img src="https://cdn.jsdelivr.net/gh/nber1994/fu0k@master/uPic/image-202111241226080732021112412260820211124151844.png" alt="image-20211124122608073" style="zoom: 50%;" />
<h4 id="g">G</h4>
<p>goroutine是运行时的最小执行单元</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#000;font-weight:bold">type</span> g <span style="color:#000;font-weight:bold">struct</span> {
    <span style="color:#998;font-style:italic">// Stack parameters.
</span><span style="color:#998;font-style:italic"></span>    <span style="color:#998;font-style:italic">// stack describes the actual stack memory: [stack.lo, stack.hi).
</span><span style="color:#998;font-style:italic"></span>    <span style="color:#998;font-style:italic">// stackguard0 is the stack pointer compared in the Go stack growth prologue.
</span><span style="color:#998;font-style:italic"></span>    <span style="color:#998;font-style:italic">// It is stack.lo+StackGuard normally, but can be StackPreempt to trigger a preemption.
</span><span style="color:#998;font-style:italic"></span>    <span style="color:#998;font-style:italic">// stackguard1 is the stack pointer compared in the C stack growth prologue.
</span><span style="color:#998;font-style:italic"></span>    <span style="color:#998;font-style:italic">// It is stack.lo+StackGuard on g0 and gsignal stacks.
</span><span style="color:#998;font-style:italic"></span>    <span style="color:#998;font-style:italic">// It is ~0 on other goroutine stacks, to trigger a call to morestackc (and crash).
</span><span style="color:#998;font-style:italic"></span>  <span style="color:#998;font-style:italic">// 当前g使用的栈空间，stack结构包括 [lo, hi]两个成员
</span><span style="color:#998;font-style:italic"></span>    stack       stack   <span style="color:#998;font-style:italic">// offset known to runtime/cgo
</span><span style="color:#998;font-style:italic"></span>  <span style="color:#998;font-style:italic">// 用于检测是否需要进行栈扩张，go代码使用
</span><span style="color:#998;font-style:italic"></span>    stackguard0 <span style="color:#458;font-weight:bold">uintptr</span> <span style="color:#998;font-style:italic">// offset known to liblink
</span><span style="color:#998;font-style:italic"></span>  <span style="color:#998;font-style:italic">// 用于检测是否需要进行栈扩展，原生代码使用的
</span><span style="color:#998;font-style:italic"></span>    stackguard1 <span style="color:#458;font-weight:bold">uintptr</span> <span style="color:#998;font-style:italic">// offset known to liblink
</span><span style="color:#998;font-style:italic"></span>  <span style="color:#998;font-style:italic">// 当前g所绑定的m
</span><span style="color:#998;font-style:italic"></span>    m              <span style="color:#000;font-weight:bold">*</span>m      <span style="color:#998;font-style:italic">// current m; offset known to arm liblink
</span><span style="color:#998;font-style:italic"></span>  <span style="color:#998;font-style:italic">// 当前g的调度数据，当goroutine切换时，保存当前g的上下文，用于恢复
</span><span style="color:#998;font-style:italic"></span>    sched          gobuf
    <span style="color:#998;font-style:italic">// g当前的状态
</span><span style="color:#998;font-style:italic"></span>    atomicstatus   <span style="color:#458;font-weight:bold">uint32</span>
  <span style="color:#998;font-style:italic">// 当前g的id
</span><span style="color:#998;font-style:italic"></span>    goid           <span style="color:#458;font-weight:bold">int64</span>
  <span style="color:#998;font-style:italic">// 下一个g的地址，通过guintptr结构体的ptr set函数可以设置和获取下一个g，通过这个字段和sched.gfreeStack sched.gfreeNoStack 可以把 free g串成一个链表
</span><span style="color:#998;font-style:italic"></span>    schedlink      guintptr
  <span style="color:#998;font-style:italic">// 判断g是否允许被抢占
</span><span style="color:#998;font-style:italic"></span>    preempt        <span style="color:#458;font-weight:bold">bool</span>       <span style="color:#998;font-style:italic">// preemption signal, duplicates stackguard0 = stackpreempt
</span><span style="color:#998;font-style:italic"></span>    <span style="color:#998;font-style:italic">// g是否要求要回到这个M执行, 有的时候g中断了恢复会要求使用原来的M执行
</span><span style="color:#998;font-style:italic"></span>    lockedm        muintptr
}
</code></pre></div><h4 id="m">M</h4>
<p>系统线程封装</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#000;font-weight:bold">type</span> m <span style="color:#000;font-weight:bold">struct</span> {
   <span style="color:#998;font-style:italic">// g0是用于调度和执行系统调用的特殊g
</span><span style="color:#998;font-style:italic"></span>   g0      <span style="color:#000;font-weight:bold">*</span>g     <span style="color:#998;font-style:italic">// goroutine with scheduling stack
</span><span style="color:#998;font-style:italic"></span>     <span style="color:#998;font-style:italic">// m当前运行的g
</span><span style="color:#998;font-style:italic"></span>   curg          <span style="color:#000;font-weight:bold">*</span>g       <span style="color:#998;font-style:italic">// current running goroutine
</span><span style="color:#998;font-style:italic"></span>   <span style="color:#998;font-style:italic">// 当前拥有的p
</span><span style="color:#998;font-style:italic"></span>   p             puintptr <span style="color:#998;font-style:italic">// attached p for executing go code (nil if not executing go code)
</span><span style="color:#998;font-style:italic"></span>   <span style="color:#998;font-style:italic">// 线程的 local storage
</span><span style="color:#998;font-style:italic"></span>   tls           [<span style="color:#099">6</span>]<span style="color:#458;font-weight:bold">uintptr</span>   <span style="color:#998;font-style:italic">// thread-local storage
</span><span style="color:#998;font-style:italic"></span>   <span style="color:#998;font-style:italic">// 唤醒m时，m会拥有这个p
</span><span style="color:#998;font-style:italic"></span>   nextp         puintptr
   id            <span style="color:#458;font-weight:bold">int64</span>
   <span style="color:#998;font-style:italic">// 如果 !=&#34;&#34;, 继续运行curg
</span><span style="color:#998;font-style:italic"></span>   preemptoff    <span style="color:#458;font-weight:bold">string</span> <span style="color:#998;font-style:italic">// if != &#34;&#34;, keep curg running on this m
</span><span style="color:#998;font-style:italic"></span>   <span style="color:#998;font-style:italic">// 自旋状态，用于判断m是否工作已结束，并寻找g进行工作
</span><span style="color:#998;font-style:italic"></span>   spinning      <span style="color:#458;font-weight:bold">bool</span> <span style="color:#998;font-style:italic">// m is out of work and is actively looking for work
</span><span style="color:#998;font-style:italic"></span>   <span style="color:#998;font-style:italic">// 用于判断m是否进行休眠状态
</span><span style="color:#998;font-style:italic"></span>   blocked       <span style="color:#458;font-weight:bold">bool</span> <span style="color:#998;font-style:italic">// m is blocked on a note
</span><span style="color:#998;font-style:italic"></span>     <span style="color:#998;font-style:italic">// m休眠和唤醒通过这个，note里面有一个成员key，对这个key所指向的地址进行值的修改，进而达到唤醒和休眠的目的
</span><span style="color:#998;font-style:italic"></span>   park          note
   <span style="color:#998;font-style:italic">// 所有m组成的一个链表
</span><span style="color:#998;font-style:italic"></span>   alllink       <span style="color:#000;font-weight:bold">*</span>m <span style="color:#998;font-style:italic">// on allm
</span><span style="color:#998;font-style:italic"></span>   <span style="color:#998;font-style:italic">// 下一个m，通过这个字段和sched.midle 可以串成一个m的空闲链表
</span><span style="color:#998;font-style:italic"></span>   schedlink     muintptr
   <span style="color:#998;font-style:italic">// mcache，m拥有p的时候，会把自己的mcache给p
</span><span style="color:#998;font-style:italic"></span>   mcache        <span style="color:#000;font-weight:bold">*</span>mcache
   <span style="color:#998;font-style:italic">// lockedm的对应值
</span><span style="color:#998;font-style:italic"></span>   lockedg       guintptr
   <span style="color:#998;font-style:italic">// 待释放的m的list，通过sched.freem 串成一个链表
</span><span style="color:#998;font-style:italic"></span>   freelink      <span style="color:#000;font-weight:bold">*</span>m      <span style="color:#998;font-style:italic">// on sched.freem
</span><span style="color:#998;font-style:italic"></span>}
</code></pre></div><h4 id="p">P</h4>
<p>P是M运行G所需的资源</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#000;font-weight:bold">type</span> p <span style="color:#000;font-weight:bold">struct</span> {
   lock mutex

   id          <span style="color:#458;font-weight:bold">int32</span>
   <span style="color:#998;font-style:italic">// p的状态，稍后介绍
</span><span style="color:#998;font-style:italic"></span>   status      <span style="color:#458;font-weight:bold">uint32</span> <span style="color:#998;font-style:italic">// one of pidle/prunning/...
</span><span style="color:#998;font-style:italic"></span>   <span style="color:#998;font-style:italic">// 下一个p的地址，可参考 g.schedlink
</span><span style="color:#998;font-style:italic"></span>   link        puintptr
   <span style="color:#998;font-style:italic">// p所关联的m
</span><span style="color:#998;font-style:italic"></span>   m           muintptr   <span style="color:#998;font-style:italic">// back-link to associated m (nil if idle)
</span><span style="color:#998;font-style:italic"></span>   <span style="color:#998;font-style:italic">// 内存分配的时候用的，p所属的m的mcache用的也是这个
</span><span style="color:#998;font-style:italic"></span>   mcache      <span style="color:#000;font-weight:bold">*</span>mcache
  
   <span style="color:#998;font-style:italic">// Cache of goroutine ids, amortizes accesses to runtime·sched.goidgen.
</span><span style="color:#998;font-style:italic"></span>   <span style="color:#998;font-style:italic">// 从sched中获取并缓存的id，避免每次分配goid都从sched分配
</span><span style="color:#998;font-style:italic"></span>     goidcache    <span style="color:#458;font-weight:bold">uint64</span>
     goidcacheend <span style="color:#458;font-weight:bold">uint64</span>

   <span style="color:#998;font-style:italic">// Queue of runnable goroutines. Accessed without lock.
</span><span style="color:#998;font-style:italic"></span>   <span style="color:#998;font-style:italic">// p 本地的runnbale的goroutine形成的队列
</span><span style="color:#998;font-style:italic"></span>   runqhead <span style="color:#458;font-weight:bold">uint32</span>
   runqtail <span style="color:#458;font-weight:bold">uint32</span>
   runq     [<span style="color:#099">256</span>]guintptr
   <span style="color:#998;font-style:italic">// runnext, if non-nil, is a runnable G that was ready&#39;d by
</span><span style="color:#998;font-style:italic"></span>   <span style="color:#998;font-style:italic">// the current G and should be run next instead of what&#39;s in
</span><span style="color:#998;font-style:italic"></span>   <span style="color:#998;font-style:italic">// runq if there&#39;s time remaining in the running G&#39;s time
</span><span style="color:#998;font-style:italic"></span>   <span style="color:#998;font-style:italic">// slice. It will inherit the time left in the current time
</span><span style="color:#998;font-style:italic"></span>   <span style="color:#998;font-style:italic">// slice. If a set of goroutines is locked in a
</span><span style="color:#998;font-style:italic"></span>   <span style="color:#998;font-style:italic">// communicate-and-wait pattern, this schedules that set as a
</span><span style="color:#998;font-style:italic"></span>   <span style="color:#998;font-style:italic">// unit and eliminates the (potentially large) scheduling
</span><span style="color:#998;font-style:italic"></span>   <span style="color:#998;font-style:italic">// latency that otherwise arises from adding the ready&#39;d
</span><span style="color:#998;font-style:italic"></span>   <span style="color:#998;font-style:italic">// goroutines to the end of the run queue.
</span><span style="color:#998;font-style:italic"></span>   <span style="color:#998;font-style:italic">// 下一个执行的g，如果是nil，则从队列中获取下一个执行的g
</span><span style="color:#998;font-style:italic"></span>   runnext guintptr

   <span style="color:#998;font-style:italic">// Available G&#39;s (status == Gdead)
</span><span style="color:#998;font-style:italic"></span>   <span style="color:#998;font-style:italic">// 状态为 Gdead的g的列表，可以进行复用
</span><span style="color:#998;font-style:italic"></span>   gfree    <span style="color:#000;font-weight:bold">*</span>g
   gfreecnt <span style="color:#458;font-weight:bold">int32</span>
}
</code></pre></div><p>可以看到，P上维护了mcache，并且维护了本地的runq队列。并且所有的P相互关联。</p>
<h4 id="sched">Sched</h4>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#000;font-weight:bold">var</span> allp [_MaxGomaxprocs <span style="color:#000;font-weight:bold">+</span> <span style="color:#099">1</span>]<span style="color:#000;font-weight:bold">*</span>p

<span style="color:#000;font-weight:bold">type</span> schedt <span style="color:#000;font-weight:bold">struct</span> {
   <span style="color:#998;font-style:italic">// 全局的go id分配
</span><span style="color:#998;font-style:italic"></span>   goidgen  <span style="color:#458;font-weight:bold">uint64</span>
   <span style="color:#998;font-style:italic">// 记录的最后一次从i/o中查询g的时间
</span><span style="color:#998;font-style:italic"></span>   lastpoll <span style="color:#458;font-weight:bold">uint64</span>

   lock mutex

   <span style="color:#998;font-style:italic">// When increasing nmidle, nmidlelocked, nmsys, or nmfreed, be
</span><span style="color:#998;font-style:italic"></span>   <span style="color:#998;font-style:italic">// sure to call checkdead().
</span><span style="color:#998;font-style:italic"></span>     <span style="color:#998;font-style:italic">// m的空闲链表，结合m.schedlink 就可以组成一个空闲链表了
</span><span style="color:#998;font-style:italic"></span>   midle        muintptr <span style="color:#998;font-style:italic">// idle m&#39;s waiting for work
</span><span style="color:#998;font-style:italic"></span>   nmidle       <span style="color:#458;font-weight:bold">int32</span>    <span style="color:#998;font-style:italic">// number of idle m&#39;s waiting for work
</span><span style="color:#998;font-style:italic"></span>   nmidlelocked <span style="color:#458;font-weight:bold">int32</span>    <span style="color:#998;font-style:italic">// number of locked m&#39;s waiting for work
</span><span style="color:#998;font-style:italic"></span>   <span style="color:#998;font-style:italic">// 下一个m的id，也用来记录创建的m数量
</span><span style="color:#998;font-style:italic"></span>   mnext        <span style="color:#458;font-weight:bold">int64</span>    <span style="color:#998;font-style:italic">// number of m&#39;s that have been created and next M ID
</span><span style="color:#998;font-style:italic"></span>   <span style="color:#998;font-style:italic">// 最多允许的m的数量
</span><span style="color:#998;font-style:italic"></span>   maxmcount    <span style="color:#458;font-weight:bold">int32</span>    <span style="color:#998;font-style:italic">// maximum number of m&#39;s allowed (or die)
</span><span style="color:#998;font-style:italic"></span>   nmsys        <span style="color:#458;font-weight:bold">int32</span>    <span style="color:#998;font-style:italic">// number of system m&#39;s not counted for deadlock
</span><span style="color:#998;font-style:italic"></span>   <span style="color:#998;font-style:italic">// free掉的m的数量，exit的m的数量
</span><span style="color:#998;font-style:italic"></span>   nmfreed      <span style="color:#458;font-weight:bold">int64</span>    <span style="color:#998;font-style:italic">// cumulative number of freed m&#39;s
</span><span style="color:#998;font-style:italic"></span>
   ngsys <span style="color:#458;font-weight:bold">uint32</span> <span style="color:#998;font-style:italic">// number of system goroutines; updated atomically
</span><span style="color:#998;font-style:italic"></span>
   pidle      puintptr <span style="color:#998;font-style:italic">// idle p&#39;s
</span><span style="color:#998;font-style:italic"></span>   npidle     <span style="color:#458;font-weight:bold">uint32</span>
   nmspinning <span style="color:#458;font-weight:bold">uint32</span> <span style="color:#998;font-style:italic">// See &#34;Worker thread parking/unparking&#34; comment in proc.go.
</span><span style="color:#998;font-style:italic"></span>
   <span style="color:#998;font-style:italic">// Global runnable queue.
</span><span style="color:#998;font-style:italic"></span>   <span style="color:#998;font-style:italic">// 这个就是全局的g的队列了，如果p的本地队列没有g或者太多，会跟全局队列进行平衡
</span><span style="color:#998;font-style:italic"></span>   <span style="color:#998;font-style:italic">// 根据runqhead可以获取队列头的g，然后根据g.schedlink 获取下一个，从而形成了一个链表
</span><span style="color:#998;font-style:italic"></span>   runqhead guintptr
   runqtail guintptr
   runqsize <span style="color:#458;font-weight:bold">int32</span>

   <span style="color:#998;font-style:italic">// freem is the list of m&#39;s waiting to be freed when their
</span><span style="color:#998;font-style:italic"></span>   <span style="color:#998;font-style:italic">// m.exited is set. Linked through m.freelink.
</span><span style="color:#998;font-style:italic"></span>   <span style="color:#998;font-style:italic">// 等待释放的m的列表
</span><span style="color:#998;font-style:italic"></span>   freem <span style="color:#000;font-weight:bold">*</span>m
}
</code></pre></div><p>全局结构上新增了全局的p列表，并且和sched结构拆分了，减少锁竞争</p>
<h3 id="44-gmp-整体一张图">4.4 GMP 整体一张图</h3>
<img src="https://cdn.jsdelivr.net/gh/nber1994/fu0k@master/uPic/ngqDBf20211124153819.jpg" alt="image-20211124153852657" style="zoom: 25%;" />
<h3 id="45-程序初始化">4.5 程序初始化</h3>
<p>go的启动流程分为4步</p>
<ol>
<li>call osinit， 这里就是设置了全局变量ncpu = cpu核心数量</li>
<li>call schedinit</li>
<li>make &amp; queue new G （runtime.newproc, go func()也是调用这个函数来创建goroutine）</li>
<li>call runtime·mstart</li>
</ol>
<p>和GM模型启动流程没有改变</p>
<img src="https://cdn.jsdelivr.net/gh/nber1994/fu0k@master/uPic/image-2021112415420457120211124154204.png" alt="image-20211124154204571" style="zoom:50%;" />
<h3 id="46-调度器初始化">4.6 调度器初始化</h3>
<img src="https://cdn.jsdelivr.net/gh/nber1994/fu0k@master/uPic/image-2021112415423084420211124154231.png" alt="image-20211124154230844" style="zoom:50%;" />
<p>schedinit这里对当前m进行了初始化，并根据osinit获取到的cpu核数和设置的<code>GOMAXPROCS</code> 确定p的数量，并进行初始化</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#000;font-weight:bold">func</span> <span style="color:#900;font-weight:bold">schedinit</span>() {
    <span style="color:#998;font-style:italic">// 从TLS或者专用寄存器获取当前g的指针类型
</span><span style="color:#998;font-style:italic"></span>    _g_ <span style="color:#000;font-weight:bold">:=</span> <span style="color:#900;font-weight:bold">getg</span>()
    <span style="color:#998;font-style:italic">// 设置m最大的数量
</span><span style="color:#998;font-style:italic"></span>    sched.maxmcount = <span style="color:#099">10000</span>

    <span style="color:#998;font-style:italic">// 初始化栈的复用空间
</span><span style="color:#998;font-style:italic"></span>    <span style="color:#900;font-weight:bold">stackinit</span>()
    <span style="color:#998;font-style:italic">// 初始化当前m
</span><span style="color:#998;font-style:italic"></span>    <span style="color:#900;font-weight:bold">mcommoninit</span>(_g_.m)

    <span style="color:#998;font-style:italic">// osinit的时候会设置 ncpu这个全局变量，这里就是根据cpu核心数和参数GOMAXPROCS来确定p的数量
</span><span style="color:#998;font-style:italic"></span>    procs <span style="color:#000;font-weight:bold">:=</span> ncpu
    <span style="color:#000;font-weight:bold">if</span> n, ok <span style="color:#000;font-weight:bold">:=</span> <span style="color:#900;font-weight:bold">atoi32</span>(<span style="color:#900;font-weight:bold">gogetenv</span>(<span style="color:#d14">&#34;GOMAXPROCS&#34;</span>)); ok <span style="color:#000;font-weight:bold">&amp;&amp;</span> n &gt; <span style="color:#099">0</span> {
        procs = n
    }
    <span style="color:#998;font-style:italic">// 生成设定数量的p
</span><span style="color:#998;font-style:italic"></span>    <span style="color:#000;font-weight:bold">if</span> <span style="color:#900;font-weight:bold">procresize</span>(procs) <span style="color:#000;font-weight:bold">!=</span> <span style="color:#000;font-weight:bold">nil</span> {
        <span style="color:#900;font-weight:bold">throw</span>(<span style="color:#d14">&#34;unknown runnable goroutine during bootstrap&#34;</span>)
    }
}
</code></pre></div><p>procresize函数更改p的数量，多退少补的原则，在初始化过程中，由于最开始是没有p的，所以这里的作用就是初始化设定数量的p了</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#000;font-weight:bold">func</span> <span style="color:#900;font-weight:bold">procresize</span>(nprocs <span style="color:#458;font-weight:bold">int32</span>) <span style="color:#000;font-weight:bold">*</span>p {
    old <span style="color:#000;font-weight:bold">:=</span> gomaxprocs
    <span style="color:#000;font-weight:bold">if</span> old &lt; <span style="color:#099">0</span> <span style="color:#000;font-weight:bold">||</span> nprocs <span style="color:#000;font-weight:bold">&lt;=</span> <span style="color:#099">0</span> {
        <span style="color:#900;font-weight:bold">throw</span>(<span style="color:#d14">&#34;procresize: invalid arg&#34;</span>)
    }
    <span style="color:#998;font-style:italic">// update statistics
</span><span style="color:#998;font-style:italic"></span>    now <span style="color:#000;font-weight:bold">:=</span> <span style="color:#900;font-weight:bold">nanotime</span>()
    <span style="color:#000;font-weight:bold">if</span> sched.procresizetime <span style="color:#000;font-weight:bold">!=</span> <span style="color:#099">0</span> {
        sched.totaltime <span style="color:#000;font-weight:bold">+=</span> <span style="color:#0086b3">int64</span>(old) <span style="color:#000;font-weight:bold">*</span> (now <span style="color:#000;font-weight:bold">-</span> sched.procresizetime)
    }
    sched.procresizetime = now

    <span style="color:#998;font-style:italic">// Grow allp if necessary.
</span><span style="color:#998;font-style:italic"></span>    <span style="color:#998;font-style:italic">// 如果新给的p的数量比原先的p的数量多，则新建增长的p
</span><span style="color:#998;font-style:italic"></span>    <span style="color:#000;font-weight:bold">if</span> nprocs &gt; <span style="color:#0086b3">int32</span>(<span style="color:#0086b3">len</span>(allp)) {
        <span style="color:#998;font-style:italic">// Synchronize with retake, which could be running
</span><span style="color:#998;font-style:italic"></span>        <span style="color:#998;font-style:italic">// concurrently since it doesn&#39;t run on a P.
</span><span style="color:#998;font-style:italic"></span>        <span style="color:#900;font-weight:bold">lock</span>(<span style="color:#000;font-weight:bold">&amp;</span>allpLock)
        <span style="color:#998;font-style:italic">// 判断allp 的cap是否满足增长后的长度，满足就直接使用，不满足，则需要扩张这个slice
</span><span style="color:#998;font-style:italic"></span>        <span style="color:#000;font-weight:bold">if</span> nprocs <span style="color:#000;font-weight:bold">&lt;=</span> <span style="color:#0086b3">int32</span>(<span style="color:#0086b3">cap</span>(allp)) {
            allp = allp[:nprocs]
        } <span style="color:#000;font-weight:bold">else</span> {
            nallp <span style="color:#000;font-weight:bold">:=</span> <span style="color:#0086b3">make</span>([]<span style="color:#000;font-weight:bold">*</span>p, nprocs)
            <span style="color:#998;font-style:italic">// Copy everything up to allp&#39;s cap so we
</span><span style="color:#998;font-style:italic"></span>            <span style="color:#998;font-style:italic">// never lose old allocated Ps.
</span><span style="color:#998;font-style:italic"></span>            <span style="color:#0086b3">copy</span>(nallp, allp[:<span style="color:#0086b3">cap</span>(allp)])
            allp = nallp
        }
        <span style="color:#900;font-weight:bold">unlock</span>(<span style="color:#000;font-weight:bold">&amp;</span>allpLock)
    }

    <span style="color:#998;font-style:italic">// initialize new P&#39;s
</span><span style="color:#998;font-style:italic"></span>    <span style="color:#998;font-style:italic">// 初始化新增的p
</span><span style="color:#998;font-style:italic"></span>    <span style="color:#000;font-weight:bold">for</span> i <span style="color:#000;font-weight:bold">:=</span> <span style="color:#0086b3">int32</span>(<span style="color:#099">0</span>); i &lt; nprocs; i<span style="color:#000;font-weight:bold">++</span> {
        pp <span style="color:#000;font-weight:bold">:=</span> allp[i]
        <span style="color:#000;font-weight:bold">if</span> pp <span style="color:#000;font-weight:bold">==</span> <span style="color:#000;font-weight:bold">nil</span> {
            pp = <span style="color:#0086b3">new</span>(p)
            pp.id = i
            pp.status = _Pgcstop
            pp.sudogcache = pp.sudogbuf[:<span style="color:#099">0</span>]
            <span style="color:#000;font-weight:bold">for</span> i <span style="color:#000;font-weight:bold">:=</span> <span style="color:#000;font-weight:bold">range</span> pp.deferpool {
                pp.deferpool[i] = pp.deferpoolbuf[i][:<span style="color:#099">0</span>]
            }
            pp.wbBuf.<span style="color:#900;font-weight:bold">reset</span>()
            <span style="color:#998;font-style:italic">// allp是一个slice，直接将新增的p放到对应的索引下面就ok了
</span><span style="color:#998;font-style:italic"></span>            <span style="color:#900;font-weight:bold">atomicstorep</span>(unsafe.<span style="color:#900;font-weight:bold">Pointer</span>(<span style="color:#000;font-weight:bold">&amp;</span>allp[i]), unsafe.<span style="color:#900;font-weight:bold">Pointer</span>(pp))
        }
        <span style="color:#000;font-weight:bold">if</span> pp.mcache <span style="color:#000;font-weight:bold">==</span> <span style="color:#000;font-weight:bold">nil</span> {
            <span style="color:#998;font-style:italic">// 初始化时，old=0，第一个新建的p给当前的m使用
</span><span style="color:#998;font-style:italic"></span>            <span style="color:#000;font-weight:bold">if</span> old <span style="color:#000;font-weight:bold">==</span> <span style="color:#099">0</span> <span style="color:#000;font-weight:bold">&amp;&amp;</span> i <span style="color:#000;font-weight:bold">==</span> <span style="color:#099">0</span> {
                <span style="color:#000;font-weight:bold">if</span> <span style="color:#900;font-weight:bold">getg</span>().m.mcache <span style="color:#000;font-weight:bold">==</span> <span style="color:#000;font-weight:bold">nil</span> {
                    <span style="color:#900;font-weight:bold">throw</span>(<span style="color:#d14">&#34;missing mcache?&#34;</span>)
                }
                pp.mcache = <span style="color:#900;font-weight:bold">getg</span>().m.mcache <span style="color:#998;font-style:italic">// bootstrap
</span><span style="color:#998;font-style:italic"></span>            } <span style="color:#000;font-weight:bold">else</span> {
                <span style="color:#998;font-style:italic">// 为p分配内存
</span><span style="color:#998;font-style:italic"></span>                pp.mcache = <span style="color:#900;font-weight:bold">allocmcache</span>()  <span style="color:#998;font-style:italic">//*******为P分配mcache********
</span><span style="color:#998;font-style:italic"></span>            }
        }
    }

    <span style="color:#998;font-style:italic">// free unused P&#39;s
</span><span style="color:#998;font-style:italic"></span>    <span style="color:#998;font-style:italic">// 释放掉多余的p，当新设置的p的数量，比原先设定的p的数量少的时候，会走到这个流程
</span><span style="color:#998;font-style:italic"></span>    <span style="color:#998;font-style:italic">// 通过 runtime.GOMAXPROCS 就可以动态的修改nprocs
</span><span style="color:#998;font-style:italic"></span>    <span style="color:#000;font-weight:bold">for</span> i <span style="color:#000;font-weight:bold">:=</span> nprocs; i &lt; old; i<span style="color:#000;font-weight:bold">++</span> {
        p <span style="color:#000;font-weight:bold">:=</span> allp[i]
        <span style="color:#998;font-style:italic">// move all runnable goroutines to the global queue
</span><span style="color:#998;font-style:italic"></span>        <span style="color:#998;font-style:italic">// 把当前p的运行队列里的g转移到全局的g的队列
</span><span style="color:#998;font-style:italic"></span>        <span style="color:#000;font-weight:bold">for</span> p.runqhead <span style="color:#000;font-weight:bold">!=</span> p.runqtail {
            <span style="color:#998;font-style:italic">// pop from tail of local queue
</span><span style="color:#998;font-style:italic"></span>            p.runqtail<span style="color:#000;font-weight:bold">--</span>
            gp <span style="color:#000;font-weight:bold">:=</span> p.runq[p.runqtail<span style="color:#000;font-weight:bold">%</span><span style="color:#0086b3">uint32</span>(<span style="color:#0086b3">len</span>(p.runq))].<span style="color:#900;font-weight:bold">ptr</span>()
            <span style="color:#998;font-style:italic">// push onto head of global queue
</span><span style="color:#998;font-style:italic"></span>            <span style="color:#900;font-weight:bold">globrunqputhead</span>(gp)
        }
        <span style="color:#998;font-style:italic">// 把runnext里的g也转移到全局队列
</span><span style="color:#998;font-style:italic"></span>        <span style="color:#000;font-weight:bold">if</span> p.runnext <span style="color:#000;font-weight:bold">!=</span> <span style="color:#099">0</span> {
            <span style="color:#900;font-weight:bold">globrunqputhead</span>(p.runnext.<span style="color:#900;font-weight:bold">ptr</span>())
            p.runnext = <span style="color:#099">0</span>
        }
        <span style="color:#998;font-style:italic">// if there&#39;s a background worker, make it runnable and put
</span><span style="color:#998;font-style:italic"></span>        <span style="color:#998;font-style:italic">// it on the global queue so it can clean itself up
</span><span style="color:#998;font-style:italic"></span>        <span style="color:#998;font-style:italic">// 如果有gc worker的话，修改g的状态，然后再把它放到全局队列中
</span><span style="color:#998;font-style:italic"></span>        <span style="color:#000;font-weight:bold">if</span> gp <span style="color:#000;font-weight:bold">:=</span> p.gcBgMarkWorker.<span style="color:#900;font-weight:bold">ptr</span>(); gp <span style="color:#000;font-weight:bold">!=</span> <span style="color:#000;font-weight:bold">nil</span> {
            <span style="color:#900;font-weight:bold">casgstatus</span>(gp, _Gwaiting, _Grunnable)
            <span style="color:#900;font-weight:bold">globrunqput</span>(gp)
            <span style="color:#998;font-style:italic">// This assignment doesn&#39;t race because the
</span><span style="color:#998;font-style:italic"></span>            <span style="color:#998;font-style:italic">// world is stopped.
</span><span style="color:#998;font-style:italic"></span>            p.gcBgMarkWorker.<span style="color:#900;font-weight:bold">set</span>(<span style="color:#000;font-weight:bold">nil</span>)
        }
        <span style="color:#998;font-style:italic">// sudoig的buf和cache，以及deferpool全部清空
</span><span style="color:#998;font-style:italic"></span>        <span style="color:#000;font-weight:bold">for</span> i <span style="color:#000;font-weight:bold">:=</span> <span style="color:#000;font-weight:bold">range</span> p.sudogbuf {
            p.sudogbuf[i] = <span style="color:#000;font-weight:bold">nil</span>
        }
        p.sudogcache = p.sudogbuf[:<span style="color:#099">0</span>]
        <span style="color:#000;font-weight:bold">for</span> i <span style="color:#000;font-weight:bold">:=</span> <span style="color:#000;font-weight:bold">range</span> p.deferpool {
            <span style="color:#000;font-weight:bold">for</span> j <span style="color:#000;font-weight:bold">:=</span> <span style="color:#000;font-weight:bold">range</span> p.deferpoolbuf[i] {
                p.deferpoolbuf[i][j] = <span style="color:#000;font-weight:bold">nil</span>
            }
            p.deferpool[i] = p.deferpoolbuf[i][:<span style="color:#099">0</span>]
        }
        <span style="color:#998;font-style:italic">// 释放掉当前p的mcache
</span><span style="color:#998;font-style:italic"></span>        <span style="color:#900;font-weight:bold">freemcache</span>(p.mcache)
        p.mcache = <span style="color:#000;font-weight:bold">nil</span>
        <span style="color:#998;font-style:italic">// 把当前p的gfree转移到全局
</span><span style="color:#998;font-style:italic"></span>        <span style="color:#900;font-weight:bold">gfpurge</span>(p)
        <span style="color:#998;font-style:italic">// 修改p的状态，让他自生自灭去了
</span><span style="color:#998;font-style:italic"></span>        p.status = _Pdead
        <span style="color:#998;font-style:italic">// can&#39;t free P itself because it can be referenced by an M in syscall
</span><span style="color:#998;font-style:italic"></span>    }

    <span style="color:#998;font-style:italic">// Trim allp.
</span><span style="color:#998;font-style:italic"></span>    <span style="color:#000;font-weight:bold">if</span> <span style="color:#0086b3">int32</span>(<span style="color:#0086b3">len</span>(allp)) <span style="color:#000;font-weight:bold">!=</span> nprocs {
        <span style="color:#900;font-weight:bold">lock</span>(<span style="color:#000;font-weight:bold">&amp;</span>allpLock)
        allp = allp[:nprocs]
        <span style="color:#900;font-weight:bold">unlock</span>(<span style="color:#000;font-weight:bold">&amp;</span>allpLock)
    }
    <span style="color:#998;font-style:italic">// 判断当前g是否有p，有的话更改当前使用的p的状态，继续使用
</span><span style="color:#998;font-style:italic"></span>    _g_ <span style="color:#000;font-weight:bold">:=</span> <span style="color:#900;font-weight:bold">getg</span>()
    <span style="color:#000;font-weight:bold">if</span> _g_.m.p <span style="color:#000;font-weight:bold">!=</span> <span style="color:#099">0</span> <span style="color:#000;font-weight:bold">&amp;&amp;</span> _g_.m.p.<span style="color:#900;font-weight:bold">ptr</span>().id &lt; nprocs {
        <span style="color:#998;font-style:italic">// continue to use the current P
</span><span style="color:#998;font-style:italic"></span>        _g_.m.p.<span style="color:#900;font-weight:bold">ptr</span>().status = _Prunning
    } <span style="color:#000;font-weight:bold">else</span> {
        <span style="color:#998;font-style:italic">// release the current P and acquire allp[0]
</span><span style="color:#998;font-style:italic"></span>        <span style="color:#998;font-style:italic">// 如果当前g有p，但是拥有的是已经释放的p，则不再使用这个p，重新分配
</span><span style="color:#998;font-style:italic"></span>        <span style="color:#000;font-weight:bold">if</span> _g_.m.p <span style="color:#000;font-weight:bold">!=</span> <span style="color:#099">0</span> {
            _g_.m.p.<span style="color:#900;font-weight:bold">ptr</span>().m = <span style="color:#099">0</span>
        }
        <span style="color:#998;font-style:italic">// 分配allp[0]给当前g使用
</span><span style="color:#998;font-style:italic"></span>        _g_.m.p = <span style="color:#099">0</span>
        _g_.m.mcache = <span style="color:#000;font-weight:bold">nil</span>
        p <span style="color:#000;font-weight:bold">:=</span> allp[<span style="color:#099">0</span>]
        p.m = <span style="color:#099">0</span>
        p.status = _Pidle
        <span style="color:#998;font-style:italic">// 将p m g绑定，并把m.mcache指向p.mcache，并修改p的状态为_Prunning
</span><span style="color:#998;font-style:italic"></span>        <span style="color:#900;font-weight:bold">acquirep</span>(p)
    }
    <span style="color:#000;font-weight:bold">var</span> runnablePs <span style="color:#000;font-weight:bold">*</span>p
    <span style="color:#000;font-weight:bold">for</span> i <span style="color:#000;font-weight:bold">:=</span> nprocs <span style="color:#000;font-weight:bold">-</span> <span style="color:#099">1</span>; i <span style="color:#000;font-weight:bold">&gt;=</span> <span style="color:#099">0</span>; i<span style="color:#000;font-weight:bold">--</span> {
        p <span style="color:#000;font-weight:bold">:=</span> allp[i]
        <span style="color:#000;font-weight:bold">if</span> _g_.m.p.<span style="color:#900;font-weight:bold">ptr</span>() <span style="color:#000;font-weight:bold">==</span> p {
            <span style="color:#000;font-weight:bold">continue</span>
        }
        p.status = _Pidle
        <span style="color:#998;font-style:italic">// 根据 runqempty 来判断当前p的g运行队列是否为空
</span><span style="color:#998;font-style:italic"></span>        <span style="color:#000;font-weight:bold">if</span> <span style="color:#900;font-weight:bold">runqempty</span>(p) {
            <span style="color:#998;font-style:italic">// g运行队列为空的p，放到 sched的pidle队列里面
</span><span style="color:#998;font-style:italic"></span>            <span style="color:#900;font-weight:bold">pidleput</span>(p)
        } <span style="color:#000;font-weight:bold">else</span> {
            <span style="color:#998;font-style:italic">// g 运行队列不为空的p，组成一个可运行队列，并最后返回
</span><span style="color:#998;font-style:italic"></span>            p.m.<span style="color:#900;font-weight:bold">set</span>(<span style="color:#900;font-weight:bold">mget</span>())
            p.link.<span style="color:#900;font-weight:bold">set</span>(runnablePs)
            runnablePs = p
        }
    }
    stealOrder.<span style="color:#900;font-weight:bold">reset</span>(<span style="color:#0086b3">uint32</span>(nprocs))
    <span style="color:#000;font-weight:bold">var</span> int32p <span style="color:#000;font-weight:bold">*</span><span style="color:#458;font-weight:bold">int32</span> = <span style="color:#000;font-weight:bold">&amp;</span>gomaxprocs <span style="color:#998;font-style:italic">// make compiler check that gomaxprocs is an int32
</span><span style="color:#998;font-style:italic"></span>    atomic.<span style="color:#900;font-weight:bold">Store</span>((<span style="color:#000;font-weight:bold">*</span><span style="color:#458;font-weight:bold">uint32</span>)(unsafe.<span style="color:#900;font-weight:bold">Pointer</span>(int32p)), <span style="color:#0086b3">uint32</span>(nprocs))
    <span style="color:#000;font-weight:bold">return</span> runnablePs
}
</code></pre></div><p>上面这一步可以看到，为P分配了mcache</p>
<h3 id="47-协程创建">4.7 协程创建</h3>
<img src="https://cdn.jsdelivr.net/gh/nber1994/fu0k@master/uPic/image-2021112415505940820211124155059.png" alt="image-20211124155059408" style="zoom:50%;" />
<p>仍然是调用newproc1函数，和GM模型的区别是，先获取空闲的g复用，之后优先加入p本地运行g队列中，否则放入全局队列中。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#000;font-weight:bold">func</span> <span style="color:#900;font-weight:bold">newproc1</span>(fn <span style="color:#000;font-weight:bold">*</span>funcval, argp <span style="color:#000;font-weight:bold">*</span><span style="color:#458;font-weight:bold">uint8</span>, narg <span style="color:#458;font-weight:bold">int32</span>, callergp <span style="color:#000;font-weight:bold">*</span>g, callerpc <span style="color:#458;font-weight:bold">uintptr</span>) {
    _g_ <span style="color:#000;font-weight:bold">:=</span> <span style="color:#900;font-weight:bold">getg</span>()

    <span style="color:#000;font-weight:bold">if</span> fn <span style="color:#000;font-weight:bold">==</span> <span style="color:#000;font-weight:bold">nil</span> {
        _g_.m.throwing = <span style="color:#000;font-weight:bold">-</span><span style="color:#099">1</span> <span style="color:#998;font-style:italic">// do not dump full stacks
</span><span style="color:#998;font-style:italic"></span>        <span style="color:#900;font-weight:bold">throw</span>(<span style="color:#d14">&#34;go of nil func value&#34;</span>)
    }
    <span style="color:#998;font-style:italic">// 加锁禁止被抢占
</span><span style="color:#998;font-style:italic"></span>    _g_.m.locks<span style="color:#000;font-weight:bold">++</span> <span style="color:#998;font-style:italic">// disable preemption because it can be holding p in a local var
</span><span style="color:#998;font-style:italic"></span>    siz <span style="color:#000;font-weight:bold">:=</span> narg
    siz = (siz <span style="color:#000;font-weight:bold">+</span> <span style="color:#099">7</span>) <span style="color:#000;font-weight:bold">&amp;^</span> <span style="color:#099">7</span>

    <span style="color:#998;font-style:italic">// We could allocate a larger initial stack if necessary.
</span><span style="color:#998;font-style:italic"></span>    <span style="color:#998;font-style:italic">// Not worth it: this is almost always an error.
</span><span style="color:#998;font-style:italic"></span>    <span style="color:#998;font-style:italic">// 4*sizeof(uintreg): extra space added below
</span><span style="color:#998;font-style:italic"></span>    <span style="color:#998;font-style:italic">// sizeof(uintreg): caller&#39;s LR (arm) or return address (x86, in gostartcall).
</span><span style="color:#998;font-style:italic"></span>    <span style="color:#998;font-style:italic">// 如果参数过多，则直接抛出异常，栈大小是2k
</span><span style="color:#998;font-style:italic"></span>    <span style="color:#000;font-weight:bold">if</span> siz <span style="color:#000;font-weight:bold">&gt;=</span> _StackMin<span style="color:#000;font-weight:bold">-</span><span style="color:#099">4</span><span style="color:#000;font-weight:bold">*</span>sys.RegSize<span style="color:#000;font-weight:bold">-</span>sys.RegSize {
        <span style="color:#900;font-weight:bold">throw</span>(<span style="color:#d14">&#34;newproc: function arguments too large for new goroutine&#34;</span>)
    }

    _p_ <span style="color:#000;font-weight:bold">:=</span> _g_.m.p.<span style="color:#900;font-weight:bold">ptr</span>()
    <span style="color:#998;font-style:italic">// 尝试获取一个空闲的g，如果获取不到，则新建一个，并添加到allg里面
</span><span style="color:#998;font-style:italic"></span>    <span style="color:#998;font-style:italic">// gfget首先会尝试从p本地获取空闲的g，如果本地没有的话，则从全局获取一堆平衡到本地p
</span><span style="color:#998;font-style:italic"></span>    newg <span style="color:#000;font-weight:bold">:=</span> <span style="color:#900;font-weight:bold">gfget</span>(_p_)
    <span style="color:#000;font-weight:bold">if</span> newg <span style="color:#000;font-weight:bold">==</span> <span style="color:#000;font-weight:bold">nil</span> {
        newg = <span style="color:#900;font-weight:bold">malg</span>(_StackMin)
        <span style="color:#900;font-weight:bold">casgstatus</span>(newg, _Gidle, _Gdead)
        <span style="color:#998;font-style:italic">// 新建的g，添加到全局的 allg里面，allg是一个slice， append进去即可
</span><span style="color:#998;font-style:italic"></span>        <span style="color:#900;font-weight:bold">allgadd</span>(newg) <span style="color:#998;font-style:italic">// publishes with a g-&gt;status of Gdead so GC scanner doesn&#39;t look at uninitialized stack.
</span><span style="color:#998;font-style:italic"></span>    }
    <span style="color:#998;font-style:italic">// 判断获取的g的栈是否正常
</span><span style="color:#998;font-style:italic"></span>    <span style="color:#000;font-weight:bold">if</span> newg.stack.hi <span style="color:#000;font-weight:bold">==</span> <span style="color:#099">0</span> {
        <span style="color:#900;font-weight:bold">throw</span>(<span style="color:#d14">&#34;newproc1: newg missing stack&#34;</span>)
    }
    <span style="color:#998;font-style:italic">// 判断g的状态是否正常
</span><span style="color:#998;font-style:italic"></span>    <span style="color:#000;font-weight:bold">if</span> <span style="color:#900;font-weight:bold">readgstatus</span>(newg) <span style="color:#000;font-weight:bold">!=</span> _Gdead {
        <span style="color:#900;font-weight:bold">throw</span>(<span style="color:#d14">&#34;newproc1: new g is not Gdead&#34;</span>)
    }
    <span style="color:#998;font-style:italic">// 预留一点空间，防止读取超出一点点
</span><span style="color:#998;font-style:italic"></span>    totalSize <span style="color:#000;font-weight:bold">:=</span> <span style="color:#099">4</span><span style="color:#000;font-weight:bold">*</span>sys.RegSize <span style="color:#000;font-weight:bold">+</span> <span style="color:#0086b3">uintptr</span>(siz) <span style="color:#000;font-weight:bold">+</span> sys.MinFrameSize <span style="color:#998;font-style:italic">// extra space in case of reads slightly beyond frame
</span><span style="color:#998;font-style:italic"></span>    <span style="color:#998;font-style:italic">// 空间大小进行对齐
</span><span style="color:#998;font-style:italic"></span>    totalSize <span style="color:#000;font-weight:bold">+=</span> <span style="color:#000;font-weight:bold">-</span>totalSize <span style="color:#000;font-weight:bold">&amp;</span> (sys.SpAlign <span style="color:#000;font-weight:bold">-</span> <span style="color:#099">1</span>) <span style="color:#998;font-style:italic">// align to spAlign
</span><span style="color:#998;font-style:italic"></span>    sp <span style="color:#000;font-weight:bold">:=</span> newg.stack.hi <span style="color:#000;font-weight:bold">-</span> totalSize
    spArg <span style="color:#000;font-weight:bold">:=</span> sp
    <span style="color:#998;font-style:italic">// usesLr 为0，这里不执行
</span><span style="color:#998;font-style:italic"></span>    <span style="color:#000;font-weight:bold">if</span> usesLR {
        <span style="color:#998;font-style:italic">// caller&#39;s LR
</span><span style="color:#998;font-style:italic"></span>        <span style="color:#000;font-weight:bold">*</span>(<span style="color:#000;font-weight:bold">*</span><span style="color:#458;font-weight:bold">uintptr</span>)(unsafe.<span style="color:#900;font-weight:bold">Pointer</span>(sp)) = <span style="color:#099">0</span>
        <span style="color:#900;font-weight:bold">prepGoExitFrame</span>(sp)
        spArg <span style="color:#000;font-weight:bold">+=</span> sys.MinFrameSize
    }
    <span style="color:#000;font-weight:bold">if</span> narg &gt; <span style="color:#099">0</span> {
        <span style="color:#998;font-style:italic">// 将参数拷贝入栈
</span><span style="color:#998;font-style:italic"></span>        <span style="color:#900;font-weight:bold">memmove</span>(unsafe.<span style="color:#900;font-weight:bold">Pointer</span>(spArg), unsafe.<span style="color:#900;font-weight:bold">Pointer</span>(argp), <span style="color:#0086b3">uintptr</span>(narg))
        <span style="color:#998;font-style:italic">// ... 省略 ...
</span><span style="color:#998;font-style:italic"></span>    }
    <span style="color:#998;font-style:italic">// 初始化用于保存现场的区域及初始化基本状态
</span><span style="color:#998;font-style:italic"></span>    <span style="color:#900;font-weight:bold">memclrNoHeapPointers</span>(unsafe.<span style="color:#900;font-weight:bold">Pointer</span>(<span style="color:#000;font-weight:bold">&amp;</span>newg.sched), unsafe.<span style="color:#900;font-weight:bold">Sizeof</span>(newg.sched))
    newg.sched.sp = sp
    newg.stktopsp = sp
    <span style="color:#998;font-style:italic">// 这里保存了goexit的地址，在用户函数执行完成后，会根据pc来执行goexit
</span><span style="color:#998;font-style:italic"></span>    newg.sched.pc = <span style="color:#900;font-weight:bold">funcPC</span>(goexit) <span style="color:#000;font-weight:bold">+</span> sys.PCQuantum <span style="color:#998;font-style:italic">// +PCQuantum so that previous instruction is in same function
</span><span style="color:#998;font-style:italic"></span>    newg.sched.g = <span style="color:#900;font-weight:bold">guintptr</span>(unsafe.<span style="color:#900;font-weight:bold">Pointer</span>(newg))
    <span style="color:#998;font-style:italic">// 这里调整 sched 信息，pc = goexit的地址
</span><span style="color:#998;font-style:italic"></span>    <span style="color:#900;font-weight:bold">gostartcallfn</span>(<span style="color:#000;font-weight:bold">&amp;</span>newg.sched, fn)
    newg.gopc = callerpc
    newg.ancestors = <span style="color:#900;font-weight:bold">saveAncestors</span>(callergp)
    newg.startpc = fn.fn
    <span style="color:#000;font-weight:bold">if</span> _g_.m.curg <span style="color:#000;font-weight:bold">!=</span> <span style="color:#000;font-weight:bold">nil</span> {
        newg.labels = _g_.m.curg.labels
    }
    <span style="color:#000;font-weight:bold">if</span> <span style="color:#900;font-weight:bold">isSystemGoroutine</span>(newg) {
        atomic.<span style="color:#900;font-weight:bold">Xadd</span>(<span style="color:#000;font-weight:bold">&amp;</span>sched.ngsys, <span style="color:#000;font-weight:bold">+</span><span style="color:#099">1</span>)
    }
    newg.gcscanvalid = <span style="color:#000;font-weight:bold">false</span>
    <span style="color:#900;font-weight:bold">casgstatus</span>(newg, _Gdead, _Grunnable)
    <span style="color:#998;font-style:italic">// 如果p缓存的goid已经用完，本地再从sched批量获取一点
</span><span style="color:#998;font-style:italic"></span>    <span style="color:#000;font-weight:bold">if</span> _p_.goidcache <span style="color:#000;font-weight:bold">==</span> _p_.goidcacheend {
        <span style="color:#998;font-style:italic">// Sched.goidgen is the last allocated id,
</span><span style="color:#998;font-style:italic"></span>        <span style="color:#998;font-style:italic">// this batch must be [sched.goidgen+1, sched.goidgen+GoidCacheBatch].
</span><span style="color:#998;font-style:italic"></span>        <span style="color:#998;font-style:italic">// At startup sched.goidgen=0, so main goroutine receives goid=1.
</span><span style="color:#998;font-style:italic"></span>        _p_.goidcache = atomic.<span style="color:#900;font-weight:bold">Xadd64</span>(<span style="color:#000;font-weight:bold">&amp;</span>sched.goidgen, _GoidCacheBatch)
        _p_.goidcache <span style="color:#000;font-weight:bold">-=</span> _GoidCacheBatch <span style="color:#000;font-weight:bold">-</span> <span style="color:#099">1</span>
        _p_.goidcacheend = _p_.goidcache <span style="color:#000;font-weight:bold">+</span> _GoidCacheBatch
    }
    <span style="color:#998;font-style:italic">// 分配goid
</span><span style="color:#998;font-style:italic"></span>    newg.goid = <span style="color:#0086b3">int64</span>(_p_.goidcache)
    _p_.goidcache<span style="color:#000;font-weight:bold">++</span>
    <span style="color:#998;font-style:italic">// 把新的g放到 p 的可运行g队列中
</span><span style="color:#998;font-style:italic"></span>    <span style="color:#900;font-weight:bold">runqput</span>(_p_, newg, <span style="color:#000;font-weight:bold">true</span>)
    <span style="color:#998;font-style:italic">// 判断是否有空闲p，且是否需要唤醒一个m来执行g
</span><span style="color:#998;font-style:italic"></span>    <span style="color:#000;font-weight:bold">if</span> atomic.<span style="color:#900;font-weight:bold">Load</span>(<span style="color:#000;font-weight:bold">&amp;</span>sched.npidle) <span style="color:#000;font-weight:bold">!=</span> <span style="color:#099">0</span> <span style="color:#000;font-weight:bold">&amp;&amp;</span> atomic.<span style="color:#900;font-weight:bold">Load</span>(<span style="color:#000;font-weight:bold">&amp;</span>sched.nmspinning) <span style="color:#000;font-weight:bold">==</span> <span style="color:#099">0</span> <span style="color:#000;font-weight:bold">&amp;&amp;</span> mainStarted {
        <span style="color:#900;font-weight:bold">wakep</span>()
    }
    _g_.m.locks<span style="color:#000;font-weight:bold">--</span>
    <span style="color:#000;font-weight:bold">if</span> _g_.m.locks <span style="color:#000;font-weight:bold">==</span> <span style="color:#099">0</span> <span style="color:#000;font-weight:bold">&amp;&amp;</span> _g_.preempt { <span style="color:#998;font-style:italic">// restore the preemption request in case we&#39;ve cleared it in newstack
</span><span style="color:#998;font-style:italic"></span>        _g_.stackguard0 = stackPreempt
    }
}
</code></pre></div><p>同样的，仍然给g的callerpc写入goexit()函数的PC</p>
<p><strong>获取空闲g</strong></p>
<img src="https://cdn.jsdelivr.net/gh/nber1994/fu0k@master/uPic/image-2021112415542677020211124155427.png" alt="image-20211124155426770" style="zoom:33%;" />
<p>先从p本地获取空闲g，没有则从全局获取空闲g</p>
<p><strong>将g放入运行队列</strong></p>
<img src="https://cdn.jsdelivr.net/gh/nber1994/fu0k@master/uPic/image-2021112415562545320211124155625.png" alt="image-20211124155625453" style="zoom:50%;" />
<p>先尝试放入本地g队列，如果满了后，就尝试放入全局g队列</p>
<h3 id="48-启动m">4.8 启动M</h3>
<img src="https://cdn.jsdelivr.net/gh/nber1994/fu0k@master/uPic/image-2021112416002379220211124160024.png" alt="image-20211124160023792" style="zoom:50%;" />
<p>整体逻辑从之前的从g全局列表获取g变为了如果入参p!=nil，则为m找一个M（没有则创建），如果p==nil则尝试找到空闲P和M最匹配，并且最后唤醒m</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#000;font-weight:bold">func</span> <span style="color:#900;font-weight:bold">startm</span>(_p_ <span style="color:#000;font-weight:bold">*</span>p, spinning <span style="color:#458;font-weight:bold">bool</span>) {
    <span style="color:#900;font-weight:bold">lock</span>(<span style="color:#000;font-weight:bold">&amp;</span>sched.lock)
    <span style="color:#000;font-weight:bold">if</span> _p_ <span style="color:#000;font-weight:bold">==</span> <span style="color:#000;font-weight:bold">nil</span> {
        <span style="color:#998;font-style:italic">// *********************如果没有指定p, 则从sched.pidle获取空闲的p*************************
</span><span style="color:#998;font-style:italic"></span>        _p_ = <span style="color:#900;font-weight:bold">pidleget</span>()
        <span style="color:#000;font-weight:bold">if</span> _p_ <span style="color:#000;font-weight:bold">==</span> <span style="color:#000;font-weight:bold">nil</span> {
            <span style="color:#900;font-weight:bold">unlock</span>(<span style="color:#000;font-weight:bold">&amp;</span>sched.lock)
            <span style="color:#998;font-style:italic">// 如果没有获取到p，重置nmspinning
</span><span style="color:#998;font-style:italic"></span>            <span style="color:#000;font-weight:bold">if</span> spinning {
                <span style="color:#998;font-style:italic">// The caller incremented nmspinning, but there are no idle Ps,
</span><span style="color:#998;font-style:italic"></span>                <span style="color:#998;font-style:italic">// so it&#39;s okay to just undo the increment and give up.
</span><span style="color:#998;font-style:italic"></span>                <span style="color:#000;font-weight:bold">if</span> <span style="color:#0086b3">int32</span>(atomic.<span style="color:#900;font-weight:bold">Xadd</span>(<span style="color:#000;font-weight:bold">&amp;</span>sched.nmspinning, <span style="color:#000;font-weight:bold">-</span><span style="color:#099">1</span>)) &lt; <span style="color:#099">0</span> {
                    <span style="color:#900;font-weight:bold">throw</span>(<span style="color:#d14">&#34;startm: negative nmspinning&#34;</span>)
                }
            }
            <span style="color:#000;font-weight:bold">return</span>
        }
    }
    <span style="color:#998;font-style:italic">// 首先尝试从 sched.midle获取一个空闲的m
</span><span style="color:#998;font-style:italic"></span>    mp <span style="color:#000;font-weight:bold">:=</span> <span style="color:#900;font-weight:bold">mget</span>()
    <span style="color:#900;font-weight:bold">unlock</span>(<span style="color:#000;font-weight:bold">&amp;</span>sched.lock)
    <span style="color:#000;font-weight:bold">if</span> mp <span style="color:#000;font-weight:bold">==</span> <span style="color:#000;font-weight:bold">nil</span> {
        <span style="color:#998;font-style:italic">// 如果获取不到空闲的m，则创建一个 mspining = true的m，并将p绑定到m上，直接返回
</span><span style="color:#998;font-style:italic"></span>        <span style="color:#000;font-weight:bold">var</span> fn <span style="color:#000;font-weight:bold">func</span>()
        <span style="color:#000;font-weight:bold">if</span> spinning {
            <span style="color:#998;font-style:italic">// The caller incremented nmspinning, so set m.spinning in the new M.
</span><span style="color:#998;font-style:italic"></span>            fn = mspinning
        }
        <span style="color:#900;font-weight:bold">newm</span>(fn, _p_)
        <span style="color:#000;font-weight:bold">return</span>
    }
    <span style="color:#998;font-style:italic">// 判断获取到的空闲m是否是spining状态
</span><span style="color:#998;font-style:italic"></span>    <span style="color:#000;font-weight:bold">if</span> mp.spinning {
        <span style="color:#900;font-weight:bold">throw</span>(<span style="color:#d14">&#34;startm: m is spinning&#34;</span>)
    }
    <span style="color:#998;font-style:italic">// 判断获取到的m是否有p
</span><span style="color:#998;font-style:italic"></span>    <span style="color:#000;font-weight:bold">if</span> mp.nextp <span style="color:#000;font-weight:bold">!=</span> <span style="color:#099">0</span> {
        <span style="color:#900;font-weight:bold">throw</span>(<span style="color:#d14">&#34;startm: m has p&#34;</span>)
    }
    <span style="color:#000;font-weight:bold">if</span> spinning <span style="color:#000;font-weight:bold">&amp;&amp;</span> !<span style="color:#900;font-weight:bold">runqempty</span>(_p_) {
        <span style="color:#900;font-weight:bold">throw</span>(<span style="color:#d14">&#34;startm: p has runnable gs&#34;</span>)
    }
    <span style="color:#998;font-style:italic">// The caller incremented nmspinning, so set m.spinning in the new M.
</span><span style="color:#998;font-style:italic"></span>    <span style="color:#998;font-style:italic">// 调用函数的父函数已经增加了nmspinning， 这里只需要设置m.spining就ok了，同时把p绑上来
</span><span style="color:#998;font-style:italic"></span>    mp.spinning = spinning
    mp.nextp.<span style="color:#900;font-weight:bold">set</span>(_p_)
    <span style="color:#998;font-style:italic">// 唤醒m
</span><span style="color:#998;font-style:italic"></span>    <span style="color:#900;font-weight:bold">notewakeup</span>(<span style="color:#000;font-weight:bold">&amp;</span>mp.park)
}
</code></pre></div><h3 id="49-调度循环">4.9 调度循环</h3>
<img src="https://cdn.jsdelivr.net/gh/nber1994/fu0k@master/uPic/image-2021112416050288820211124160503.png" alt="image-20211124160502888" style="zoom:50%;" />
<p><strong>schedule</strong></p>
<p>首先进行调度次数检测，如果大于某个数，则从全局获取g，然后m在P的资源下执行g</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#000;font-weight:bold">func</span> <span style="color:#900;font-weight:bold">schedule</span>() {
    _g_ <span style="color:#000;font-weight:bold">:=</span> <span style="color:#900;font-weight:bold">getg</span>()

    <span style="color:#000;font-weight:bold">if</span> _g_.m.locks <span style="color:#000;font-weight:bold">!=</span> <span style="color:#099">0</span> {
        <span style="color:#900;font-weight:bold">throw</span>(<span style="color:#d14">&#34;schedule: holding locks&#34;</span>)
    }
    <span style="color:#998;font-style:italic">// 如果有lockg，停止执行当前的m
</span><span style="color:#998;font-style:italic"></span>    <span style="color:#000;font-weight:bold">if</span> _g_.m.lockedg <span style="color:#000;font-weight:bold">!=</span> <span style="color:#099">0</span> {
        <span style="color:#998;font-style:italic">// 解除lockedm的锁定，并执行当前g
</span><span style="color:#998;font-style:italic"></span>        <span style="color:#900;font-weight:bold">stoplockedm</span>()
        <span style="color:#900;font-weight:bold">execute</span>(_g_.m.lockedg.<span style="color:#900;font-weight:bold">ptr</span>(), <span style="color:#000;font-weight:bold">false</span>) <span style="color:#998;font-style:italic">// Never returns.
</span><span style="color:#998;font-style:italic"></span>    }

    <span style="color:#998;font-style:italic">// We should not schedule away from a g that is executing a cgo call,
</span><span style="color:#998;font-style:italic"></span>    <span style="color:#998;font-style:italic">// since the cgo call is using the m&#39;s g0 stack.
</span><span style="color:#998;font-style:italic"></span>    <span style="color:#000;font-weight:bold">if</span> _g_.m.incgo {
        <span style="color:#900;font-weight:bold">throw</span>(<span style="color:#d14">&#34;schedule: in cgo&#34;</span>)
    }

top:
    <span style="color:#998;font-style:italic">// gc 等待
</span><span style="color:#998;font-style:italic"></span>    <span style="color:#000;font-weight:bold">if</span> sched.gcwaiting <span style="color:#000;font-weight:bold">!=</span> <span style="color:#099">0</span> {
        <span style="color:#900;font-weight:bold">gcstopm</span>()
        <span style="color:#000;font-weight:bold">goto</span> top
    }

    <span style="color:#000;font-weight:bold">var</span> gp <span style="color:#000;font-weight:bold">*</span>g
    <span style="color:#000;font-weight:bold">var</span> inheritTime <span style="color:#458;font-weight:bold">bool</span>

    <span style="color:#000;font-weight:bold">if</span> gp <span style="color:#000;font-weight:bold">==</span> <span style="color:#000;font-weight:bold">nil</span> {
        <span style="color:#998;font-style:italic">// Check the global runnable queue once in a while to ensure fairness.
</span><span style="color:#998;font-style:italic"></span>        <span style="color:#998;font-style:italic">// Otherwise two goroutines can completely occupy the local runqueue
</span><span style="color:#998;font-style:italic"></span>        <span style="color:#998;font-style:italic">// by constantly respawning each other.
</span><span style="color:#998;font-style:italic"></span>        <span style="color:#998;font-style:italic">// 为了保证公平，每隔61次，从全局队列上获取g
</span><span style="color:#998;font-style:italic"></span>        <span style="color:#000;font-weight:bold">if</span> _g_.m.p.<span style="color:#900;font-weight:bold">ptr</span>().schedtick<span style="color:#000;font-weight:bold">%</span><span style="color:#099">61</span> <span style="color:#000;font-weight:bold">==</span> <span style="color:#099">0</span> <span style="color:#000;font-weight:bold">&amp;&amp;</span> sched.runqsize &gt; <span style="color:#099">0</span> {
            <span style="color:#900;font-weight:bold">lock</span>(<span style="color:#000;font-weight:bold">&amp;</span>sched.lock)
            gp = <span style="color:#900;font-weight:bold">globrunqget</span>(_g_.m.p.<span style="color:#900;font-weight:bold">ptr</span>(), <span style="color:#099">1</span>)
            <span style="color:#900;font-weight:bold">unlock</span>(<span style="color:#000;font-weight:bold">&amp;</span>sched.lock)
        }
    }
    <span style="color:#000;font-weight:bold">if</span> gp <span style="color:#000;font-weight:bold">==</span> <span style="color:#000;font-weight:bold">nil</span> {
        <span style="color:#998;font-style:italic">// 全局队列上获取不到待运行的g，则从p local队列中获取
</span><span style="color:#998;font-style:italic"></span>        gp, inheritTime = <span style="color:#900;font-weight:bold">runqget</span>(_g_.m.p.<span style="color:#900;font-weight:bold">ptr</span>())
        <span style="color:#000;font-weight:bold">if</span> gp <span style="color:#000;font-weight:bold">!=</span> <span style="color:#000;font-weight:bold">nil</span> <span style="color:#000;font-weight:bold">&amp;&amp;</span> _g_.m.spinning {
            <span style="color:#900;font-weight:bold">throw</span>(<span style="color:#d14">&#34;schedule: spinning with local work&#34;</span>)
        }
    }
    <span style="color:#000;font-weight:bold">if</span> gp <span style="color:#000;font-weight:bold">==</span> <span style="color:#000;font-weight:bold">nil</span> {
        <span style="color:#998;font-style:italic">// 如果p local获取不到待运行g，则开始查找，这个函数会从 全局 io poll， p locl和其他p local获取待运行的g，后面详细分析
</span><span style="color:#998;font-style:italic"></span>        gp, inheritTime = <span style="color:#900;font-weight:bold">findrunnable</span>() <span style="color:#998;font-style:italic">// blocks until work is available
</span><span style="color:#998;font-style:italic"></span>    }

    <span style="color:#998;font-style:italic">// This thread is going to run a goroutine and is not spinning anymore,
</span><span style="color:#998;font-style:italic"></span>    <span style="color:#998;font-style:italic">// so if it was marked as spinning we need to reset it now and potentially
</span><span style="color:#998;font-style:italic"></span>    <span style="color:#998;font-style:italic">// start a new spinning M.
</span><span style="color:#998;font-style:italic"></span>    <span style="color:#000;font-weight:bold">if</span> _g_.m.spinning {
        <span style="color:#998;font-style:italic">// 如果m是自旋状态，取消自旋
</span><span style="color:#998;font-style:italic"></span>        <span style="color:#900;font-weight:bold">resetspinning</span>()
    }

    <span style="color:#000;font-weight:bold">if</span> gp.lockedm <span style="color:#000;font-weight:bold">!=</span> <span style="color:#099">0</span> {
        <span style="color:#998;font-style:italic">// Hands off own p to the locked m,
</span><span style="color:#998;font-style:italic"></span>        <span style="color:#998;font-style:italic">// then blocks waiting for a new p.
</span><span style="color:#998;font-style:italic"></span>        <span style="color:#998;font-style:italic">// 如果g有lockedm，则休眠上交p，休眠m，等待新的m，唤醒后从这里开始执行，跳转到top
</span><span style="color:#998;font-style:italic"></span>        <span style="color:#900;font-weight:bold">startlockedm</span>(gp)
        <span style="color:#000;font-weight:bold">goto</span> top
    }
    <span style="color:#998;font-style:italic">// 开始执行这个g
</span><span style="color:#998;font-style:italic"></span>    <span style="color:#900;font-weight:bold">execute</span>(gp, inheritTime)
}
</code></pre></div><p>最后，仍然是gogo函数执行g的用户代码，同时伪造了call指令的栈帧，将goexit()函数写入了SP上，ret指令结束后会跳转到goexit()函数继续执行</p>
<p><strong>goexit()</strong></p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#000;font-weight:bold">func</span> <span style="color:#900;font-weight:bold">goexit0</span>(gp <span style="color:#000;font-weight:bold">*</span>g) {
    _g_ <span style="color:#000;font-weight:bold">:=</span> <span style="color:#900;font-weight:bold">getg</span>()
    <span style="color:#998;font-style:italic">// 转换g的状态为dead，以放回空闲列表
</span><span style="color:#998;font-style:italic"></span>    <span style="color:#900;font-weight:bold">casgstatus</span>(gp, _Grunning, _Gdead)
    <span style="color:#000;font-weight:bold">if</span> <span style="color:#900;font-weight:bold">isSystemGoroutine</span>(gp) {
        atomic.<span style="color:#900;font-weight:bold">Xadd</span>(<span style="color:#000;font-weight:bold">&amp;</span>sched.ngsys, <span style="color:#000;font-weight:bold">-</span><span style="color:#099">1</span>)
    }
    <span style="color:#998;font-style:italic">// 清空g的状态
</span><span style="color:#998;font-style:italic"></span>    gp.m = <span style="color:#000;font-weight:bold">nil</span>
    locked <span style="color:#000;font-weight:bold">:=</span> gp.lockedm <span style="color:#000;font-weight:bold">!=</span> <span style="color:#099">0</span>
    gp.lockedm = <span style="color:#099">0</span>
    _g_.m.lockedg = <span style="color:#099">0</span>
    gp.paniconfault = <span style="color:#000;font-weight:bold">false</span>
    gp._defer = <span style="color:#000;font-weight:bold">nil</span> <span style="color:#998;font-style:italic">// should be true already but just in case.
</span><span style="color:#998;font-style:italic"></span>    gp._panic = <span style="color:#000;font-weight:bold">nil</span> <span style="color:#998;font-style:italic">// non-nil for Goexit during panic. points at stack-allocated data.
</span><span style="color:#998;font-style:italic"></span>    gp.writebuf = <span style="color:#000;font-weight:bold">nil</span>
    gp.waitreason = <span style="color:#099">0</span>
    gp.param = <span style="color:#000;font-weight:bold">nil</span>
    gp.labels = <span style="color:#000;font-weight:bold">nil</span>
    gp.timer = <span style="color:#000;font-weight:bold">nil</span>

    <span style="color:#998;font-style:italic">// Note that gp&#39;s stack scan is now &#34;valid&#34; because it has no
</span><span style="color:#998;font-style:italic"></span>    <span style="color:#998;font-style:italic">// stack.
</span><span style="color:#998;font-style:italic"></span>    gp.gcscanvalid = <span style="color:#000;font-weight:bold">true</span>
    <span style="color:#900;font-weight:bold">dropg</span>()

    <span style="color:#998;font-style:italic">// 把g放回空闲列表，以备复用
</span><span style="color:#998;font-style:italic"></span>    <span style="color:#900;font-weight:bold">gfput</span>(_g_.m.p.<span style="color:#900;font-weight:bold">ptr</span>(), gp)
    <span style="color:#998;font-style:italic">// 再次进入调度循环
</span><span style="color:#998;font-style:italic"></span>    <span style="color:#900;font-weight:bold">schedule</span>()
}
</code></pre></div><p>最后调用schedule函数开始下一轮调用。</p>
<img src="https://cdn.jsdelivr.net/gh/nber1994/fu0k@master/uPic/image-2021112416291048520211124162911.png" alt="image-20211124162910485" style="zoom:50%;" />
<p>剩下的自己去看吧，我累了</p>
<h2 id="五非均匀存储访问调度器--提案">五、非均匀存储访问调度器 · 提案</h2>
<p>这个有兴趣自己研究吧</p>
<h1 id="参考资料">参考资料</h1>
<ul>
<li><a href="https://segmentfault.com/a/1190000020254937#item-3-3">这个GMP源码讲的比较清楚</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/404698231?utm_source=wechat_session&amp;utm_medium=social&amp;utm_oi=1034005455210786816">go scheduler这十年发展历程</a></li>
<li><a href="https://segmentfault.com/a/1190000040364177">图解协程调度模型-GMP模型</a></li>
<li><a href="https://learnku.com/articles/41728">GMP各种场景分析</a></li>
<li><a href="https://qcrao.com/ishare/go-scheduler/#true%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB">这哥们的文档大而全</a></li>
<li><a href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-goroutine/#p">这哥们马上出书了，从发展到代码都有涉及</a></li>
<li><a href="https://lessisbetter.site/2019/03/10/golang-scheduler-1-history/">大斌这哥们的系列文章-除了源码其他讲的非常清楚</a></li>
<li><a href="https://eddycjy.com/posts/go/go-tips-gmp-p/">GMP为什么有P-煎鱼</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1819618">GMP和GM动态图</a></li>
<li><a href="https://segmentfault.com/a/1190000016038785">很火的scheduler英文文档翻译</a></li>
</ul>

        </div>
        </br>
        <hr>
</main>
<aside>
	<div>
		<div>
			<h1>LATEST POSTS</h1>
		</div>
		<div id='common-a'>
			<ul>
				
                <div id="lists">
                    <div id=date class="date-time-title">
                        <time>2022-02-17</time>
                    </div>
                    <div class="date-time-title post">
                        <a href="http://nber1994.github.io/posts/channel-select/">golang channel浅析</a>
                    </div>
                </div>
				
                <div id="lists">
                    <div id=date class="date-time-title">
                        <time>2022-02-09</time>
                    </div>
                    <div class="date-time-title post">
                        <a href="http://nber1994.github.io/posts/golang-race%E6%A3%80%E6%B5%8B/">golang-race检测</a>
                    </div>
                </div>
				
                <div id="lists">
                    <div id=date class="date-time-title">
                        <time>2022-02-09</time>
                    </div>
                    <div class="date-time-title post">
                        <a href="http://nber1994.github.io/posts/golang-%E4%BF%A1%E5%8F%B7%E9%87%8F/">golang-信号量</a>
                    </div>
                </div>
				
                <div id="lists">
                    <div id=date class="date-time-title">
                        <time>2022-02-09</time>
                    </div>
                    <div class="date-time-title post">
                        <a href="http://nber1994.github.io/posts/golang%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB/">golang知识汇总</a>
                    </div>
                </div>
				
                <div id="lists">
                    <div id=date class="date-time-title">
                        <time>2022-01-15</time>
                    </div>
                    <div class="date-time-title post">
                        <a href="http://nber1994.github.io/posts/golang%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%E7%9A%84%E5%AE%9E%E7%8E%B0/">golang同步机制的实现</a>
                    </div>
                </div>
				
			</ul>
		</div>
	</div>
</aside>


	<footer>
    <div id='footer'>
	<p>&copy; 2022 <a href="http://nber1994.github.io/"><b>jingtianyou&#39;s blog</b></a>.
	</p>
    </div>
</footer>

</body>
</html>
