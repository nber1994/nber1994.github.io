<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">

        <link href="https://fonts.googleapis.com/css?family=Ubuntu" rel="stylesheet">

        <title>mysql-事务</title>

        <link rel="stylesheet" href="/css/stylesheet.css">


        <style type="text/css">
*{margin: 0; padding: 0;}
.clearfix:after {
    clear: both;
    content: ".";
    display: block;
    height: 0;
    visibility: hidden;
}
      .wrap {
           
          text-align: left;
      }
      .wrap span{
          display: inline-block;
          vertical-align: middle;
          word-break:break-word; 
          width: 50em;
      }
      .wrap img{
          width: 4.5em;
          height: auto;
          vertical-align: middle;
      }

      .wrap p{
          font-style:italic;
          font-size:12px;
      }

        </style>

    </head>
    <body>
        <section id="page-title">
            <h1>
                <a href="/">nber1994</a> </h1>
            <br>
            <div class="wrap">
                <script type="text/javascript">
                    

                    function chunkSubstr(str, size) {
                                            const numChunks = Math.ceil(str.length / size)
                                            const chunks = new Array(numChunks)

                                            for (let i = 0, o = 0; i < numChunks; ++i, o += size) {
                                                                    chunks[i] = str.substr(o, size)
                                                                }

                                            return chunks
                                        }
                    var pic = [];
                    pic[0] = "https://cdn.jsdelivr.net/gh/nber1994/fu0k@master/uPic/qRKvRQ20220116152554.jpg";
                    pic[1] = "https://cdn.jsdelivr.net/gh/nber1994/fu0k@master/uPic/nEf3GW20220116150946.jpg";
                    pic[2] = "https://cdn.jsdelivr.net/gh/nber1994/fu0k@master/uPic/ITL6SB20220116154359.jpg";
                    pic[3] = "https://cdn.jsdelivr.net/gh/nber1994/fu0k@master/uPic/3QAQ7M20220116154758.jpg";
                    pic[4] = "https://cdn.jsdelivr.net/gh/nber1994/fu0k@master/uPic/HCCsx620220116160636.jpg";
                    pic[5] = "https://cdn.jsdelivr.net/gh/nber1994/fu0k@master/uPic/c4zSPk20220116161109.jpg";
                    pic[6] = "https://cdn.jsdelivr.net/gh/nber1994/fu0k@master/uPic/Bm5IHA20220116161518.jpg";
                    pic[7] = "https://cdn.jsdelivr.net/gh/nber1994/fu0k@master/uPic/lpcstW20220116161917.jpg";
                    pic[8] = "https://cdn.jsdelivr.net/gh/nber1994/fu0k@master/uPic/MSCA4K20220116162440.jpg";

                    var talk = [];
                    talk[0] = "Help poor children in Uganda!";
                    talk[1] = "Bad programmers worry about the code. Good programmers worry about data structures and their relationships.";
                    talk[2] = "So, dear Redis community, today I’m stepping back as the Redis maintainer.";
                    talk[3] = "Don't tune for speed until you've measured.";
                    talk[4] = "C is quirky, flawed, and an enormous success.";
                    talk[5] = "I've never thought of PHP as more than a simple tool to solve problems.";
                    talk[6] = "Java is C++ without the guns, clubs and knives.";
                    talk[7] = "Life is short, you need Python!";
                    talk[8] = "C makes it easy to shoot yourself in the foot; C++ makes it harder, but when you do it blows your whole leg off.";

                    var randomBgIndex = Math.floor( Math.random() * 8 );

                    
                    document.write("<img src=" + pic[randomBgIndex] + ">")
                    document.write("<span style='font-size:12px'>" + talk[randomBgIndex] + " </span>")
                    
                </script>
            </div>


        </section>
        <br>



<section class="blog-post">
    <h1>mysql-事务</h1>
    <div class="blog-post-subheader">
        August 9, 2019
    </div>
    <div class="blog-post-content">
        <h2 id="事务概述">事务概述</h2>
<blockquote>
<p>Innodb中的事务隔离级别和锁的关系 <a href="https://tech.meituan.com/innodb_lock.html">https://tech.meituan.com/innodb_lock.html</a></p>
</blockquote>
<ul>
<li>A：原子性
一个事件中的几个步骤，要么不做，要么都做</li>
<li>C：一致性
事务将数据库从一个状态转化为另一个一致性状态，例如外键约束没有遭到破坏
一致性关注的是数据，用户只对事务开始前的数据和事务结束后的数据可见，中间状态的数据对用户是不可见的</li>
<li>I：隔离性
隔离性也叫做并发控制，可串行化，锁等。总的来说就是事务提交之前对其他事务是不可见的
隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。</li>
<li>D：持久性
事务一旦提交，则其结果就是永久性的
持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。</li>
</ul>
<h2 id="事务的实现">事务的实现</h2>
<p>redo log 用来保证事务的持久性<br>
undo log用来保证事务的一致性</p>
<p>redo log 和undo log并不是互为逆过程<br>
redo log记录的是页的改动<br>
undo log记录的是行的改动</p>
<h2 id="redo-log">redo log</h2>
<p>分为两种，一种是redo缓冲区中的redo log，其是易失的 <br>
另一种是redo日志文件，是持久的</p>
<h3 id="redo-log作用">redo log作用</h3>
<p>innodb是事务型存储引擎，通过force log at commit机制实现事务的持久化，即在事务提交之前将所有日志写入到日志文件中 <br>
redo log基本上是顺序写的，而且只有在redo log日志写入之后，调用fsync命令。所以磁盘的性能决定了sync的性能，进而决定了事务的性能<br>
在innodb中，该日志包含两部分，redo log和undo log，redo log来实现事务的持久性，undo log来实现事务的回滚和mvcc机制</p>
<h3 id="binlog与redo-log区别">binlog与redo log区别</h3>
<ul>
<li>层次不同 binlog是记录的mysql行为的，而redo log只是innodb中的</li>
<li>日志内容不同，binlog记录的是逻辑日志，记录的内容是sql，而redo log记录的是页面的变动</li>
<li>写入时机不同，binlog是在事务提交只有写入，redolog在事务中就写入</li>
</ul>
<h3 id="redolog恢复">redolog恢复</h3>
<p>当mysql启动时，不论上次关闭是否正常，都会重做redolog，将页面改动做回磁盘，根据checkpoint表示的LSN，重做之后的redolog</p>
<h2 id="undo-log">undo log</h2>
<p>undolog用于事物的回滚，将数据改动为事务之前的状态
与redolog不同的是，undolog是存在于共享表空间的undo段</p>
<h3 id="误解">误解</h3>
<p>undolog是逻辑日志，只记录变化量</p>
<h3 id="undolog作业">undolog作业</h3>
<p>一个是进行事务的回滚 <br>
另一个是实现mvcc <br>
当一个事务读取一行信息，如果发现正在被某一事务占用，则会根据undolog读取到之前版本的信息 <br>
同时undolog也会导致redolog的产生，因为undolog也需要持久化保护</p>
<h2 id="事务隔离级别">事务隔离级别</h2>
<blockquote>
<p>事务的四个隔离级别</p>
</blockquote>
<ul>
<li>read uncommitted</li>
<li>read commited</li>
<li>repeatble read</li>
<li>serializable
<img src="https://cdn.jsdelivr.net/gh/nber1994/fu0k@master/uPic/20181108214404214_256950961.png" alt=""></li>
</ul>
<p>innodb支持的隔离级别是repeatable read，但是innodb通过next-key lock解决了幻读的问题 <br>
所以innodb已经完全实现了事务的ACID，实现了serializeble</p>
<h3 id="read-commited">read commited</h3>
<p>所有的读取都是不加锁的，数据写入，修改删除是加锁的</p>
<h3 id="repeatable-read">repeatable read</h3>
<h4 id="不可重复读幻读">不可重复读&amp;幻读</h4>
<p>对于这两个概念，其实是有一定区别的，不可重复读是对于修改和删除来说的，而幻读是对于inser来说的。 <br>
sql第一次读取某行之后，将改行记录加锁，阻止其他事务读取，即可实现可重复读，但是此时如果有insert操作， <br>
是无法阻止的，还是会出现幻读的现象，这种情况下只能使用悲观锁，读加上读锁，写加上写锁，读写互斥，这样可以避免 <br>
脏读，不可重复读，幻读的问题，这种方法会导致并发性能降低，而innodb采用了mvcc机制避免了幻读的问题
<img src="https://cdn.jsdelivr.net/gh/nber1994/fu0k@master/uPic/20181108215740807_2132671057.png" alt=""></p>
<h4 id="mvcc的实现">mvcc的实现</h4>
<p>innodb会为每条记录增加一个版本信息，对应的是事务的版本号，每开启一个事务，事务的版本号就会递增 <br>
在MVCC中，</p>
<ul>
<li>select 读取的是&lt;=当前事务号的数据。</li>
<li>insert 保存当前事务版本号为当前插入数据版本号</li>
<li>delete 保存当前事务版本号为行的删除版本号</li>
<li>update 新插入一条记录，保存当前事务版本号为行创建版本号，同时将原来的版本号保存到原来的行
<img src="https://cdn.jsdelivr.net/gh/nber1994/fu0k@master/uPic/20181108220727145_152902922.png" alt=""></li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/nber1994/fu0k@master/uPic/20181108221515967_1448968242.png" alt=""></p>
<h3 id="快照度和当前度">快照度和当前度</h3>
<p>快照度读取的是历史的数据 <br>
当前度读取的是当前最新版本的数据</p>
<ol>
<li>
<p>在mvcc中，快照读就是</p>
<ul>
<li>select * from table_t where &hellip;</li>
</ul>
</li>
<li>
<p>当前读</p>
<ul>
<li>select ？ from table_t for update</li>
<li>select ？ from table_t lock in share mode</li>
<li>insert</li>
<li>update</li>
<li>delete
<strong>当前读其实是对于写操作来说的，当前读会存在幻读的问题，所以innodb引入了next-key锁来解决这个问题</strong>
<img src="https://cdn.jsdelivr.net/gh/nber1994/fu0k@master/uPic/20181108222755951_1379483439.png" alt=""></li>
</ul>
</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/nber1994/fu0k@master/uPic/20181108222812780_744706261.png" alt=""></p>
<blockquote>
<p>在mysql中，此时其实会在（5，30】上加next-key锁，从而阻止了事务B的插入操作，另外innodb其实会在(30 ， -∞)<br>
上也加上gap锁，使其他事务无法在这两个区间插入操作，受限于这种方式，innodb会锁住不需要的区间</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/nber1994/fu0k@master/uPic/20181108223515915_743433911.png" alt=""></p>
<p>对于update操作，如果where没有命中索引，则会在全表上加上gap锁，此时所有的操作都会被阻塞 <br>
行锁防止别的事务修改或删除，GAP锁防止别的事务新增，行锁和GAP锁结合形成的的Next-Key锁共同解决了RR级别在写数据时的幻读问题。</p>

    </div>
</section>

</body>
<br>
    <div class="wrap">
        <script type="text/javascript">
            
            var pic = [];
            pic[0] = "https://cdn.jsdelivr.net/gh/nber1994/fu0k@master/uPic/m731jF20220117115554.png";
            pic[1] = "https://cdn.jsdelivr.net/gh/nber1994/fu0k@master/uPic/m731jF20220117115554.png";
            pic[2] = "https://cdn.jsdelivr.net/gh/nber1994/fu0k@master/uPic/m731jF20220117115554.png";
            pic[3] = "https://cdn.jsdelivr.net/gh/nber1994/fu0k@master/uPic/m731jF20220117115554.png";

            var talk = [];
            talk[0] = "mail : jingherego@gmail.com";
            talk[1] = "github : github.com/nber1994";
            talk[2] = "本站内容部分来源于网络，可转载.";
            talk[3] = "如有错误，请联系我";

            var randomBgIndex = Math.floor( Math.random() * 4 );

            
            
            document.write("<img src=" + pic[randomBgIndex] + " width='400'>")
            document.write("<span style='font-size:12px;'><p>" + talk[randomBgIndex] + " </p></span>")
            
        </script>
    </div>


</html>
