<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">

        <link href="https://fonts.googleapis.com/css?family=Ubuntu" rel="stylesheet">

        <title>php高级用法</title>

        <link rel="stylesheet" href="/css/stylesheet.css">
    </head>
    <body>
        <section id="page-title">
            <h1><a href="/">nber1994</a></h1>
        </section>



<section class="blog-post">
    <h1>php高级用法</h1>
    <div class="blog-post-subheader">
        October 12, 2017
    </div>
    <div class="blog-post-content">
        <blockquote>
<p>胡乱探讨了包括autoload，异常处理，多进程，反射使用，trait代码复用，生成器等php语言的高级特性</p>
</blockquote>
<h1 id="1autoload自动加载">1.autoload自动加载</h1>
<ul>
<li>spl_autoload_register() 函数可以注册任意数量的自动加载器，当使用尚未被定义的类（class）和接口（interface）时自动去加载。通过注册自动加载器，脚本引擎在 php 出错失败前有了最后一个机会加载所需的类</li>
<li>尽管 __autoload() 函数也能自动加载类和接口，但更建议使用 spl_autoload_register() 函数。 spl_autoload_register() 提供了一种更加灵活的方式来实现类的自动加载（同一个应用中，可以支持任意数量的加载器，比如第三方库中的）。因此，不再建议使用 __autoload() 函数，在以后的版本中它可能被弃用。</li>
<li>自动加载不可用于 php 的 CLI 交互模式</li>
</ul>
<h2 id="自动加载简单实例">自动加载简单实例</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-php" data-lang="php"><span style="color:#f92672">&lt;?</span><span style="color:#a6e22e">php</span>
    <span style="color:#a6e22e">spl_autoload_register</span>(<span style="color:#66d9ef">function</span> ($class_name) {
        <span style="color:#66d9ef">require_once</span> $class_name <span style="color:#f92672">.</span> <span style="color:#e6db74">&#39;.php&#39;</span>;
    });
    
    $obj  <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">MyClass1</span>();
    $obj2 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">MyClass2</span>();
<span style="color:#75715e">?&gt;</span><span style="color:#960050;background-color:#1e0010">
</span></code></pre></div><h2 id="自动加载抛出异常">自动加载抛出异常</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-php" data-lang="php"><span style="color:#f92672">&lt;?</span><span style="color:#a6e22e">php</span>
    <span style="color:#a6e22e">spl_autoload_register</span>(<span style="color:#66d9ef">function</span> ($name) {
        <span style="color:#66d9ef">echo</span> <span style="color:#e6db74">&#34;Want to load </span><span style="color:#e6db74">$name</span><span style="color:#e6db74">.</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
        <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">Exception</span>(<span style="color:#e6db74">&#34;Unable to load </span><span style="color:#e6db74">$name</span><span style="color:#e6db74">.&#34;</span>);
    });
    
    <span style="color:#66d9ef">try</span> {
        $obj <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">NonLoadableClass</span>();
    } <span style="color:#66d9ef">catch</span> (<span style="color:#a6e22e">Exception</span> $e) {
        <span style="color:#66d9ef">echo</span> $e<span style="color:#f92672">-&gt;</span><span style="color:#a6e22e">getMessage</span>(), <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
    }
<span style="color:#75715e">?&gt;</span><span style="color:#960050;background-color:#1e0010">
</span></code></pre></div><h2 id="spl_autoload_register">spl_autoload_register</h2>
<ul>
<li>
<p>将函数注册到SPL __autoload函数队列中。如果该队列中的函数尚未激活，则激活它们。</p>
</li>
<li>
<p>如果在你的程序中已经实现了__autoload()函数，它必须显式注册到__autoload()队列中。因为 spl_autoload_register()函数会将Zend Engine中的__autoload()函数取代为spl_autoload()或spl_autoload_call()。</p>
</li>
<li>
<p>如果需要多条 autoload 函数，spl_autoload_register() 满足了此类需求。 它实际上创建了 autoload 函数的队列，按定义时的顺序逐个执行。相比之下， __autoload() 只可以定义一次。</p>
</li>
<li>
<p>参数：autoload_function /*欲注册的自动装载函数。如果没有提供任何参数，则自动注册 autoload 的默认实现函数spl_autoload()。</p>
</li>
<li>
<p>参数：throw /*此参数设置了 autoload_function 无法成功注册时， spl_autoload_register()是否抛出异常。</p>
</li>
<li>
<p>参数：prepend /*如果是 true，spl_autoload_register() 会添加函数到队列之首，而不是队列尾部。</p>
</li>
</ul>
<h2 id="composer的自动加载流程">composer的自动加载流程</h2>
<ul>
<li>index.php文件
在config/loader.php文件中会引入vendor.php文件</li>
<li>autoloader.php文件
1.会引入autoload_real.php文件
2.会返回一个自动加载器</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-php" data-lang="php">    <span style="color:#f92672">&lt;?</span><span style="color:#a6e22e">php</span>
        <span style="color:#75715e">// autoload.php @generated by Composer
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">require_once</span> <span style="color:#66d9ef">__DIR__</span> <span style="color:#f92672">.</span> <span style="color:#e6db74">&#39;/composer&#39;</span> <span style="color:#f92672">.</span> <span style="color:#e6db74">&#39;/autoload_real.php&#39;</span>; <span style="color:#75715e">//会返回一个加载类
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">ComposerAutoloaderInite572cdf763ad8e4d6770ce15b9328edb</span><span style="color:#f92672">::</span><span style="color:#a6e22e">getLoader</span>(); 
</code></pre></div><ul>
<li>autoload_real.php文件</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-php" data-lang="php"><span style="color:#f92672">&lt;?</span><span style="color:#a6e22e">php</span>

    <span style="color:#75715e">// autoload_real.php @generated by Composer
</span><span style="color:#75715e"></span>    
    <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ComposerAutoloaderInit85b4dbf6b714d62ec745fcf3dd1a5041</span>
    {
        <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> $loader;
    
        <span style="color:#75715e">// 在实例化ClassLoader时调用该函数
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">loadClassLoader</span>($class)
        {   
        <span style="color:#75715e">// 该函数在getLoader方法里被注册为__autoload的实现，在实例化类时，如果类不存在，会自动调用该方法
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// 如果实例化的函数是Composer\Autoload\ClassLoader 则引入该类
</span><span style="color:#75715e"></span>    
            <span style="color:#66d9ef">if</span> (<span style="color:#e6db74">&#39;Composer\Autoload\ClassLoader&#39;</span> <span style="color:#f92672">===</span> $class) {
    
                <span style="color:#66d9ef">require</span> <span style="color:#66d9ef">__DIR__</span> <span style="color:#f92672">.</span> <span style="color:#e6db74">&#39;/ClassLoader.php&#39;</span>;
            }
        }
    
        <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">getLoader</span>()
        {
            <span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">null</span> <span style="color:#f92672">!==</span> <span style="color:#a6e22e">self</span><span style="color:#f92672">::</span>$loader) {
                <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">self</span><span style="color:#f92672">::</span>$loader;
            }
    
            <span style="color:#75715e">// 注册 loadClassLoader函数作为 __autoload 的实现   
</span><span style="color:#75715e"></span>            <span style="color:#a6e22e">spl_autoload_register</span>(<span style="color:#66d9ef">array</span>(<span style="color:#e6db74">&#39;ComposerAutoloaderInit85b4dbf6b714d62ec745fcf3dd1a5041&#39;</span>, <span style="color:#e6db74">&#39;loadClassLoader&#39;</span>), <span style="color:#66d9ef">true</span>, <span style="color:#66d9ef">true</span>);
    
            <span style="color:#75715e">// 实例化该方法时会自动调用上述方法注册的函数，
</span><span style="color:#75715e"></span>            <span style="color:#75715e">// loadClassLoader函数里引入 ClassLoader类
</span><span style="color:#75715e"></span>            <span style="color:#a6e22e">self</span><span style="color:#f92672">::</span>$loader <span style="color:#f92672">=</span> $loader <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">\Composer\Autoload\ClassLoader</span>();
    
            <span style="color:#a6e22e">spl_autoload_unregister</span>(<span style="color:#66d9ef">array</span>(<span style="color:#e6db74">&#39;ComposerAutoloaderInit85b4dbf6b714d62ec745fcf3dd1a5041&#39;</span>, <span style="color:#e6db74">&#39;loadClassLoader&#39;</span>));
    
            <span style="color:#75715e">// PSR-0 的规则
</span><span style="color:#75715e"></span>            $map <span style="color:#f92672">=</span> <span style="color:#66d9ef">require</span> <span style="color:#66d9ef">__DIR__</span> <span style="color:#f92672">.</span> <span style="color:#e6db74">&#39;/autoload_namespaces.php&#39;</span>;
            <span style="color:#66d9ef">foreach</span> ($map <span style="color:#66d9ef">as</span> $namespace <span style="color:#f92672">=&gt;</span> $path) {
                $loader<span style="color:#f92672">-&gt;</span><span style="color:#a6e22e">set</span>($namespace, $path);
            }
    
        <span style="color:#75715e">// PSR-4 的规则
</span><span style="color:#75715e"></span>            $map <span style="color:#f92672">=</span> <span style="color:#66d9ef">require</span> <span style="color:#66d9ef">__DIR__</span> <span style="color:#f92672">.</span> <span style="color:#e6db74">&#39;/autoload_psr4.php&#39;</span>;
            <span style="color:#66d9ef">foreach</span> ($map <span style="color:#66d9ef">as</span> $namespace <span style="color:#f92672">=&gt;</span> $path) {
                $loader<span style="color:#f92672">-&gt;</span><span style="color:#a6e22e">setPsr4</span>($namespace, $path);
            }
    
            $classMap <span style="color:#f92672">=</span> <span style="color:#66d9ef">require</span> <span style="color:#66d9ef">__DIR__</span> <span style="color:#f92672">.</span> <span style="color:#e6db74">&#39;/autoload_classmap.php&#39;</span>;
            <span style="color:#66d9ef">if</span> ($classMap) {
                $loader<span style="color:#f92672">-&gt;</span><span style="color:#a6e22e">addClassMap</span>($classMap);
            }
    
        <span style="color:#75715e">// 注册给定的函数作为 __autoload 的实现,具体参考下文
</span><span style="color:#75715e"></span>            <span style="color:#75715e">// Class-Map部分
</span><span style="color:#75715e"></span>            $loader<span style="color:#f92672">-&gt;</span><span style="color:#a6e22e">register</span>(<span style="color:#66d9ef">true</span>);
    
        <span style="color:#75715e">// Files方式 直接加载需要访问的文件
</span><span style="color:#75715e"></span>            $includeFiles <span style="color:#f92672">=</span> <span style="color:#66d9ef">require</span> <span style="color:#66d9ef">__DIR__</span> <span style="color:#f92672">.</span> <span style="color:#e6db74">&#39;/autoload_files.php&#39;</span>;
            <span style="color:#66d9ef">foreach</span> ($includeFiles <span style="color:#66d9ef">as</span> $fileIdentifier <span style="color:#f92672">=&gt;</span> $file) {
                <span style="color:#a6e22e">composerRequire85b4dbf6b714d62ec745fcf3dd1a5041</span>($fileIdentifier, $file);
            }
    
            <span style="color:#66d9ef">return</span> $loader;
        }
    }
    
    <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">composerRequire85b4dbf6b714d62ec745fcf3dd1a5041</span>($fileIdentifier, $file)
    {
        <span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">empty</span>($GLOBALS[<span style="color:#e6db74">&#39;__composer_autoload_files&#39;</span>][$fileIdentifier])) {
            <span style="color:#75715e">// 加载需要调用的文件
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">require</span> $file;
    
            $GLOBALS[<span style="color:#e6db74">&#39;__composer_autoload_files&#39;</span>][$fileIdentifier] <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span>;
        }
    }
</code></pre></div><ul>
<li>启动过程 index.php引入loader.php，loader.php引入了composer的autoloader.php，在这个文件中，会调用getLoader方法，按照PSR-0与PSR-4标准按照相应的标准进行文件的引入。</li>
</ul>
<h1 id="2异常处理">2.异常处理</h1>
<ul>
<li>抛出异常但是不catch是，会提示</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">Fatal error: Uncaught exception <span style="color:#e6db74">&#39;Exception&#39;</span> 
with message <span style="color:#e6db74">&#39;Value must be 1 or below&#39;</span> in C:<span style="color:#ae81ff">\w</span>ebfolder<span style="color:#ae81ff">\t</span>est.php:6 
Stack trace: <span style="color:#75715e">#0 C:\webfolder\test.php(12): </span>
checkNum<span style="color:#f92672">(</span>28<span style="color:#f92672">)</span> <span style="color:#75715e">#1 {main} thrown in C:\webfolder\test.php on line 6</span>
</code></pre></div><ul>
<li>catch&quot; 代码块会捕获异常，并创建一个包含异常信息的对象</li>
<li>设置顶层异常处理器,设置用户自定义的异常处理函数,用于没有用 try/catch 块来捕获的异常
set_exception_handler($ex)</li>
<li>需要进行异常处理的代码应该放入 try 代码块内，以便捕获潜在的异常。</li>
<li>每个 try 或 throw 代码块必须至少拥有一个对应的 catch 代码块。</li>
<li>使用多个 catch 代码块可以捕获不同种类的异常。</li>
<li>可以在 try 代码块内的 catch 代码块中再次抛出（re-thrown）异常。</li>
</ul>
<h1 id="3多进程">3.多进程</h1>
<ul>
<li>php处理多并发主要是依赖服务器或php-FPM的多进程及它们进程的复用，但php实现多进程也意义重大，尤其是在后台Cli模式下处理大量数据或运行后台DEMON守护进程时，多进程的优势不用多说</li>
<li>php的多线程也曾被人提及，但进程内多线程资源共享和分配的问题难以解决。php也有多线程想关的扩展 pthreads ，但据说不太稳定</li>
<li>需要两个扩展 pcntl和 posix</li>
<li>创建子进程: pcntl_fork()-在当前进程当前位置产生子进程,子进程会继承父进程的上下文，并且和父进程一样从pcntl_fork()函数的位置继续向下执行，pcntl_fork()函数会返回不同的值，以便于区分各个分支，并执行不同的任务</li>
<li>父进程的返回值为1(pid)，后续的子进程的pid都比这个值大</li>
<li>子进程中，此函数的返回值会是固定值0，我们也可以通过判断pcntl_fork()的返回值为0来确定子进程</li>
<li>简单的例子</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-php" data-lang="php"><span style="color:#f92672">&lt;?</span><span style="color:#a6e22e">php</span>
    $ppid <span style="color:#f92672">=</span> <span style="color:#a6e22e">posix_getpid</span>();
    $pid <span style="color:#f92672">=</span> <span style="color:#a6e22e">pcntl_fork</span>();
    <span style="color:#66d9ef">if</span> ($pid <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) {
        <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">Exception</span>(<span style="color:#e6db74">&#39;fork子进程失败!&#39;</span>);
    } <span style="color:#66d9ef">elseif</span> ($pid <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>) {
        <span style="color:#a6e22e">cli_set_process_title</span>(<span style="color:#e6db74">&#34;我是父进程,我的进程id是</span><span style="color:#e6db74">{</span>$ppid<span style="color:#e6db74">}</span><span style="color:#e6db74">.&#34;</span>);
    　　 <span style="color:#a6e22e">sleep</span>(<span style="color:#ae81ff">30</span>); <span style="color:#75715e">// 保持30秒，确保能被ps查到
</span><span style="color:#75715e"></span>    } <span style="color:#66d9ef">else</span> {
        $cpid <span style="color:#f92672">=</span> <span style="color:#a6e22e">posix_getpid</span>();
        <span style="color:#a6e22e">cli_set_process_title</span>(<span style="color:#e6db74">&#34;我是</span><span style="color:#e6db74">{</span>$ppid<span style="color:#e6db74">}</span><span style="color:#e6db74">的子进程,我的进程id是</span><span style="color:#e6db74">{</span>$cpid<span style="color:#e6db74">}</span><span style="color:#e6db74">.&#34;</span>);
        <span style="color:#a6e22e">sleep</span>(<span style="color:#ae81ff">30</span>);
    }

</code></pre></div><h2 id="管理子进程">管理子进程</h2>
<p>使用信号来管理子进程</p>
<h3 id="分发信号处理器">分发信号处理器</h3>
<ul>
<li>我们通过在父进程接收子进程传来的信号，判断子进程状态，来对子进程进行管理。</li>
<li>我们需要在父进程里使用pcntl_signal()函数和pcntl_signal_dispatch()函数来给各个子进程安装信号处理器。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-php" data-lang="php"><span style="color:#f92672">&lt;?</span><span style="color:#a6e22e">php</span>
    <span style="color:#a6e22e">pcntl_signal</span> (<span style="color:#a6e22e">int</span> $signo , <span style="color:#a6e22e">callback</span> $handler) <span style="color:#a6e22e">安装一个信号处理器；</span>
    <span style="color:#75715e">#$signo是待处理的信号常量，callback是其处理函数
</span><span style="color:#75715e"></span>    
    <span style="color:#a6e22e">pcntl_signal_dispatch</span> () <span style="color:#a6e22e">调用每个等待信号通过pcntl_signal</span>()<span style="color:#a6e22e">安装的处理器</span>
</code></pre></div><ul>
<li>php内常见的信号常量有：</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">        SIGCHLD     子进程退出成为僵尸进程会向父进程发送此信号
        SIGHUP      进程挂起
        SIGTEM      进程终止
        ...         // 其他请在手册中查看
</code></pre></div><ul>
<li>安装并调用信号处理器后，一旦子进程有相应的信号返回给父进程，父进程就可以调用相应的callback函数对子进程处理；</li>
</ul>
<h2 id="处理子进程">处理子进程</h2>
<ul>
<li>posix_kill()：此函数并不能顾名思义，它通过向子进程发送一个信号来操作子进程，在需要要时可以选择给子进程发送进程终止信号来终止子进程；</li>
<li>pcntl_waitpid()：等待或返回fork的子进程状态，如果指定的子进程在此函数调用时已经退出（俗称僵尸进程），此函数将立刻返回，并释放子进程的所有系统资源，此进程可以避免子进程变成僵尸进程，造成系统资源浪费；</li>
</ul>
<h2 id="总结">总结</h2>
<blockquote>
<p>1.使用多进程, 子进程结束以后, 内核会负责回收资源<br>
2.使用多进程,子进程异常退出不会导致整个进程Thread退出. 父进程还有机会重建流程.<br>
3.一个常驻主进程, 只负责任务分发, 逻辑更清楚.</p>
</blockquote>
<h1 id="4反射的使用方法-获取类成员及其属性-reflectionclass">4.反射的使用方法 获取类成员及其属性 ReflectionClass</h1>
<ul>
<li>面向对象编辑中对象被赋予了自省的能力,而这个自省的过程就是反射.</li>
<li>给你一个光秃秃的对象,我可以仅仅通过这个对象就能知道它所属的类,拥有哪些方法.</li>
<li>反射指在php运行状态中,扩展分析php程序,导出或提取出关于类,方法,属性,参数等详细信息,包括注释.这种动态获取信息以及动态调用对象方法的功能称为反射API</li>
</ul>
<h2 id="使用反射">使用反射</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-php" data-lang="php"><span style="color:#f92672">&lt;?</span><span style="color:#a6e22e">php</span>
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">HandsonBoy</span>
{
    <span style="color:#66d9ef">public</span> $name <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;chenqionghe&#39;</span>;
    <span style="color:#66d9ef">public</span> $age <span style="color:#f92672">=</span> <span style="color:#ae81ff">18</span>;
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">function</span> __set($name,$value)
    {
        <span style="color:#66d9ef">echo</span> <span style="color:#e6db74">&#39;您正在设置私有属性&#39;</span><span style="color:#f92672">.</span>$name<span style="color:#f92672">.</span><span style="color:#e6db74">&#39;&lt;br &gt;值为&#39;</span><span style="color:#f92672">.</span>$value<span style="color:#f92672">.</span><span style="color:#e6db74">&#39;&lt;br&gt;&#39;</span>;
        $this<span style="color:#f92672">-&gt;</span>$name <span style="color:#f92672">=</span> $value;
    }
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">function</span> __get($name)
    {
        <span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span><span style="color:#a6e22e">isset</span>($this<span style="color:#f92672">-&gt;</span>$name))
        {
            <span style="color:#66d9ef">echo</span> <span style="color:#e6db74">&#39;未设置&#39;</span><span style="color:#f92672">.</span>$name;
            $this<span style="color:#f92672">-&gt;</span>$name <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;正在为你设置默认值&#34;</span><span style="color:#f92672">.</span><span style="color:#e6db74">&#39;&lt;br&gt;&#39;</span>;
        }
        <span style="color:#66d9ef">return</span> $this<span style="color:#f92672">-&gt;</span>$name;
    }
}
$boy <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">HandsonBoy</span>();
<span style="color:#66d9ef">echo</span> $boy<span style="color:#f92672">-&gt;</span><span style="color:#a6e22e">name</span><span style="color:#f92672">.</span><span style="color:#e6db74">&#39;&lt;br /&gt;&#39;</span>;
$boy<span style="color:#f92672">-&gt;</span><span style="color:#a6e22e">hair</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;short&#39;</span>;
</code></pre></div><h3 id="获取对象的方法和属性">获取对象的方法和属性</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-php" data-lang="php"><span style="color:#f92672">&lt;?</span><span style="color:#a6e22e">php</span>
$reflect <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">ReflectionObject</span>($boy);
$props <span style="color:#f92672">=</span> $reflect<span style="color:#f92672">-&gt;</span><span style="color:#a6e22e">getProperties</span>();
<span style="color:#75715e">//获取属性的名字
</span><span style="color:#75715e"></span><span style="color:#66d9ef">foreach</span>($props <span style="color:#66d9ef">as</span> $prop)
{
    <span style="color:#66d9ef">print</span> $prop<span style="color:#f92672">-&gt;</span><span style="color:#a6e22e">getName</span>()<span style="color:#f92672">.</span><span style="color:#a6e22e">php_EOL</span>;
}
<span style="color:#75715e">//获取对象方法列表
</span><span style="color:#75715e"></span>$methos <span style="color:#f92672">=</span> $reflect<span style="color:#f92672">-&gt;</span><span style="color:#a6e22e">getMethods</span>();
<span style="color:#66d9ef">foreach</span>($methos <span style="color:#66d9ef">as</span> $method)
{
    <span style="color:#66d9ef">print</span> $method<span style="color:#f92672">-&gt;</span><span style="color:#a6e22e">getName</span>()<span style="color:#f92672">.</span><span style="color:#a6e22e">php_EOL</span>;
}
</code></pre></div><h3 id="不用反射api使用class函数只针对公开的属性和方法">不用反射API,使用class函数(只针对公开的属性和方法)</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-php" data-lang="php"><span style="color:#f92672">&lt;?</span><span style="color:#a6e22e">php</span>
<span style="color:#75715e">//返回对象属性的关联数组
</span><span style="color:#75715e"></span><span style="color:#a6e22e">var_dump</span>(<span style="color:#a6e22e">get_object_vars</span>($boy));
<span style="color:#75715e">//类属性
</span><span style="color:#75715e"></span><span style="color:#a6e22e">var_dump</span>(<span style="color:#a6e22e">get_class_vars</span>(<span style="color:#a6e22e">get_class</span>($boy)));
<span style="color:#75715e">//返回由类的属性的方法名组成的数组
</span><span style="color:#75715e"></span><span style="color:#a6e22e">var_dump</span>(<span style="color:#a6e22e">get_class_methods</span>(<span style="color:#a6e22e">get_class</span>($boy)));
</code></pre></div><h3 id="打印类的代码的实例">打印类的代码的实例</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-php" data-lang="php"><span style="color:#f92672">&lt;?</span><span style="color:#a6e22e">php</span>
<span style="color:#e6db74">/**
</span><span style="color:#e6db74"> * @param $classObject 对象或者类名
</span><span style="color:#e6db74"> */</span>
<span style="color:#66d9ef">function</span> <span style="color:#a6e22e">getClass</span>($classObject)
{
    $object <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">ReflectionClass</span>($classObject);
    $className <span style="color:#f92672">=</span> $object<span style="color:#f92672">-&gt;</span><span style="color:#a6e22e">getName</span>();
    $Methods <span style="color:#f92672">=</span> $Properties <span style="color:#f92672">=</span> <span style="color:#66d9ef">array</span>();
    <span style="color:#66d9ef">foreach</span>($object<span style="color:#f92672">-&gt;</span><span style="color:#a6e22e">getProperties</span>() <span style="color:#66d9ef">as</span> $v)
    {
        $Properties[$v<span style="color:#f92672">-&gt;</span><span style="color:#a6e22e">getName</span>()] <span style="color:#f92672">=</span> $v;
    }
    <span style="color:#66d9ef">foreach</span>($object<span style="color:#f92672">-&gt;</span><span style="color:#a6e22e">getMethods</span>() <span style="color:#66d9ef">as</span> $v)
    {
        $Methods[$v<span style="color:#f92672">-&gt;</span><span style="color:#a6e22e">getName</span>()] <span style="color:#f92672">=</span> $v;
    }
    <span style="color:#66d9ef">echo</span> <span style="color:#e6db74">&#34;class </span><span style="color:#e6db74">{</span>$className<span style="color:#e6db74">}</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">{</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
    <span style="color:#a6e22e">is_array</span>($Properties) <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">ksort</span>($Properties);
    <span style="color:#66d9ef">foreach</span>($Properties <span style="color:#66d9ef">as</span> $k<span style="color:#f92672">=&gt;</span>$v)
    {
        <span style="color:#66d9ef">echo</span> <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\t</span><span style="color:#e6db74">&#34;</span>;
        <span style="color:#66d9ef">echo</span> $v<span style="color:#f92672">-&gt;</span><span style="color:#a6e22e">isPublic</span>() <span style="color:#f92672">?</span> <span style="color:#e6db74">&#39;public&#39;</span> <span style="color:#f92672">:</span> <span style="color:#e6db74">&#39;&#39;</span>,$v<span style="color:#f92672">-&gt;</span><span style="color:#a6e22e">isPrivate</span>() <span style="color:#f92672">?</span> <span style="color:#e6db74">&#39;private&#39;</span> <span style="color:#f92672">:</span><span style="color:#e6db74">&#39;&#39;</span>,$v<span style="color:#f92672">-&gt;</span><span style="color:#a6e22e">isProtected</span>() <span style="color:#f92672">?</span> <span style="color:#e6db74">&#39;protected&#39;</span> <span style="color:#f92672">:</span> <span style="color:#e6db74">&#39;&#39;</span>;
        $v<span style="color:#f92672">-&gt;</span><span style="color:#a6e22e">isStatic</span>() <span style="color:#f92672">?</span> <span style="color:#e6db74">&#39;static&#39;</span> <span style="color:#f92672">:</span> <span style="color:#e6db74">&#39;&#39;</span>;
        <span style="color:#66d9ef">echo</span> <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\t</span><span style="color:#e6db74">{</span>$k<span style="color:#e6db74">}</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
    }
    <span style="color:#66d9ef">echo</span> <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
    <span style="color:#66d9ef">if</span>(<span style="color:#a6e22e">is_array</span>($Methods)) <span style="color:#a6e22e">ksort</span>($Methods);
    <span style="color:#66d9ef">foreach</span>($Methods <span style="color:#66d9ef">as</span> $k<span style="color:#f92672">=&gt;</span>$v)
    {
        <span style="color:#66d9ef">echo</span> <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\t</span><span style="color:#e6db74">function </span><span style="color:#e6db74">{</span>$k<span style="color:#e6db74">}</span><span style="color:#e6db74">()</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
    }
    <span style="color:#66d9ef">echo</span> <span style="color:#e6db74">&#34;}</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
}
</code></pre></div><h2 id="反射的作用">反射的作用</h2>
<ul>
<li>反射可以用于文档生成,因此可以用它对文件里的类进行扫描,逐个生成描述文档.</li>
<li>做hook实现插件功能</li>
<li>动态代理
作为动态代理的例子:</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-php" data-lang="php">
<span style="color:#f92672">&lt;?</span><span style="color:#a6e22e">php</span>
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">mysql</span>
{
    <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">connect</span>($db)
    {
<span style="color:#75715e">#        echo &#34;连接到数据库{$db[0]}&#34; . php_EOL;
</span><span style="color:#75715e"></span>    }
}

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">sqlproxy</span>
{
    <span style="color:#66d9ef">private</span> $target;
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">function</span> __construct($tar)
    {
        $this<span style="color:#f92672">-&gt;</span><span style="color:#a6e22e">target</span>[] <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> $tar;
    }
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">function</span> __call($name,$args)
    {
        <span style="color:#66d9ef">foreach</span>($this<span style="color:#f92672">-&gt;</span><span style="color:#a6e22e">target</span> <span style="color:#66d9ef">as</span> $obj)
        {
            $r <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">ReflectionClass</span>($obj);
            <span style="color:#66d9ef">if</span>($method <span style="color:#f92672">=</span> $r<span style="color:#f92672">-&gt;</span><span style="color:#a6e22e">getMethod</span>($name))
            {
                <span style="color:#66d9ef">if</span>($method<span style="color:#f92672">-&gt;</span><span style="color:#a6e22e">isPublic</span>() <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">!</span>$method<span style="color:#f92672">-&gt;</span><span style="color:#a6e22e">isAbstract</span>())
                {
                    <span style="color:#66d9ef">echo</span> <span style="color:#e6db74">&#34;方法前拦截记录LOG&#34;</span><span style="color:#f92672">.</span><span style="color:#a6e22e">php_EOL</span>;
                    $method<span style="color:#f92672">-&gt;</span><span style="color:#a6e22e">invoke</span>($obj,$args);
                    <span style="color:#66d9ef">echo</span> <span style="color:#e6db74">&#34;方法后拦截&#34;</span><span style="color:#f92672">.</span><span style="color:#a6e22e">php_EOL</span>;
                }
            }
        }
    }
}
$obj <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">sqlproxy</span>(<span style="color:#e6db74">&#39;mysql&#39;</span>);
$obj<span style="color:#f92672">-&gt;</span><span style="color:#a6e22e">connect</span>(<span style="color:#e6db74">&#39;chenqionghe&#39;</span>);
</code></pre></div><h2 id="弊端">弊端</h2>
<ul>
<li>反射也会破坏类的封装性,因为反射可以使本不应该暴露的方法或属性被强制暴露了出来,这既是优点也是缺点.</li>
</ul>
<h1 id="5trait-代码复用">5.trait 代码复用</h1>
<ul>
<li>自 php 5.4.0 起，php 实现了一种代码复用的方法，称为 trait。</li>
<li>Trait 是为类似 php 的单继承语言而准备的一种代码复用机制。Trait 为了减少单继承语言的限制，使开发人员能够自由地在不同层次结构内独立的类中复用 method</li>
<li>Trait 是 php 多重继承的一种解决方案。例如，需要同时继承两个 Abstract Class， 这将会是件很麻烦的事情，Trait 就是为了解决这个问题。它为传统继承增加了水平特性的组合</li>
</ul>
<h2 id="用法">用法</h2>
<h3 id="简单使用">简单使用</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-php" data-lang="php"><span style="color:#f92672">&lt;?</span><span style="color:#a6e22e">php</span>
<span style="color:#66d9ef">trait</span> <span style="color:#a6e22e">first_trait</span>{
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">hello</span>(){
        <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#39;hello&#39;</span>;
    }
}
</code></pre></div><ul>
<li>在Class里使用trait，要使用use关键字，使用多个trait时用英文逗号隔开</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-php" data-lang="php"><span style="color:#f92672">&lt;?</span><span style="color:#a6e22e">php</span>
<span style="color:#66d9ef">trait</span> <span style="color:#a6e22e">first_trait</span>{
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">hello</span>(){
        <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#39;hello&#39;</span>;
    }
}

<span style="color:#66d9ef">trait</span> <span style="color:#a6e22e">second_trait</span>{
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">world</span>(){
        <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#39;world&#39;</span>;
    }
}

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">first_class</span>{
    <span style="color:#66d9ef">use</span> <span style="color:#a6e22e">first_trait</span>,<span style="color:#a6e22e">second_trait</span>;
}
$obj<span style="color:#f92672">=</span><span style="color:#66d9ef">new</span> <span style="color:#a6e22e">first_class</span>();
<span style="color:#66d9ef">echo</span> $obj<span style="color:#f92672">-&gt;</span><span style="color:#a6e22e">hello</span>();
<span style="color:#66d9ef">echo</span> $obj<span style="color:#f92672">-&gt;</span><span style="color:#a6e22e">world</span>();
</code></pre></div><ul>
<li>
<p>优先级
从基类继承的成员会被 trait 插入的成员所覆盖。优先顺序是来自当前类的成员覆盖了 trait 的方法，而 trait 则覆盖了被继承的方法。</p>
</li>
<li>
<p>trait之间的嵌套</p>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-php" data-lang="php"><span style="color:#f92672">&lt;?</span><span style="color:#a6e22e">php</span>
<span style="color:#66d9ef">trait</span> <span style="color:#a6e22e">first_trait</span>{
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">hello</span>(){
        <span style="color:#66d9ef">echo</span> <span style="color:#e6db74">&#39;hello&#39;</span>;
    }
}

<span style="color:#66d9ef">trait</span> <span style="color:#a6e22e">second_trait</span>{
    <span style="color:#75715e">//trait之间的嵌套
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">use</span> <span style="color:#a6e22e">first_trait</span>;
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">world</span>(){
        <span style="color:#66d9ef">echo</span> <span style="color:#e6db74">&#39;world&#39;</span>;
    }
}

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">first_class</span>{
    <span style="color:#66d9ef">use</span> <span style="color:#a6e22e">second_trait</span>;
}
$obj<span style="color:#f92672">=</span><span style="color:#66d9ef">new</span> <span style="color:#a6e22e">first_class</span>();
<span style="color:#66d9ef">echo</span> $obj<span style="color:#f92672">-&gt;</span><span style="color:#a6e22e">hello</span>();
<span style="color:#66d9ef">echo</span> $obj<span style="color:#f92672">-&gt;</span><span style="color:#a6e22e">world</span>();
</code></pre></div><ul>
<li>可以在trait中声明抽象方法，使用它的Class或trait必须实现抽象方法</li>
</ul>
<h3 id="冲突的解决">冲突的解决</h3>
<ul>
<li>如果两个 trait 都插入了一个同名的方法，如果没有明确解决冲突将会产生一个致命错误。</li>
<li>为了解决多个 trait 在同一个类中的命名冲突，需要使用 insteadof 操作符来明确指定使用冲突方法中的哪一个。</li>
<li>以上方式仅允许排除掉其它方法，as 操作符可以将其中一个冲突的方法以另一个名称来引入，相当于方法的别名。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-php" data-lang="php"><span style="color:#f92672">&lt;?</span><span style="color:#a6e22e">php</span>
<span style="color:#66d9ef">trait</span> <span style="color:#a6e22e">A</span> {
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">smallTalk</span>() {
        <span style="color:#66d9ef">echo</span> <span style="color:#e6db74">&#39;a&#39;</span>;
    }
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">bigTalk</span>() {
        <span style="color:#66d9ef">echo</span> <span style="color:#e6db74">&#39;A&#39;</span>;
    }
}

<span style="color:#66d9ef">trait</span> <span style="color:#a6e22e">B</span> {
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">smallTalk</span>() {
        <span style="color:#66d9ef">echo</span> <span style="color:#e6db74">&#39;b&#39;</span>;
    }
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">bigTalk</span>() {
        <span style="color:#66d9ef">echo</span> <span style="color:#e6db74">&#39;B&#39;</span>;
    }
}

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Talker</span> {
    <span style="color:#66d9ef">use</span> <span style="color:#a6e22e">A</span>, <span style="color:#a6e22e">B</span> {
        <span style="color:#a6e22e">B</span><span style="color:#f92672">::</span><span style="color:#a6e22e">smallTalk</span> <span style="color:#a6e22e">insteadof</span> <span style="color:#a6e22e">A</span>; <span style="color:#75715e">//trait B 的smallTalk方法会代替 trait A 的smallTalk方法
</span><span style="color:#75715e"></span>        <span style="color:#a6e22e">A</span><span style="color:#f92672">::</span><span style="color:#a6e22e">bigTalk</span> <span style="color:#a6e22e">insteadof</span> <span style="color:#a6e22e">B</span>;  <span style="color:#75715e">//trait A 的bigTalk方法会代替 trait B 的bigTalk方法
</span><span style="color:#75715e"></span>    }
}

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Aliased_Talker</span> {
    <span style="color:#66d9ef">use</span> <span style="color:#a6e22e">A</span>, <span style="color:#a6e22e">B</span> {
        <span style="color:#a6e22e">B</span><span style="color:#f92672">::</span><span style="color:#a6e22e">smallTalk</span> <span style="color:#a6e22e">insteadof</span> <span style="color:#a6e22e">A</span>;<span style="color:#75715e">//trait B 的smallTalk方法会代替 trait A 的smallTalk方法
</span><span style="color:#75715e"></span>        <span style="color:#a6e22e">A</span><span style="color:#f92672">::</span><span style="color:#a6e22e">bigTalk</span> <span style="color:#a6e22e">insteadof</span> <span style="color:#a6e22e">B</span>;<span style="color:#75715e">//trait A 的bigTalk方法会代替 trait B 的bigTalk方法
</span><span style="color:#75715e"></span>        <span style="color:#a6e22e">B</span><span style="color:#f92672">::</span><span style="color:#a6e22e">bigTalk</span> <span style="color:#66d9ef">as</span> <span style="color:#a6e22e">talk</span>; <span style="color:#75715e">//使用 as 操作符来定义了 talk方法 来作为 B 的 bigTalk方法 的别名
</span><span style="color:#75715e"></span>    }
}

$obj<span style="color:#f92672">=</span><span style="color:#66d9ef">new</span> <span style="color:#a6e22e">Talker</span>();
$obj<span style="color:#f92672">-&gt;</span><span style="color:#a6e22e">smallTalk</span>();
$obj<span style="color:#f92672">-&gt;</span><span style="color:#a6e22e">bigTalk</span>();
<span style="color:#75715e">//结果会输出 bA
</span><span style="color:#75715e"></span>$obj2<span style="color:#f92672">=</span><span style="color:#66d9ef">new</span> <span style="color:#a6e22e">Aliased_Talker</span>();
$obj2<span style="color:#f92672">-&gt;</span><span style="color:#a6e22e">talk</span>();<span style="color:#75715e">//会输出B
</span></code></pre></div><h3 id="修改访问控制">修改访问控制</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-php" data-lang="php"><span style="color:#f92672">&lt;?</span><span style="color:#a6e22e">php</span>
<span style="color:#66d9ef">trait</span> <span style="color:#a6e22e">HelloWorld</span> {
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">sayHello</span>() {
        <span style="color:#66d9ef">echo</span> <span style="color:#e6db74">&#39;Hello World!&#39;</span>;
    }
}

<span style="color:#75715e">// 修改 sayHello 的访问控制
</span><span style="color:#75715e"></span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyClass1</span> {
    <span style="color:#66d9ef">use</span> <span style="color:#a6e22e">HelloWorld</span> { <span style="color:#a6e22e">sayHello</span> <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">protected</span>; }
}

<span style="color:#75715e">// 给方法一个改变了访问控制的别名
</span><span style="color:#75715e">// 原版 sayHello 的访问控制则没有发生变化
</span><span style="color:#75715e"></span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyClass2</span> {
    <span style="color:#66d9ef">use</span> <span style="color:#a6e22e">HelloWorld</span> { <span style="color:#a6e22e">sayHello</span> <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">private</span> <span style="color:#a6e22e">myPrivateHello</span>; }
}
</code></pre></div><h3 id="trait-同样可以定义属性">Trait 同样可以定义属性</h3>
<ul>
<li>如果 trait 定义了一个属性，那类将不能定义同样名称的属性，否则会产生一个错误。如果该属性在类中的定义与在 trait 中的定义兼容（同样的可见性和初始值）则错误的级别是 E_STRICT，否则是一个致命错误。</li>
</ul>
<h1 id="6php的生成器yield和协程">6.php的生成器、yield和协程</h1>
<h2 id="迭代生成器">迭代生成器</h2>
<h3 id="迭代生成器也是一个函数不同的是这个函数的返回值是依次返回而不是只返回一个单独的值或者换句话说生成器使你能更方便的实现了迭代器接口下面通过实现一个xrange函数来简单说明">(迭代)生成器也是一个函数,不同的是这个函数的返回值是依次返回,而不是只返回一个单独的值.或者,换句话说,生成器使你能更方便的实现了迭代器接口.下面通过实现一个xrange函数来简单说明：</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-php" data-lang="php"><span style="color:#f92672">&lt;?</span><span style="color:#a6e22e">php</span>
<span style="color:#66d9ef">function</span> <span style="color:#a6e22e">xrange</span>($start, $end, $step <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>) {
    <span style="color:#66d9ef">for</span> ($i <span style="color:#f92672">=</span> $start; $i <span style="color:#f92672">&lt;=</span> $end; $i <span style="color:#f92672">+=</span> $step) {
        <span style="color:#66d9ef">yield</span> $i;
    }
}
 
<span style="color:#66d9ef">foreach</span> (<span style="color:#a6e22e">xrange</span>(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1000000</span>) <span style="color:#66d9ef">as</span> $num) {
    <span style="color:#66d9ef">echo</span> $num, <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
}
</code></pre></div><ul>
<li>range()函数返回从1到100万0的数组</li>
<li>xrange() 返回的是依次输出这些值的迭代器</li>
</ul>
<h3 id="优点">优点</h3>
<ul>
<li>可以让你在处理大数据集合的时候不用一次性的加载到内存中.甚至你可以处理无限大的数据流.</li>
<li>也可以不同通过生成器来实现这个功能,而是可以通过继承Iterator接口实现.但通过使用生成器实现起来会更方便,不用再去实现iterator接口中的5个方法了</li>
</ul>
<h2 id="生成器为可中断的函数">生成器为可中断的函数</h2>
<ul>
<li>生成器是一种可中断的函数, 在它里面的yield构成了中断点.</li>
<li>调用xrange(1,1000000)的时候, xrange()函数里代码其实并没有真正地运行. 它只是返回了一个迭代器</li>
<li>调用迭代器的方法一次, 其中的代码运行一次.例如, 如果你调用$range-&gt;rewind(), 那么xrange()里的代码就会运行到控制流第一次出现yield的地方. 而函数内传递给yield语句的返回值可以通过$range-&gt;current()获取.</li>
<li>为了继续执行生成器中yield后的代码, 你就需要调用$range-&gt;next()方法. 这将再次启动生成器, 直到下一次yield语句出现. 因此,连续调用next()和current()方法, 你就能从生成器里获得所有的值, 直到再没有yield语句出现.</li>
<li>对xrange()来说, 这种情形出现在$i超过$end时. 在这中情况下, 控制流将到达函数的终点,因此将不执行任何代码.一旦这种情况发生,vaild()方法将返回假, 这时迭代结束.</li>
</ul>
<h2 id="协程">协程</h2>
<ul>
<li>协程的支持是在迭代生成器的基础上, 增加了可以回送数据给生成器的功能(调用者发送数据给被调用的生成器函数). 这就把生成器到调用者的单向通信转变为两者之间的双向通信.</li>
<li>传递数据的功能是通过迭代器的send()方法实现的. 下面的logger()协程是这种通信如何运行的例子：</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-php" data-lang="php"><span style="color:#f92672">&lt;?</span><span style="color:#a6e22e">php</span>
<span style="color:#66d9ef">function</span> <span style="color:#a6e22e">logger</span>($fileName) {
    $fileHandle <span style="color:#f92672">=</span> <span style="color:#a6e22e">fopen</span>($fileName, <span style="color:#e6db74">&#39;a&#39;</span>);
    <span style="color:#66d9ef">while</span> (<span style="color:#66d9ef">true</span>) {
        <span style="color:#a6e22e">fwrite</span>($fileHandle, <span style="color:#66d9ef">yield</span> <span style="color:#f92672">.</span> <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
    }
}
 
$logger <span style="color:#f92672">=</span> <span style="color:#a6e22e">logger</span>(<span style="color:#66d9ef">__DIR__</span> <span style="color:#f92672">.</span> <span style="color:#e6db74">&#39;/log&#39;</span>);
$logger<span style="color:#f92672">-&gt;</span><span style="color:#a6e22e">send</span>(<span style="color:#e6db74">&#39;Foo&#39;</span>);
$logger<span style="color:#f92672">-&gt;</span><span style="color:#a6e22e">send</span>(<span style="color:#e6db74">&#39;Bar&#39;</span>)
<span style="color:#75715e">?&gt;</span><span style="color:#960050;background-color:#1e0010">
</span></code></pre></div><p>yield没有作为一个语句来使用, 而是用作一个表达式, 即它能被演化成一个值. 这个值就是调用者传递给send()方法的值. 在这个例子里, yield表达式将首先被”Foo”替代写入Log, 然后被”Bar”替代写入Log.</p>
<ul>
<li>进行接收和发送的例子</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-php" data-lang="php"><span style="color:#f92672">&lt;?</span><span style="color:#a6e22e">php</span>
<span style="color:#66d9ef">function</span> <span style="color:#a6e22e">gen</span>() {
    $ret <span style="color:#f92672">=</span> (<span style="color:#66d9ef">yield</span> <span style="color:#e6db74">&#39;yield1&#39;</span>);
    <span style="color:#a6e22e">var_dump</span>($ret);
    $ret <span style="color:#f92672">=</span> (<span style="color:#66d9ef">yield</span> <span style="color:#e6db74">&#39;yield2&#39;</span>);
    <span style="color:#a6e22e">var_dump</span>($ret);
}

$gen <span style="color:#f92672">=</span> <span style="color:#a6e22e">gen</span>();
<span style="color:#a6e22e">var_dump</span>($gen<span style="color:#f92672">-&gt;</span><span style="color:#a6e22e">current</span>());    <span style="color:#75715e">// string(6) &#34;yield1&#34;
</span><span style="color:#75715e"></span><span style="color:#a6e22e">var_dump</span>($gen<span style="color:#f92672">-&gt;</span><span style="color:#a6e22e">send</span>(<span style="color:#e6db74">&#39;ret1&#39;</span>)); <span style="color:#75715e">// string(4) &#34;ret1&#34;   (the first var_dump in gen)
</span><span style="color:#75715e"></span>                              <span style="color:#75715e">// string(6) &#34;yield2&#34; (the var_dump of the -&gt;send() return value)
</span><span style="color:#75715e"></span><span style="color:#a6e22e">var_dump</span>($gen<span style="color:#f92672">-&gt;</span><span style="color:#a6e22e">send</span>(<span style="color:#e6db74">&#39;ret2&#39;</span>)); <span style="color:#75715e">// string(4) &#34;ret2&#34;   (again from within gen)
</span><span style="color:#75715e"></span>                              <span style="color:#75715e">// NULL               (the return value of -&gt;send())
</span><span style="color:#75715e"></span><span style="color:#75715e">?&gt;</span><span style="color:#960050;background-color:#1e0010">
</span></code></pre></div><h2 id="多任务协作">多任务协作</h2>
<ul>
<li>
<p>多任务协作，单核cpu，只能运行某个程序一会儿，这就需要运行一个程序后中断，然后执行其他程序，一段时间后，再回来执行后面的流程。</p>
</li>
<li>
<p>因此yield指令则提供了任务中断自身的一种方法。把控制交回任务调度器，yield还可以用来在任务和调度器之间进行通信</p>
</li>
<li>
<p>一个简单的包装协程函数</p>
</li>
</ul>

    </div>
</section>

    </body>
</html>