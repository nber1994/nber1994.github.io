<!DOCTYPE html>
<html lang="zh-cn">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<style type=text/css>body{font-family:monospace;}</style>
	<title>问题汇总</title>
	
	
	<link rel="stylesheet" href="/css/style.css">
	
	
</head>
<body>
	<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">

        <link href="https://fonts.googleapis.com/css?family=Ubuntu" rel="stylesheet">

        <title>问题汇总</title>

        <link rel="stylesheet" href="/css/stylesheet.css">
    </head>

<header>
        <section id="page-title">
            <h1><a href="/">nber1994</a></h1>

          <div class="date-time-title post">
			<a  href="/">All</a>
          </div>
			
			
          <div class="date-time-title post">
			<a href="/posts/">Posts</a>
          </div>
			
          <div class="date-time-title post">
			<a href="/categories/">Categories</a>
          </div>
			
          <div class="date-time-title post">
			<a href="/tags/">Tags</a>
          </div>
			
          <div class="date-time-title post">
			<a href="/about">About</a>
          </div>
			
	

        </section>
</header>

<div id="icon">
<script type="text/javascript">


    function chunkSubstr(str, size) {
            const numChunks = Math.ceil(str.length / size)
            const chunks = new Array(numChunks)

            for (let i = 0, o = 0; i < numChunks; ++i, o += size) {
                    chunks[i] = str.substr(o, size)
                }

            return chunks
        }
    var pic = [];
    pic[0] = "https://cdn.jsdelivr.net/gh/nber1994/fu0k@master/uPic/qRKvRQ20220116152554.jpg";
    pic[1] = "https://cdn.jsdelivr.net/gh/nber1994/fu0k@master/uPic/nEf3GW20220116150946.jpg";
    pic[2] = "https://cdn.jsdelivr.net/gh/nber1994/fu0k@master/uPic/ITL6SB20220116154359.jpg";
    pic[3] = "https://cdn.jsdelivr.net/gh/nber1994/fu0k@master/uPic/3QAQ7M20220116154758.jpg";
    pic[4] = "https://cdn.jsdelivr.net/gh/nber1994/fu0k@master/uPic/HCCsx620220116160636.jpg";
    pic[5] = "https://cdn.jsdelivr.net/gh/nber1994/fu0k@master/uPic/c4zSPk20220116161109.jpg";
    pic[6] = "https://cdn.jsdelivr.net/gh/nber1994/fu0k@master/uPic/Bm5IHA20220116161518.jpg";
    pic[7] = "https://cdn.jsdelivr.net/gh/nber1994/fu0k@master/uPic/lpcstW20220116161917.jpg";
    pic[8] = "https://cdn.jsdelivr.net/gh/nber1994/fu0k@master/uPic/MSCA4K20220116162440.jpg";

    var talk = [];
    talk[0] = "Help poor children in Uganda!";
    talk[1] = "Bad programmers worry about the code. Good programmers worry about data structures and their relationships.";
    talk[2] = "So, dear Redis community, today I’m stepping back as the Redis maintainer.";
    talk[3] = "Don't tune for speed until you've measured.";
    talk[4] = "C is quirky, flawed, and an enormous success.";
    talk[5] = "I've never thought of PHP as more than a simple tool to solve problems.";
    talk[6] = "Java is C++ without the guns, clubs and knives.";
    talk[7] = "Life is short, you need Python!";
    talk[8] = "C makes it easy to shoot yourself in the foot; C++ makes it harder, but when you do it blows your whole leg off.";

    var randomBgIndex = Math.floor( Math.random() * 8 );


    document.write("<img src=" + pic[randomBgIndex] + ">")
    document.write("<span style='font-size:12px'>" + talk[randomBgIndex] + " </span>")
    document.write("</div>")

</script>
</div>
<br>

	
<main>
    <article>
        <h1>问题汇总</h1>
        <div id="common-a">
            <b><time>2019-01-08</time></b>
            
            <a href="/categories/else"> ❐else</a>
            
            
            <a href="/tags/summary">✎ summary</a>
            
        </div>
        <div>
            <h1 id="问题汇总">问题汇总</h1>
<h1 id="os">OS</h1>
<p>虚拟内存
段页式
倒排页表
LRU，LFU算法实现
共享内存
多进程，多线程
如何fork一个进程
exec
waitpid
exit
页表的copy-on-worite
PCB</p>
<blockquote>
<p>PCB process control block
&gt; task_struct存储了进程的页表，打开文件描述符表，内存描述符，通用寄存器，进程状态等</p>
</blockquote>
<p>进程状态
<img src="https://cdn.jsdelivr.net/gh/nber1994/fu0k@master/uPic/20181208204811079_108465955.png" alt="">
IO多路复用
select，poll，epoll实现和优劣</p>
<p>用户态和内核态区别
进程，线程间通信
什么时候多线程什么时候多进程
线程ID进程组ID
线程和进程的切换和调度，切换的时什么
多进程
- 数据共享复杂，需要进程间通信
- 相对于多线程占用更多的内存
- 进程间切换相对于多线程开销较大
- 编程调试较简单
- 进程间互相不影响
- 适用于多机，性能扩展性较好
多线程
- 数据共享较简单
- 线程间可能会互相影响
- 编程调试较复杂
- 可以利用多核的优势
- 多线程之间切换开销较小</p>
<ul>
<li>文件描述符表</li>
</ul>
<h1 id="网络">网络</h1>
<h1 id="http-https">http https</h1>
<p>https相比较于http来说，在会话层加入了stl算法加密，过程如下
1.服务端发送来证书和公钥
2.客户端根据内置的颁发机构验证证书的真伪
3.如果证书为假，则报错
4.如果证书为真，则生成随机值，并用公钥加密传递给服务端
5.服务端收到后使用私钥进行解密，拿到随机值
6.之后的通信都使用随机值进行加密</p>
<h1 id="http-code">http code</h1>
<p>200 ok
301 moved permanly
302 Found
303 See Other
400 Bad Request
401 Nuauthorized
403 forbidden
404 Not Found
500 internal server error
502 bad gateway
503 service unavaliable
504 gateway timout</p>
<h1 id="iso7层">ISO7层</h1>
<p>应用层 用于应用之间的协议
表示层 特定格式和网络通用格式之间的转换
会话层 管理会话，发送策略
传输层 节点之间的可靠传输
网络层 寻址&amp;路由
数据链路层 链路之间的通信
物理层 01和电压高低转换</p>
<h1 id="如何排查网络问题">如何排查网络问题</h1>
<p>ping 看是否可以ping通
nslookup 获取域名对应的IP
traceroute 来看请求到达经历了多少跳路由
出现***说明有问题
telnet 检查端口是否出现开放
netstat 检查本地端口是否开启
iptables 查看防火墙
iftop 查看网络流量ip维度
tcpdump 抓包工具</p>
<p>DNS
13个根服务器 所有一级
跟服务器 -》一级 -》 二级-》 。。。。。-》本地服务器
本地如果没有直接到根服务器查询</p>
<h1 id="tcp-34手">tcp 3，4手</h1>
<p>msl 最大生存时间
<img src="https://cdn.jsdelivr.net/gh/nber1994/fu0k@master/uPic/20181129180159420_118828546.png" alt=""></p>
<p>ACK 确认
SYN 同步序号
FIN 终结
seq 序号</p>
<h2 id="三次握手">三次握手</h2>
<p>第一次：建立连接，客户端发送SYN seq=x 客户端进入SYN_SENT状态
第二次：服务端接收到后，返回 seq=y ack=x+1 服务端进入SYN_RECV状态
第三次：客户端回复，ack=1 连接建立完成 客户端进入ESTABLISHED 服务端接收到ack之后进入ESTABLISHED</p>
<h2 id="为什么三次握手">为什么三次握手</h2>
<p>为了防止某个SYN包在某个网络节点长时间的滞留之后又到达接收端
此时如果只是两次，接收端收到SYN之后就返回ack，建立连接但是事实上发送端并没有建立连接，白白浪费了接收端的资源</p>
<h2 id="四次分手">四次分手</h2>
<p>第一次：一端向另一端发送FIN seq=x 进入FIN_WAIT_1
第二次：另一端回复ack=x+1 进入CLOSE_WAIT
第三次：另一端发送FIN seq=y 进入FIN_WAIT_2
第四次：一端接收到之后返回ack=y+1 进入TIME_WAIT 另一端收到ack报文之后就关闭连接</p>
<h2 id="为什么四次分手">为什么四次分手</h2>
<p>因为一方发送FIN表明的是这一方已经没有数据需要传输了，而另一方收到之后会立马回复一个ack
但是另一方可能还有数据要发送，所以这个时候连接还不能断开，只有等到两方都没有数据要发送之后，才可以断开连接
CLOSE_WAIT的意思是，我已经知道对方要断开连接了，我要做的就是看我自己是否还存在数据未发送
<a href="https://github.com/jawil/blog/issues/14">通俗讲tcp三四</a></p>
<p>为什么time_wait时两倍的msl
1.让之前的包失效
2.及时接收到FIN</p>
<h1 id="mss-最大包长度">mss 最大包长度</h1>
<h1 id="华东窗口-拥塞窗口">华东窗口 拥塞窗口</h1>
<h1 id="tcp-为什么可靠">tcp 为什么可靠</h1>
<h1 id="tcp状态图">tcp状态图</h1>
<p><img src="https://cdn.jsdelivr.net/gh/nber1994/fu0k@master/uPic/20181129214141949_2139064559.png" alt=""></p>
<h1 id="负载均衡-四层和七层">负载均衡 四层和七层</h1>
<p>四层 ip+端口
是在ip加端口层次做负载均衡
负载均衡相当于是路由器，根据规则将ip+端口的包根据NAT协议分发给后端机器，tcp的握手是原机器和目标机器直接握手
七层 虚拟url或者主机ip等
在url或者主机ip上坐负载均衡
需要负载均衡机器首先和客户端建立tcp连接，然后和后端机器家里连接，将请求转发
对机器要求较高</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#000;font-weight:bold">|</span>          <span style="color:#000;font-weight:bold">|</span> <span style="color:#a61717;background-color:#e3d2d2">四层负载均衡（</span>layer <span style="color:#099">4</span><span style="color:#a61717;background-color:#e3d2d2">）</span> <span style="color:#000;font-weight:bold">|</span> <span style="color:#a61717;background-color:#e3d2d2">七层负载均衡（</span>layer <span style="color:#099">7</span><span style="color:#a61717;background-color:#e3d2d2">）</span>                          <span style="color:#000;font-weight:bold">|</span>
<span style="color:#000;font-weight:bold">+----------+-------------------------+--------------------------------------------------+</span>
<span style="color:#000;font-weight:bold">|</span> <span style="color:#a61717;background-color:#e3d2d2">基于</span>     <span style="color:#000;font-weight:bold">|</span> <span style="color:#a61717;background-color:#e3d2d2">基于</span>IP<span style="color:#000;font-weight:bold">+</span>Port的           <span style="color:#000;font-weight:bold">|</span> <span style="color:#a61717;background-color:#e3d2d2">基于虚拟的</span>URL或主机IP等<span style="color:#a61717;background-color:#e3d2d2">。</span>                        <span style="color:#000;font-weight:bold">|</span>
<span style="color:#000;font-weight:bold">+----------+-------------------------+--------------------------------------------------+</span>
<span style="color:#000;font-weight:bold">|</span> <span style="color:#a61717;background-color:#e3d2d2">类似于</span>   <span style="color:#000;font-weight:bold">|</span> <span style="color:#a61717;background-color:#e3d2d2">路由器</span>                  <span style="color:#000;font-weight:bold">|</span> <span style="color:#a61717;background-color:#e3d2d2">代理服务器</span>                                       <span style="color:#000;font-weight:bold">|</span>
<span style="color:#000;font-weight:bold">+----------+-------------------------+--------------------------------------------------+</span>
<span style="color:#000;font-weight:bold">|</span> <span style="color:#a61717;background-color:#e3d2d2">握手次数</span> <span style="color:#000;font-weight:bold">|</span> <span style="color:#099">1</span> <span style="color:#a61717;background-color:#e3d2d2">次</span>                    <span style="color:#000;font-weight:bold">|</span> <span style="color:#099">2</span> <span style="color:#a61717;background-color:#e3d2d2">次</span>                                             <span style="color:#000;font-weight:bold">|</span>
<span style="color:#000;font-weight:bold">+----------+-------------------------+--------------------------------------------------+</span>
<span style="color:#000;font-weight:bold">|</span> <span style="color:#a61717;background-color:#e3d2d2">复杂度</span>   <span style="color:#000;font-weight:bold">|</span> <span style="color:#a61717;background-color:#e3d2d2">低</span>                      <span style="color:#000;font-weight:bold">|</span> <span style="color:#a61717;background-color:#e3d2d2">高</span>                                               <span style="color:#000;font-weight:bold">|</span>
<span style="color:#000;font-weight:bold">+----------+-------------------------+--------------------------------------------------+</span>
<span style="color:#000;font-weight:bold">|</span> <span style="color:#a61717;background-color:#e3d2d2">性能</span>     <span style="color:#000;font-weight:bold">|</span> <span style="color:#a61717;background-color:#e3d2d2">高；无需解析内容</span>        <span style="color:#000;font-weight:bold">|</span> <span style="color:#a61717;background-color:#e3d2d2">中；需要算法识别</span> URL<span style="color:#a61717;background-color:#e3d2d2">，</span>Cookie <span style="color:#a61717;background-color:#e3d2d2">和</span> HTTP head <span style="color:#a61717;background-color:#e3d2d2">等信息</span> <span style="color:#000;font-weight:bold">|</span>
<span style="color:#000;font-weight:bold">+----------+-------------------------+--------------------------------------------------+</span>
<span style="color:#000;font-weight:bold">|</span> <span style="color:#a61717;background-color:#e3d2d2">安全性</span>   <span style="color:#000;font-weight:bold">|</span> <span style="color:#a61717;background-color:#e3d2d2">低，无法识别</span> DDoS等攻击 <span style="color:#000;font-weight:bold">|</span> <span style="color:#a61717;background-color:#e3d2d2">高，</span> <span style="color:#a61717;background-color:#e3d2d2">可以防御</span>SYN cookie以SYN flood等             <span style="color:#000;font-weight:bold">|</span>
<span style="color:#000;font-weight:bold">+----------+-------------------------+--------------------------------------------------+</span>
<span style="color:#000;font-weight:bold">|</span> <span style="color:#a61717;background-color:#e3d2d2">额外功能</span> <span style="color:#000;font-weight:bold">|</span> <span style="color:#a61717;background-color:#e3d2d2">无</span>                      <span style="color:#000;font-weight:bold">|</span> <span style="color:#a61717;background-color:#e3d2d2">会话保持，图片压缩，防盗链等</span>                     <span style="color:#000;font-weight:bold">|</span>
</code></pre></div><h1 id="nat">NAT</h1>
<p>一个网络存在一个公网地址，网络内的内网主机访问外网时，会在NAT网管转换源地址为公网地址，并记录，返回值根据这条记录返回到之前的主句
当多个内网主句同时访问外网机器，会分配不同的端口，来区分不同的返回结果</p>
<h1 id="tcp拥塞控制-慢启动-快启动">tcp拥塞控制 慢启动 快启动</h1>
<p>tcp的拥塞控制是由拥塞窗口和慢启动来实现的，
拥塞窗口就是发送端每次会发送窗口的大小，实际发送为min(拥塞窗口，接收端窗口)
首先在建立连接之后，发送端会一1MSS的大小发送包，并且每收到一个ack时窗口加一，这样会以指数增长
当第一次发生超时重传时，会设置拥塞窗口阈值为当时窗口的一半，并且从1MSS开始发送
当发生快速重传时，由于其发生时网络情况较超时重传时较轻，会设置阈值为一半并且窗口为一半+3
当窗口超过阈值时，收到一个ack会按照一个窗口的字节数/拥塞窗口的字节数的比例增加窗口
这样看来其实拥塞窗口看起来像是在逐步侵占网络</p>
<h1 id="tcp通过什么保持可靠">tcp通过什么保持可靠</h1>
<p>seq 每次连接建立时会随机生成一个seq原始值，并在握手时互相通知，以后每次都会根据包的大小累加
防止上一个连接的包干扰本次连接
ack 收到确认，并且回把确认收到的seq返回
超时重传，如果超过超时重传事件没有收到ack则重发
快速重传，三次收到相同的seq值得ack，说明某个包丢失，则重传seq之后的包</p>
<h1 id="tcp如何提速">tcp如何提速</h1>
<p>按照窗口发送，并不需要等待上一个包收到ack后才发下一个
延时确认，等待窗口缓冲区被消费，返回更大的窗口大小
捎带应答，将应用的应打包和ack何为一个包发送</p>
<h1 id="mysql">mysql</h1>
<h1 id="myisam和innodb的区别">myisam和innodb的区别</h1>
<p>myisam
不支持事务，行级锁，索引为聚簇索引
innodb
支持事务，行级锁，索引为聚簇索引</p>
<h1 id="隔离级别">隔离级别</h1>
<p>uncommited read
未提交读，可能导致脏读，不可重复读，幻读
commited read
提交读，可能导致不可重复读，幻读
repetable read
可重复读，可能导致幻读
serialize
最安全，并发较低</p>
<h1 id="事务实现">事务实现</h1>
<p>mysql默认实现了不可重复读隔离级别的事务，
借助undo log实现了MVCC，来实现可重复读
每个事务开始之前会分配一个commitID，快照读ID之前的数据，update 新插入一条为本ID的数据，delete 标记本ID删除，insert 本ID
同时借助next-key锁解决了幻读的问题，幻读其实是对于insert来说的，next-key锁会在间隙加上锁，并在之前加上gap锁，有时会退化为行锁（唯一索引）</p>
<h1 id="索引实现细节">索引实现细节</h1>
<p>innodb采用B+树组织索引，B+树特点属于平衡树的一种，当数据量很大时也能保持比较低的树高保证查询速度（每次查询一个io）
每个非节点只存储关键字，并不存储数据内容，使得每个飞叶子节点能存储更多的关键词
主键索引的叶子节点存储数据行，因此叫做聚簇索引
辅助索引的叶子节点存储主键iD，因此每次查询会先查询副主索引得到主键ID再去查询朱建索引</p>
<h1 id="为什么使用b树">为什么使用B+树</h1>
<p>B+树属于平衡二叉树，左右节点树高不能相差大于1，当数据量较大时也能通过横向扩展保持较低的树高
b+树非叶子节点不保存数据行，每个叶子节点可以存储更多的关键字
叶子节点存储数据行，并且叶子节点之间互相连接，便于范围查找</p>
<h1 id="树高为什么这么高">树高为什么这么高</h1>
<p>innodb中一页的大小为16k，如果主键索引为bigint（8byte），同时一个指针为6byte，则一个飞叶子节点可以存储大约16k/14=1170个关键字，叶子节点假设一行1k，则一个叶子节点保存16个，三层1170<em>1170</em>16=2千万</p>
<h1 id="binlog">binlog</h1>
<p>mysql层次，记录每次对数据的改动，
记录修改的sql
记录数据行被修改后
混合模式，如一些函数修改，无法完成中从同步，则直接记录被修改后的记录
主要实现主从同步和回滚</p>
<h1 id="redo-log">redo log</h1>
<p>innodb内部实现持久化的日志
分为两种，一种是redolog缓冲区内的（易失），一种是redolog文件中的（不易失）
记录每一页的变动，采取force log bofore commit机制保证事务的持久化
每次事务提交后，写入redolog缓冲区，通过策略sync到磁盘
mysql重新启动时，都会重做redolog，根据checkpoint来恢复磁盘数据</p>
<h1 id="undolog">undolog</h1>
<p>innodb内部实现MVCC和事务回滚的日志
undolog同时会产生对应的redolog
记录每一行的变动</p>
<h1 id="主从延迟的原因">主从延迟的原因</h1>
<p>通过binlog进行主从同步，binglog顺序写入性能较高，slave主从复制线程从master拉取binlog也比较快
slave的slave_IO_Runing线程从binlog中读取日志执行也比较快
slave_io_running线程为单线程处理ddl和dml，同时可能与query产生锁争夺，所以同步会存在延迟
主库的插入可以并发，并且一般主库不query减少了锁争夺</p>
<h1 id="联合索引">联合索引</h1>
<p>联合索引的每个飞叶子节点，保存着所有联合索引的字段的关键字
最左前缀原则
联合索引的前一个字段如果使用&gt;&lt;或者函数，则后面的索引不会用到</p>
<h1 id="各种innodbcahche-buffer-pool">各种innoDBcahche buffer pool</h1>
<p>innodb的插入缓冲中的页包含数据页，索引页，插入缓冲页，锁信息，自适应哈希索引页等
缓冲池中的页采用lru算法来进行管理，lru_list和free_list</p>
<p>锁
分库分表分片</p>
<h1 id="redis">redis</h1>
<p>zset 类型&amp;实现
hash
lru：redis的实现，应用
事件机制，单线程高性能
集群实现，一致性hash，分布式事务，一致性 raft算法
内存淘汰
过期key
主从同步
持久化
pipline
redis事务实现
主从同步 psync和fsync</p>
<h1 id="算法">算法</h1>
<p>hash简单实现
list
array
tree
二叉树 侧边看过去
动态规划 最大面积
树的蛇形遍历
lfu，leu hashmap（增删改查）
单列表排序
八皇后
字符串匹配</p>
<h1 id="设计题">设计题</h1>
<h1 id="微服务">微服务</h1>

        </div>
    </article>
</main>
<aside>
	<div>
		<div>
			<h1>LATEST POSTS</h1>
		</div>
		<div id='common-a'>
			<ul>
				
                <div id="lists">
                    <div id=date class="date-time-title">
                        <time>2022-02-17</time>
                    </div>
                    <div class="date-time-title post">
                        <a href="http://nber1994.github.io/posts/channel-select/">golang channel浅析</a>
                    </div>
                </div>
				
                <div id="lists">
                    <div id=date class="date-time-title">
                        <time>2022-02-09</time>
                    </div>
                    <div class="date-time-title post">
                        <a href="http://nber1994.github.io/posts/golang-race%E6%A3%80%E6%B5%8B/">golang-race检测</a>
                    </div>
                </div>
				
                <div id="lists">
                    <div id=date class="date-time-title">
                        <time>2022-02-09</time>
                    </div>
                    <div class="date-time-title post">
                        <a href="http://nber1994.github.io/posts/golang-%E4%BF%A1%E5%8F%B7%E9%87%8F/">golang-信号量</a>
                    </div>
                </div>
				
                <div id="lists">
                    <div id=date class="date-time-title">
                        <time>2022-02-09</time>
                    </div>
                    <div class="date-time-title post">
                        <a href="http://nber1994.github.io/posts/golang%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB/">golang知识汇总</a>
                    </div>
                </div>
				
                <div id="lists">
                    <div id=date class="date-time-title">
                        <time>2022-01-15</time>
                    </div>
                    <div class="date-time-title post">
                        <a href="http://nber1994.github.io/posts/golang%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%E7%9A%84%E5%AE%9E%E7%8E%B0/">golang同步机制的实现</a>
                    </div>
                </div>
				
			</ul>
		</div>
	</div>
</aside>


	<footer>
    <div id='footer'>
	<p>&copy; 2022 <a href="http://nber1994.github.io/"><b>jingtianyou&#39;s blog</b></a>.
	</p>
    </div>
</footer>

</body>
</html>
