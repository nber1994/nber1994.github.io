<!DOCTYPE html>
<html lang="zh-cn">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<style type=text/css>body{font-family:monospace;}</style>
	<title>channel &amp; selelct</title>
	
	
	<link rel="stylesheet" href="/css/style.css">
	
	
</head>
<body>
	<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">

        <link href="https://fonts.googleapis.com/css?family=Ubuntu" rel="stylesheet">

        <title>channel &amp; selelct</title>

        <link rel="stylesheet" href="/css/stylesheet.css">
    </head>

<header>
        <section id="page-title">
            <h1><a href="/">nber1994</a></h1>

          <div class="date-time-title post">
			<a  href="/">All</a>
          </div>
			
			
          <div class="date-time-title post">
			<a href="/posts/">Posts</a>
          </div>
			
          <div class="date-time-title post">
			<a href="/categories/">Categories</a>
          </div>
			
          <div class="date-time-title post">
			<a href="/tags/">Tags</a>
          </div>
			
          <div class="date-time-title post">
			<a href="/about">About</a>
          </div>
			
	

        </section>
</header>

<div id="icon">
<script type="text/javascript">


    function chunkSubstr(str, size) {
            const numChunks = Math.ceil(str.length / size)
            const chunks = new Array(numChunks)

            for (let i = 0, o = 0; i < numChunks; ++i, o += size) {
                    chunks[i] = str.substr(o, size)
                }

            return chunks
        }
    var pic = [];
    pic[0] = "https://cdn.jsdelivr.net/gh/nber1994/fu0k@master/uPic/qRKvRQ20220116152554.jpg";
    pic[1] = "https://cdn.jsdelivr.net/gh/nber1994/fu0k@master/uPic/nEf3GW20220116150946.jpg";
    pic[2] = "https://cdn.jsdelivr.net/gh/nber1994/fu0k@master/uPic/ITL6SB20220116154359.jpg";
    pic[3] = "https://cdn.jsdelivr.net/gh/nber1994/fu0k@master/uPic/3QAQ7M20220116154758.jpg";
    pic[4] = "https://cdn.jsdelivr.net/gh/nber1994/fu0k@master/uPic/HCCsx620220116160636.jpg";
    pic[5] = "https://cdn.jsdelivr.net/gh/nber1994/fu0k@master/uPic/c4zSPk20220116161109.jpg";
    pic[6] = "https://cdn.jsdelivr.net/gh/nber1994/fu0k@master/uPic/Bm5IHA20220116161518.jpg";
    pic[7] = "https://cdn.jsdelivr.net/gh/nber1994/fu0k@master/uPic/lpcstW20220116161917.jpg";
    pic[8] = "https://cdn.jsdelivr.net/gh/nber1994/fu0k@master/uPic/MSCA4K20220116162440.jpg";

    var talk = [];
    talk[0] = "Help poor children in Uganda!";
    talk[1] = "Bad programmers worry about the code. Good programmers worry about data structures and their relationships.";
    talk[2] = "So, dear Redis community, today I’m stepping back as the Redis maintainer.";
    talk[3] = "Don't tune for speed until you've measured.";
    talk[4] = "C is quirky, flawed, and an enormous success.";
    talk[5] = "I've never thought of PHP as more than a simple tool to solve problems.";
    talk[6] = "Java is C++ without the guns, clubs and knives.";
    talk[7] = "Life is short, you need Python!";
    talk[8] = "C makes it easy to shoot yourself in the foot; C++ makes it harder, but when you do it blows your whole leg off.";

    var randomBgIndex = Math.floor( Math.random() * 8 );


    document.write("<img src=" + pic[randomBgIndex] + ">")
    document.write("<span style='font-size:12px'>" + talk[randomBgIndex] + " </span>")
    document.write("</div>")

</script>
</div>
<br>

	
	<main>
		<article>
			<h1>channel &amp; selelct</h1>
			<b><time>2020-11-23</time></b>
		       

			<div>
				<h1 id="并发编程模型">并发编程模型</h1>
<p><img src="https://cdn.jsdelivr.net/gh/nber1994/fu0k@master/uPic/cf91b4c995dd4ee2bbcf8662dd7d3e9120211227192856.jpeg" alt="img"></p>
<p>并发编程的意义，这个不需要多说了，大流量，高并发全靠它，性能上来了，稳定性也就不言而喻了</p>
<p>并发的两个基础部分：</p>
<ol>
<li>并发调度单位，concurrency unit</li>
<li>并发模型，concurrency model</li>
</ol>
<h2 id="concurrency-unit">Concurrency unit</h2>
<p>并发调度单位讲究 轻！快！</p>
<p>unit占用轻！unit切换快！</p>
<h3 id="进程作为unit">进程作为Unit</h3>
<p>进程拥有独占的内存和指令流，是一个应用的包装，但是进程作为并发基本单元有如下问题：</p>
<ol>
<li>资源占用过大
<ol>
<li>每个进程占用的内存太大了，进程携带了自己的虚拟内存页表，文件描述符等</li>
</ol>
</li>
<li>不能发挥多核的性能
<ol>
<li>进程不能很好的发挥多核机器的性能，常常出现一个核跑，多个核看的现象</li>
<li>
<img src="https://cdn.jsdelivr.net/gh/nber1994/fu0k@master/uPic/image-20211117181946354.png" alt="image-20211117181946354" style="zoom: 50%;" />
</li>
</ol>
</li>
<li>进程切换消耗过大
<ol>
<li>进程切换需要进行系统调用，涉及到内存从用户态拷贝至内核态</li>
<li>保存当前进程的现场，并且恢复下一个进程</li>
</ol>
</li>
</ol>
<img src="https://cdn.jsdelivr.net/gh/nber1994/fu0k@master/uPic/image-20211117192847504.png" alt="image-20211117192847504" style="zoom:50%;" />
<h3 id="线程作为unit">线程作为Unit</h3>
<p>线程较轻量级，一个进程可以包含多个线程，则每个最小并发粒度的资源占用要小很多，且同一个进程内线程间切换只需要对指令流进行切换即可。</p>
<img src="https://cdn.jsdelivr.net/gh/nber1994/fu0k@master/uPic/image-20211118005842113.png" alt="image-20211118005842113" style="zoom:50%;" />
<p>但是，进程间切换仍需要进入内核进行，仍然存在大量的并发切换消耗</p>
<h3 id="协程作为unit">协程作为Unit</h3>
<p>协程，也叫做<strong>用户态线程</strong>，它规避了最后一个问题，切换消耗过大的问题，无需通过系统调用进入内核进行切换，协程所有的生命周期均发生在用户态。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nber1994/fu0k@master/uPic/bVcTwI820211227195035.png" alt="img"></p>
<p>因为协程的优点，协程类编程也开始越来越火了。比较有代表性的有Go的goroutine、Erlang的Erlang进程、Scala的actor、windows下的fibre（纤程）等，一些动态语言像Python、Ruby、Lua也慢慢支持协程。</p>
<p><strong>但是</strong> 语言引入协程作为并发调度单位，需要实现自己的协程调度器、并提供协程间通信的方式等一系列支持模块，相较于传统的基于进程线程的并发方式，需要实现很多额外的功能组件。<strong>实现较复杂。</strong></p>
<h2 id="concurrency-model">Concurrency model</h2>
<p>总体来看，目前能找到的最轻量的调度单元就是协程了，虽然实现起来有些麻烦，但是现代语言也越来越多的引入协程了。</p>
<p>那么解决了并发单元的问题后，我们再研究下并发模型，为什么需要并发模型呢，因为<strong>并发就意味着竞争</strong>：对内存的竞争，对算力的竞争等，那么如何降低竞争带来的性能损耗，就需要并发模型的设计了。简单来说，并发模型就是指导并发单元以何种方式处理竞争，尽量减少竞争带来的性能损耗。简单来说，就是<strong>定义了并发单元间的通信方式</strong>。</p>
<h3 id="共享内存锁">共享内存+锁</h3>
<img src="https://cdn.jsdelivr.net/gh/nber1994/fu0k@master/uPic/image-2021122720381900520211227203819.png" alt="image-20211227203819005" style="zoom:50%;" />
<p>最经典的模型，通过锁来保护资源，多个并发单元访问资源前首先争夺锁，然后再去访问资源。没抢到锁的unit则阻塞等待。</p>
<p>这个应该是目前最常用的了，也最符合直觉，但是可以明显看到，在竞争时会产生<strong>阻塞耗时</strong>。</p>
<p><strong>这就是常说的使用共享内存来进行通信</strong></p>
<h3 id="函数式编程">函数式编程</h3>
<p><strong>既然基于共享内存通信会产生大量的竞争，那么函数式编程的通信思想是，在并发单元执行过程中不进行通信，只在最后大家都执行完后统一对结果做收集和汇总</strong></p>
<img src="https://coolshell.cn/wp-content/uploads/2013/12/yoda-lambda-204x300.png" alt="img" style="zoom: 50%;" />
<p>函数式编程的特性：</p>
<ol>
<li>不可变数据，默认是变量是不可变的，如果你要改变变量，你需要把变量copy出去</li>
<li>函数对于Input A一定会返回Output B，即<strong>函数内部没有状态</strong>，不会对全局变量进行修改，运行时涉及的变量都是局部变量</li>
<li>这么一来，每个函数对输入负责，只会访问局部变量，全局不存在资源竞争</li>
</ol>
<p>基于函数式编程模型作为并发模型的话，性能会很高，但是会产生额外的大量的局部变量</p>
<p><strong>代表语言：clojure</strong></p>
<h4 id="举个例子">举个例子：</h4>
<p>s3e在设计之初，提供了一套SDK，目的是帮助业务建模和模型可视化，大体是这样的，将一个业务功能节点抽象为了workflow，workflow中的每个task state对应一个函数，为了降低使用成本，各个函数的签名都是一致的</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#000;font-weight:bold">func</span> <span style="color:#900;font-weight:bold">Action</span>(ctx context.Context, db <span style="color:#000;font-weight:bold">*</span>Databus) (<span style="color:#000;font-weight:bold">*</span>Databus, <span style="color:#458;font-weight:bold">error</span>)
</code></pre></div><p>每个函数都会对Databus做一些自己的修改，这个修改是全局Action可见的（因为Databus传的是指针类型），因此如果存在并发的节点，会存在对全局变量的锁竞争。</p>
<p>但是在接入业务需求时，这套设计还好，不会产生太大的问题，但是在接入拦截系统时，由于拦截系统的比较大的诉求是希望引入并发带来对耗时的优化，如果仍然采用这种粗粒度锁的方式，竞争会比较大，可预见的性能优化不会太明显，如图</p>
<p><img src="https://cdn.jsdelivr.net/gh/nber1994/fu0k@master/uPic/image-2021122818275940220211228182800.png" alt="image-20211228182759402"></p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#000;font-weight:bold">type</span> Data <span style="color:#000;font-weight:bold">struct</span> {
	input 		<span style="color:#000;font-weight:bold">*</span>Input
  collector <span style="color:#000;font-weight:bold">*</span>ChekerCollector
}

<span style="color:#000;font-weight:bold">type</span> CheckerCollector <span style="color:#000;font-weight:bold">struct</span> {
  lock 			sync.Lock
	data <span style="color:#000;font-weight:bold">map</span>[<span style="color:#458;font-weight:bold">string</span>]<span style="color:#000;font-weight:bold">*</span>CheckRes
}

<span style="color:#000;font-weight:bold">func</span> (cc <span style="color:#000;font-weight:bold">*</span>CheckerCollector) <span style="color:#900;font-weight:bold">Report</span>(key <span style="color:#458;font-weight:bold">string</span>, res <span style="color:#000;font-weight:bold">*</span>CheckRes) {
  cc.lock.<span style="color:#900;font-weight:bold">Lock</span>()
  <span style="color:#000;font-weight:bold">map</span>[key] = res
  cc.lock.<span style="color:#900;font-weight:bold">Unlock</span>()
}
</code></pre></div><p>那么，采用函数式编程的思路，我们把databus尽量减少写操作，将需要写的字段分配到每个并发节点的运行时局部变量中，然后再对每个并发节点的结果做统一的收集，可以很好的减少并发竞争</p>
<p><img src="https://cdn.jsdelivr.net/gh/nber1994/fu0k@master/uPic/image-2021122818272690920211228182727.png" alt="image-20211228182726909"></p>
<h3 id="actor">Actor</h3>
<p>那么，我们回归到通信本身，有没有更好的通信方式呢？</p>
<p>Actor的主要思路是，每个并发单元抽象为actor，每个actor都拥有一个邮箱**，所有actor间的通信都会异步的发送到对方的邮箱中**，这样<strong>解耦了actor</strong>之间的关系，各个actor都能按照自己的步调进行执行，但是他们会按照邮箱中消息的发送顺序来依次处理消息，当且仅当前一个消息处理完成后，才会开始下一个消息处理，即<strong>保障了消息的时序性</strong>。</p>
<img src="https://cdn.jsdelivr.net/gh/nber1994/fu0k@master/uPic/image-2021122819182969720211228191830.png" alt="image-20211228191829697" style="zoom:67%;" />
<p>这样的话，在并发单元执行过程中，也不会存在锁资源的竞争，但是由于发送过程是异步的，即只将消息放入目标actor的邮箱中即完成了发送操作，但是消息什么时候会被目标actor处理，则是不可预测的。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nber1994/fu0k@master/uPic/image-2021122820544288320211228205443.png" alt="image-20211228205442883"></p>
<p><strong>代表语言：erlang，scala的akka库</strong></p>
<h3 id="csp">CSP</h3>
<p>csp的降低竞争的思想大体和actor保持一致，但是在消息发送上则采用了同步的方式，且与actor不同的是，csp关注的不是发送接受者，而是发送的媒介。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nber1994/fu0k@master/uPic/image-2021122820550199820211228205502.png" alt="image-20211228205501998"></p>
<p>并发单元间通过一个FIFO队列（channel）来进行通信，而不是直接和目标单元进行通信。</p>
<h4 id="actor和csp的区别">actor和csp的区别</h4>
<p><img src="https://cdn.jsdelivr.net/gh/nber1994/fu0k@master/uPic/image-2021122820562839520211228205629.png" alt="image-20211228205628395"></p>
<ol>
<li>actor的并发单元之间直接通信，csp则通过channel通信，后者显然耦合更松散</li>
<li>csp的消息交换是同步的，actor则是完全异步，可以在任意时间点发送消息到任何并发单元（甚至不存在的），并且actor可以自由选择处理哪些消息</li>
<li>相应的，csp的channel空间可以使有限的，而actor的邮箱理论上是需要无限大的</li>
<li>actor关注的是并发单元，而csp关注的则是channel</li>
</ol>
<h3 id="现实">现实</h3>
<p>现实上，几乎所有并发编程语言<strong>都支持锁+共享内存</strong>的形式进行并发单元通信，而对于支持函数式编程，actor和csp等概念的大部分语言，并没有严格完全按照模型定义实现，都在使用上或多或少的做了一些折中。</p>
<h1 id="channel">channel</h1>
<p>步入正题！</p>
<p>那么，显然golang深受csp模型的影响，channel和gorutinue是golang中的一等公民。</p>
<p>但是它又没有完全按照CSP理论中的channel来实现，CSP中的channel是一个纯粹的同步信道，而go channel不仅支持同步式通信，而且支持非同步式信道。</p>
<p>我们已经知道，channel本质上就是一个<strong>有锁的并发安全的FIFO消息队列</strong>，他负责在gorutinue之间传递消息。</p>
<h2 id="doc">Doc</h2>
<h3 id="类型">类型</h3>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go">ChannelType = ( <span style="color:#d14">&#34;chan&#34;</span> | <span style="color:#d14">&#34;chan&#34;</span> <span style="color:#d14">&#34;&lt;-&#34;</span> | <span style="color:#d14">&#34;&lt;-&#34;</span> <span style="color:#d14">&#34;chan&#34;</span> ) ElementType .
</code></pre></div><p>包含三种类型的定义，可选的'&lt;-&lsquo;代表了channel的方向，如果没有指定方向，channel就是双向的，可以接受数据，也可以发送数据。</p>
<p>举个例子：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go">		<span style="color:#000;font-weight:bold">var</span> ch1 <span style="color:#000;font-weight:bold">chan</span> <span style="color:#458;font-weight:bold">int</span>   <span style="color:#998;font-style:italic">// 声明一个传递整型的通道
</span><span style="color:#998;font-style:italic"></span>    <span style="color:#000;font-weight:bold">var</span> ch2 <span style="color:#000;font-weight:bold">chan</span> <span style="color:#458;font-weight:bold">bool</span>  <span style="color:#998;font-style:italic">// 声明一个传递布尔型的通道
</span><span style="color:#998;font-style:italic"></span>    <span style="color:#000;font-weight:bold">var</span> ch3 <span style="color:#000;font-weight:bold">chan</span> []<span style="color:#458;font-weight:bold">int</span> <span style="color:#998;font-style:italic">// 声明一个传递int切片的通道
</span></code></pre></div><h3 id="创建">创建</h3>
<p>channel是引用类型，channel的空值为nil</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#000;font-weight:bold">var</span> ch <span style="color:#000;font-weight:bold">chan</span> <span style="color:#458;font-weight:bold">int</span>
fmt.<span style="color:#900;font-weight:bold">Println</span>(ch) <span style="color:#998;font-style:italic">// &lt;nil&gt;
</span></code></pre></div><p>所以，通道在初始化后，还需要使用make函数进行初始化后才能使用</p>
<pre tabindex="0"><code>make(chan 元素类型, [缓冲大小])
</code></pre><p>缓冲区大小可选，举个例子</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go">ch4 <span style="color:#000;font-weight:bold">:=</span> <span style="color:#0086b3">make</span>(<span style="color:#000;font-weight:bold">chan</span> <span style="color:#458;font-weight:bold">int</span>)
ch5 <span style="color:#000;font-weight:bold">:=</span> <span style="color:#0086b3">make</span>(<span style="color:#000;font-weight:bold">chan</span> <span style="color:#458;font-weight:bold">bool</span> <span style="color:#099">10</span>)
ch6 <span style="color:#000;font-weight:bold">:=</span> <span style="color:#0086b3">make</span>(<span style="color:#000;font-weight:bold">chan</span> []<span style="color:#458;font-weight:bold">int</span> <span style="color:#099">1</span>)
</code></pre></div><h3 id="发送">发送</h3>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go">ch <span style="color:#000;font-weight:bold">&lt;-</span> <span style="color:#099">10</span> <span style="color:#998;font-style:italic">//将10发送到channel中
</span></code></pre></div><h3 id="接收">接收</h3>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go">x, ok <span style="color:#000;font-weight:bold">:=</span> <span style="color:#000;font-weight:bold">&lt;-</span> ch <span style="color:#998;font-style:italic">//判断ch是否已经关闭
</span><span style="color:#998;font-style:italic"></span>x <span style="color:#000;font-weight:bold">:=</span> <span style="color:#000;font-weight:bold">&lt;-</span> ch <span style="color:#998;font-style:italic">//从chan中接受值并赋值给x
</span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">&lt;-</span> ch <span style="color:#998;font-style:italic">//从ch中接收值并忽略
</span></code></pre></div><h3 id="关闭">关闭</h3>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#0086b3">close</span>(ch)	
</code></pre></div><p>Tips：</p>
<p>只有在需要通知接收方所有数据已经发送完毕时，才需要显式的调用close函数关闭chan，除此之外，若不对channel进行关闭操作，它是可以被垃圾回收机制回收的，<strong>关闭通道不是必须的</strong></p>
<p>通道关闭后：</p>
<ul>
<li>对一个关闭的channel再发送值回panic</li>
<li>对一个关闭的channel进行接收会一直获取值直到channel为空</li>
<li>对一个关闭的channel并且没有值的channel执行接收操作会得到类型的零值</li>
<li>重复关闭channel会panic</li>
</ul>
<h3 id="优雅的读取channel">优雅的读取channel</h3>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#998;font-style:italic">// channel 练习
</span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">func</span> <span style="color:#900;font-weight:bold">main</span>() {
    ch1 <span style="color:#000;font-weight:bold">:=</span> <span style="color:#0086b3">make</span>(<span style="color:#000;font-weight:bold">chan</span> <span style="color:#458;font-weight:bold">int</span>)
    ch2 <span style="color:#000;font-weight:bold">:=</span> <span style="color:#0086b3">make</span>(<span style="color:#000;font-weight:bold">chan</span> <span style="color:#458;font-weight:bold">int</span>)
    <span style="color:#998;font-style:italic">// 开启goroutine将0~100的数发送到ch1中
</span><span style="color:#998;font-style:italic"></span>    <span style="color:#000;font-weight:bold">go</span> <span style="color:#000;font-weight:bold">func</span>() {
        <span style="color:#000;font-weight:bold">for</span> i <span style="color:#000;font-weight:bold">:=</span> <span style="color:#099">0</span>; i &lt; <span style="color:#099">100</span>; i<span style="color:#000;font-weight:bold">++</span> {
            ch1 <span style="color:#000;font-weight:bold">&lt;-</span> i
        }
        <span style="color:#0086b3">close</span>(ch1)
    }()
    <span style="color:#998;font-style:italic">// 开启goroutine从ch1中接收值，并将该值的平方发送到ch2中
</span><span style="color:#998;font-style:italic"></span>    <span style="color:#000;font-weight:bold">go</span> <span style="color:#000;font-weight:bold">func</span>() {
        <span style="color:#000;font-weight:bold">for</span> {
            i, ok <span style="color:#000;font-weight:bold">:=</span> <span style="color:#000;font-weight:bold">&lt;-</span>ch1 <span style="color:#998;font-style:italic">// 通道关闭后再取值ok=false
</span><span style="color:#998;font-style:italic"></span>            <span style="color:#000;font-weight:bold">if</span> !ok {
                <span style="color:#000;font-weight:bold">break</span>
            }
            ch2 <span style="color:#000;font-weight:bold">&lt;-</span> i <span style="color:#000;font-weight:bold">*</span> i
        }
        <span style="color:#0086b3">close</span>(ch2)
    }()
    <span style="color:#998;font-style:italic">// 在主goroutine中从ch2中接收值打印
</span><span style="color:#998;font-style:italic"></span>    <span style="color:#000;font-weight:bold">for</span> i <span style="color:#000;font-weight:bold">:=</span> <span style="color:#000;font-weight:bold">range</span> ch2 { <span style="color:#998;font-style:italic">// 通道关闭后会退出for range循环
</span><span style="color:#998;font-style:italic"></span>        fmt.<span style="color:#900;font-weight:bold">Println</span>(i)
    }
}
</code></pre></div><p>可以看到👆的例子，存在两种接收channel的方式，并且都处理了channel关闭的情况，按照个人喜好选择吧。</p>
<h3 id="查看channel容量">查看channel容量</h3>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#0086b3">len</span>(ch) <span style="color:#998;font-style:italic">//查看ch缓冲区内的元素
</span><span style="color:#998;font-style:italic"></span><span style="color:#0086b3">cap</span>(ch) <span style="color:#998;font-style:italic">//查看ch缓冲区的最大容量
</span></code></pre></div><h2 id="无缓冲channel">无缓冲channel</h2>
<img src="https://cdn.jsdelivr.net/gh/nber1994/fu0k@master/uPic/image-2022010321131727020220103211317.png" alt="image-20220103211317270" style="zoom:67%;" />
<p>无缓冲区的channel又叫做阻塞channel，举个例子</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#000;font-weight:bold">func</span> <span style="color:#900;font-weight:bold">main</span>() {
	ch <span style="color:#000;font-weight:bold">:=</span> <span style="color:#0086b3">make</span>(<span style="color:#000;font-weight:bold">chan</span> <span style="color:#458;font-weight:bold">int</span>)
	ch <span style="color:#000;font-weight:bold">&lt;-</span> <span style="color:#099">9527</span>
	fmt.<span style="color:#900;font-weight:bold">Println</span>(<span style="color:#d14">&#34;OK&#34;</span>)
}
</code></pre></div><p>上面这段代码👆，执行时会报错吗</p>
<pre tabindex="0"><code>$ go run main.go
fatal error: all goroutines are asleep - deadlock!

goroutine 1 [chan send]:
main.main()
        /home/xiaoju/gulf/test/main.go:7 +0x54
exit status 2
</code></pre><p>简单来说，阻塞式的channel是需要先有接收者才能发送的，否则会一直阻塞，改进：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#000;font-weight:bold">func</span> <span style="color:#900;font-weight:bold">recv</span>(c <span style="color:#000;font-weight:bold">chan</span> <span style="color:#458;font-weight:bold">int</span>) {
    ret <span style="color:#000;font-weight:bold">:=</span> <span style="color:#000;font-weight:bold">&lt;-</span>c
    fmt.<span style="color:#900;font-weight:bold">Println</span>(<span style="color:#d14">&#34;recv ok&#34;</span>, ret)
}
<span style="color:#000;font-weight:bold">func</span> <span style="color:#900;font-weight:bold">main</span>() {
    ch <span style="color:#000;font-weight:bold">:=</span> <span style="color:#0086b3">make</span>(<span style="color:#000;font-weight:bold">chan</span> <span style="color:#458;font-weight:bold">int</span>)
    <span style="color:#000;font-weight:bold">go</span> <span style="color:#900;font-weight:bold">recv</span>(ch) <span style="color:#998;font-style:italic">// 启用goroutine从通道接收值
</span><span style="color:#998;font-style:italic"></span>    ch <span style="color:#000;font-weight:bold">&lt;-</span> <span style="color:#099">10</span>
    fmt.<span style="color:#900;font-weight:bold">Println</span>(<span style="color:#d14">&#34;ok&#34;</span>)
}
</code></pre></div><p>反之，当只有发送者时，发送者也会阻塞，等待接收者到来才能发送，因此，使用无缓冲channel进行通信将导致<strong>发送和接收的goroutine同步化</strong>，因此无缓冲channel也称为<strong>同步channel</strong>。</p>
<h2 id="有缓冲的channel">有缓冲的channel</h2>
<img src="https://cdn.jsdelivr.net/gh/nber1994/fu0k@master/uPic/image-2022010317133827620220103171339.png" alt="image-20220103171338276" style="zoom:67%;" />
<p>我们可以在channel初始化时声明其容量</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#000;font-weight:bold">func</span> <span style="color:#900;font-weight:bold">main</span>() {
    ch <span style="color:#000;font-weight:bold">:=</span> <span style="color:#0086b3">make</span>(<span style="color:#000;font-weight:bold">chan</span> <span style="color:#458;font-weight:bold">int</span>, <span style="color:#099">1</span>) <span style="color:#998;font-style:italic">// 创建一个容量为1的有缓冲区通道
</span><span style="color:#998;font-style:italic"></span>    ch <span style="color:#000;font-weight:bold">&lt;-</span> <span style="color:#099">10</span>
    fmt.<span style="color:#900;font-weight:bold">Println</span>(<span style="color:#d14">&#34;OK&#34;</span>)
}
</code></pre></div><p>只要缓冲区未满，则发送者发送消息不回阻塞，直到缓冲区满了之后，发送者发送消息才会阻塞，反之，缓冲区不空，接收者接收消息不阻塞，缓冲区空，接收者接收消息阻塞。</p>
<h2 id="源码总览">源码总览</h2>
<h3 id="主结构">主结构</h3>
<p><img src="https://cdn.jsdelivr.net/gh/nber1994/fu0k@master/uPic/image-2021122911302169020211229113022.png" alt="image-20211229113021690"></p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#000;font-weight:bold">type</span> hchan <span style="color:#000;font-weight:bold">struct</span> {
	qcount   <span style="color:#458;font-weight:bold">uint</span>           <span style="color:#998;font-style:italic">// 队列中的所有元素个数
</span><span style="color:#998;font-style:italic"></span>	dataqsiz <span style="color:#458;font-weight:bold">uint</span>           <span style="color:#998;font-style:italic">// ring buffer的大小
</span><span style="color:#998;font-style:italic"></span>	buf      unsafe.Pointer <span style="color:#998;font-style:italic">// ring buffer 数组实现
</span><span style="color:#998;font-style:italic"></span>	elemsize <span style="color:#458;font-weight:bold">uint16</span>					<span style="color:#998;font-style:italic">// 元素大小
</span><span style="color:#998;font-style:italic"></span>	closed   <span style="color:#458;font-weight:bold">uint32</span>					<span style="color:#998;font-style:italic">// 是否关闭
</span><span style="color:#998;font-style:italic"></span>	elemtype <span style="color:#000;font-weight:bold">*</span>_type <span style="color:#998;font-style:italic">// 元素类型
</span><span style="color:#998;font-style:italic"></span>	sendx    <span style="color:#458;font-weight:bold">uint</span>   <span style="color:#998;font-style:italic">// 发送的索引
</span><span style="color:#998;font-style:italic"></span>	recvx    <span style="color:#458;font-weight:bold">uint</span>   <span style="color:#998;font-style:italic">// 接受索引
</span><span style="color:#998;font-style:italic"></span>  recvq    waitq  <span style="color:#998;font-style:italic">// recv 等待队列 (&lt;-chane)
</span><span style="color:#998;font-style:italic"></span>  sendq    waitq  <span style="color:#998;font-style:italic">// send 等待列表 (chan&lt;-)
</span><span style="color:#998;font-style:italic"></span>
	lock mutex <span style="color:#998;font-style:italic">//锁
</span><span style="color:#998;font-style:italic"></span>}
</code></pre></div><p>为什么使用ringbuffer来存元素？首先，我们需要实现一个FIFO的队列，</p>
<p>那么第一反应是链表，新增和删除节点都是O(1)，但是链表在send操作时，需要重新分配内存创建一个链表节点。recv操作时，recv后的链表节点需要GC去识别与回收内存。这明显有点奢侈。</p>
<img src="https://cdn.jsdelivr.net/gh/nber1994/fu0k@master/uPic/image-2022010420102572120220104201026.png" alt="image-20220104201025721" style="zoom:50%;" />
<p>那么如果使用ringbuffer的话，首先，一次分配内存后，无论send还是recv操作，都不存在内存分配操作。而且由于数组的大小是固定的，可以直接将ringbuffer和hchan放入连续内存中，提高访问速度。</p>
<img src="https://cdn.jsdelivr.net/gh/nber1994/fu0k@master/uPic/image-2022010421265878120220104212659.png" alt="image-20220104212658781" style="zoom:50%;" />
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#000;font-weight:bold">type</span> waitq <span style="color:#000;font-weight:bold">struct</span> {
	first <span style="color:#000;font-weight:bold">*</span>sudog
	last  <span style="color:#000;font-weight:bold">*</span>sudog
}
</code></pre></div><div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#000;font-weight:bold">type</span> sudog <span style="color:#000;font-weight:bold">struct</span> {
    <span style="color:#998;font-style:italic">// The following fields are protected by the hchan.lock of the
</span><span style="color:#998;font-style:italic"></span>    <span style="color:#998;font-style:italic">// channel this sudog is blocking on. shrinkstack depends on
</span><span style="color:#998;font-style:italic"></span>    <span style="color:#998;font-style:italic">// this for sudogs involved in channel ops.
</span><span style="color:#998;font-style:italic"></span>  	<span style="color:#998;font-style:italic">//下面的字段，由hchan.lock保护
</span><span style="color:#998;font-style:italic"></span>    g <span style="color:#000;font-weight:bold">*</span>g

    <span style="color:#998;font-style:italic">// isSelect indicates g is participating in a select, so
</span><span style="color:#998;font-style:italic"></span>    <span style="color:#998;font-style:italic">// g.selectDone must be CAS&#39;d to win the wake-up race.
</span><span style="color:#998;font-style:italic"></span>  	<span style="color:#998;font-style:italic">// isSelect 标识 g 是否正在参与一个select，因此g.selectDone必须以 CAS 的方式来避免唤醒时的race
</span><span style="color:#998;font-style:italic"></span>    isSelect <span style="color:#458;font-weight:bold">bool</span>
    next     <span style="color:#000;font-weight:bold">*</span>sudog
    prev     <span style="color:#000;font-weight:bold">*</span>sudog
    elem     unsafe.Pointer <span style="color:#998;font-style:italic">// data element (may point to stack) 指向要发送或者接受的元素数据，可能指向栈
</span><span style="color:#998;font-style:italic"></span>
    <span style="color:#998;font-style:italic">// The following fields are never accessed concurrently.
</span><span style="color:#998;font-style:italic"></span>    <span style="color:#998;font-style:italic">// For channels, waitlink is only accessed by g.
</span><span style="color:#998;font-style:italic"></span>    <span style="color:#998;font-style:italic">// For semaphores, all fields (including the ones above)
</span><span style="color:#998;font-style:italic"></span>    <span style="color:#998;font-style:italic">// are only accessed when holding a semaRoot lock.
</span><span style="color:#998;font-style:italic"></span>  	<span style="color:#998;font-style:italic">//以下字段永远不会被并发访问，
</span><span style="color:#998;font-style:italic"></span>
    acquiretime <span style="color:#458;font-weight:bold">int64</span>
    releasetime <span style="color:#458;font-weight:bold">int64</span>
    ticket      <span style="color:#458;font-weight:bold">uint32</span>
    parent      <span style="color:#000;font-weight:bold">*</span>sudog <span style="color:#998;font-style:italic">// semaRoot binary tree
</span><span style="color:#998;font-style:italic"></span>    waitlink    <span style="color:#000;font-weight:bold">*</span>sudog <span style="color:#998;font-style:italic">// g.waiting list or semaRoot
</span><span style="color:#998;font-style:italic"></span>    waittail    <span style="color:#000;font-weight:bold">*</span>sudog <span style="color:#998;font-style:italic">// semaRoot
</span><span style="color:#998;font-style:italic"></span>    c           <span style="color:#000;font-weight:bold">*</span>hchan <span style="color:#998;font-style:italic">// channel 反向索引
</span><span style="color:#998;font-style:italic"></span>}
</code></pre></div><h2 id="创建-1">创建</h2>
<h2 id="发送-1">发送</h2>
<h2 id="接受">接受</h2>
<h2 id="关闭-1">关闭</h2>
<h1 id="select">select</h1>
<h2 id="分类">分类</h2>
<p>zero-case</p>
<p>uni-case</p>
<p>muilt-case</p>
<p>多个case，上一个case执行过程中，下一个case的chan有数据来了的话，会怎么做</p>

			</div>
		</article>
	</main>
<aside>
	<div>
		<div>
			<h1>LATEST POSTS</h1>
		</div>
		<div id='common-a'>
			<ul>
				
                <div id="lists">
                    <div id=date class="date-time-title">
                        <time>2022-01-15</time>
                    </div>
                    <div class="date-time-title post">
                        <a href="http://nber1994.github.io/posts/golang%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%E7%9A%84%E5%AE%9E%E7%8E%B0/">golang同步机制的实现</a>
                    </div>
                </div>
				
                <div id="lists">
                    <div id=date class="date-time-title">
                        <time>2021-11-25</time>
                    </div>
                    <div class="date-time-title post">
                        <a href="http://nber1994.github.io/posts/scheduler-%E4%B8%8A/">go-scheduler 上</a>
                    </div>
                </div>
				
                <div id="lists">
                    <div id=date class="date-time-title">
                        <time>2021-11-25</time>
                    </div>
                    <div class="date-time-title post">
                        <a href="http://nber1994.github.io/posts/scheduler-%E4%B8%8B/">go-scheduler 下</a>
                    </div>
                </div>
				
                <div id="lists">
                    <div id=date class="date-time-title">
                        <time>2020-11-24</time>
                    </div>
                    <div class="date-time-title post">
                        <a href="http://nber1994.github.io/posts/%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96php%E5%BC%95%E7%94%A8%E7%9A%84%E6%89%80%E6%9C%89%E8%84%9A%E6%9C%AC/">如何获取php引用的所有脚本</a>
                    </div>
                </div>
				
                <div id="lists">
                    <div id=date class="date-time-title">
                        <time>2020-11-23</time>
                    </div>
                    <div class="date-time-title post">
                        <a href="http://nber1994.github.io/posts/channel-select/">channel &amp; selelct</a>
                    </div>
                </div>
				
			</ul>
		</div>
	</div>
</aside>


	<footer>
    <div id='footer'>
	<p>&copy; 2022 <a href="http://nber1994.github.io/"><b>jingtianyou&#39;s blog</b></a>.
	</p>
    </div>
</footer>

</body>
</html>
